<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>andy Wong&#39;s Blog</title>
  
  <subtitle>知道的越多，不知道的越多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongdee.github.io/"/>
  <updated>2021-07-27T16:24:17.807Z</updated>
  <id>https://chongdee.github.io/</id>
  
  <author>
    <name>andy Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>闭包及应用场景</title>
    <link href="https://chongdee.github.io/2021/07/28/JavaScript/%E9%97%AD%E5%8C%85%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8/"/>
    <id>https://chongdee.github.io/2021/07/28/JavaScript/闭包场景应用/</id>
    <published>2021-07-27T16:23:16.454Z</published>
    <updated>2021-07-27T16:24:17.807Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><blockquote><p>在 JS 忍者秘籍(P90)中对闭包的定义：闭包允许函数访问并操作函数外部的变量。红宝书上对于闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。<br>MDN 对闭包的定义为：闭包是指那些能够访问自由变量的函数。这里的自由变量是外部函数作用域中的变量。</p><p>概述上面的话，闭包是指有权访问另一个函数作用域中变量的函数</p></blockquote><h2 id="形成闭包的原因"><a href="#形成闭包的原因" class="headerlink" title="形成闭包的原因"></a>形成闭包的原因</h2><p>内部的函数存在外部作用域的引用就会导致闭包。从上面介绍的上级作用域的概念中其实就有闭包的例子 return f就是一个表现形式。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = <span class="number">0</span></span><br><span class="line">function foo()&#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">b</span> =<span class="number">14</span></span><br><span class="line">    function fo()&#123;</span><br><span class="line">        console.log(<span class="selector-tag">a</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line">    fo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>这里的子函数 fo 内存就存在外部作用域的引用 a, b，所以这就会产生闭包</p><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><blockquote><p>保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。<br>保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化</p></blockquote><h2 id="使用闭包需要注意什么"><a href="#使用闭包需要注意什么" class="headerlink" title="使用闭包需要注意什么"></a>使用闭包需要注意什么</h2><p>容易导致内存泄漏。闭包会携带包含其它的函数作用域，因此会比其他函数占用更多的内存。过度使用闭包会导致内存占用过多，所以要谨慎使用闭包。</p><h2 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h2><h3 id="1-函数防抖"><a href="#1-函数防抖" class="headerlink" title="1.函数防抖"></a>1.函数防抖</h3><p>比如要缩放窗口 触发onresize 事件 需要在这时候做一件事情,但是我们希望拖动的时候只触发一次,比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'onresize'</span>)<span class="comment">//只想触发一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般方法vs闭包</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">window.onresize = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">debounce(fn,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"> var fn = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;    console.<span class="built_in">log</span>(<span class="string">'fn'</span>)</span><br><span class="line">&#125;</span><br><span class="line">var <span class="built_in">time</span> = <span class="string">''</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span><span class="params">(fn,timeLong)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">time</span>)&#123;</span><br><span class="line">            clearTimeout(<span class="built_in">time</span>)</span><br><span class="line">            <span class="built_in">time</span> = <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">time</span> =setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">         fn()</span><br><span class="line">        &#125;,timeLong)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = debounce(fn,<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;     <span class="comment">//timer第一次执行后会保存在内存里 永远都是执行器 直到最后被触发</span></span><br><span class="line">           clearTimeout(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">            fn()</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用闭包设计单例模式"><a href="#2-使用闭包设计单例模式" class="headerlink" title="2.使用闭包设计单例模式"></a>2.使用闭包设计单例模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理实现单例模式</span></span><br><span class="line"><span class="keyword">var</span> ProxyMode = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> CreateUser(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 测试单体模式的实例</span></span><br><span class="line"><span class="keyword">var</span> a = ProxyMode(<span class="string">"aaa"</span>);</span><br><span class="line"><span class="keyword">var</span> b = ProxyMode(<span class="string">"bbb"</span>);</span><br><span class="line"><span class="comment">// 因为单体模式是只实例化一次，所以下面的实例是相等的</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b);    <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="3-为多个组件独立属性"><a href="#3-为多个组件独立属性" class="headerlink" title="3.为多个组件独立属性"></a>3.为多个组件独立属性</h3><p>假如我现在要在页面中使用echarts画6个线状图，需要6个容器 </p><p>需要为每个容器元素声明一个独立id,不然会混乱</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>()&#123;</span><br><span class="line"> <span class="keyword">this</span>.state = &#123;<span class="attr">id</span>: <span class="string">"EchartsLine"</span>+Util.clourse()&#125;;</span><br><span class="line"> &#125;</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.myEChart =echarts.init(<span class="built_in">document</span>.getElementById(<span class="keyword">this</span>.state.id));<span class="comment">//不同id</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div</span><br><span class="line">    id=&#123;<span class="keyword">this</span>.state.id&#125;</span><br><span class="line">    </span><br><span class="line">    className=<span class="string">'echarts-line'</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">clourse()&#123;</span></span><br><span class="line"><span class="regexp">    let clourse = (function()&#123;</span></span><br><span class="line"><span class="regexp">        var a = 1;</span></span><br><span class="line"><span class="regexp">        return function()&#123;</span></span><br><span class="line"><span class="regexp">            return a++;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;)(this);</span></span><br><span class="line"><span class="regexp">    this.clourse = clourse;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/使用数字命名 不用害怕被篡改复制代码</span></span><br></pre></td></tr></table></figure><h3 id="4-设置私有变量"><a href="#4-设置私有变量" class="headerlink" title="4.设置私有变量"></a>4.设置私有变量</h3><p>内部属性 在java里使用private就可以,但是js 还没有这个东东</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _width = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Private</span> </span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(s) &#123;</span><br><span class="line">            <span class="keyword">this</span>[_width] = s</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        foo() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>[_width])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> Private(<span class="string">"50"</span>);</span><br><span class="line">    p.foo();</span><br><span class="line">    <span class="built_in">console</span>.log(p[_width]);<span class="comment">//可以拿到复制代码</span></span><br><span class="line">    <span class="comment">//赋值到闭包里</span></span><br><span class="line">    <span class="keyword">let</span> sque = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> _width = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Squery</span> </span>&#123;</span><br><span class="line">            <span class="keyword">constructor</span>(s) &#123;</span><br><span class="line">                <span class="keyword">this</span>[_width] = s</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            foo() &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>[_width])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Squery</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ss = <span class="keyword">new</span> sque(<span class="number">20</span>);</span><br><span class="line">    ss.foo();</span><br><span class="line">    <span class="built_in">console</span>.log(ss[_width])</span><br></pre></td></tr></table></figure><h3 id="5-拿到正确的值"><a href="#5-拿到正确的值" class="headerlink" title="5.拿到正确的值"></a>5.拿到正确的值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)<span class="comment">//10个10</span></span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遇到这种问题 如何用解决呢</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">var</span> i=0<span class="comment">;i&lt;10;i++)&#123;</span></span><br><span class="line">((<span class="name">j</span>)=&gt;&#123;</span><br><span class="line">  setTimeout(<span class="name">function</span>()&#123;</span><br><span class="line">        console.log(<span class="name">j</span>)//1-10</span><br><span class="line">    &#125;,<span class="number">1000</span>)&#125;)(<span class="name">i</span>)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理是 声明了10个自执行函数，保存当时的值到内部</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;闭包是什么&quot;&gt;&lt;a href=&quot;#闭包是什么&quot; class=&quot;headerlink&quot; title=&quot;闭包是什么&quot;&gt;&lt;/a&gt;闭包是什么&lt;/h2&gt;&lt;blockquote
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://chongdee.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://chongdee.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>react-redux一点就透</title>
    <link href="https://chongdee.github.io/2021/07/28/react/redux/react-redux%E4%B8%80%E7%82%B9%E5%B0%B1%E9%80%8F/"/>
    <id>https://chongdee.github.io/2021/07/28/react/redux/react-redux一点就透/</id>
    <published>2021-07-27T16:06:19.093Z</published>
    <updated>2021-07-27T16:08:17.663Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="1-目录"><a href="#1-目录" class="headerlink" title="1. 目录"></a>1. 目录</h2><ul><li>redux简介</li><li>案例</li><li>react-redux核心介绍</li></ul><h2 id="2-redux简介"><a href="#2-redux简介" class="headerlink" title="2. redux简介"></a>2. redux简介</h2><ul><li><p>redux是react全家桶的一员，它试图为 React 应用提供「可预测化的状态管理」机制。</p></li><li><p>Redux是将整个应用状态存储到到一个地方，称为store</p></li><li><p>里面保存一棵状态树(state tree)</p></li><li><p>组件可以派发(dispatch)行为(action)给store,而不是直接通知其它组件</p></li><li><p>其它组件可以通过订阅store中的状态(state)来刷新自己的视图</p></li></ul><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save redux</span></span><br></pre></td></tr></table></figure><h2 id="4-redux核心"><a href="#4-redux核心" class="headerlink" title="4. redux核心"></a>4. redux核心</h2><h3 id="4-1-State"><a href="#4-1-State" class="headerlink" title="4.1 State"></a>4.1 State</h3><p>state是数据集合</p><p><strong>可以理解为工厂加工商品所需的原材料</strong></p><h3 id="4-2-action"><a href="#4-2-action" class="headerlink" title="4.2 action"></a>4.2 action</h3><p>State的变化，会导致View的变化。但是，用户接触不到 State，只能接触到View 所以，State的变化必须是 View导致的。</p><p>action就是改变state的指令，有多少操作state的动作就会有多少action。</p><p><strong>可以将action理解为描述发生了什么的指示器</strong></p><h3 id="4-3-reducer-加工函数"><a href="#4-3-reducer-加工函数" class="headerlink" title="4.3 reducer 加工函数"></a>4.3 reducer 加工函数</h3><p>action发出命令后将state放入reucer加工函数中，返回新的state。<br>可以理解为加工的机器</p><h3 id="4-4-store"><a href="#4-4-store" class="headerlink" title="4.4 store"></a>4.4 store</h3><p><strong>store可以理解为有多个加工机器的总工厂</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let store</span> = createStore(reducers);</span><br></pre></td></tr></table></figure><p>Store 就是把它们联系到一起的对象。Store 有以下职责：</p><ul><li>维持应用的 state；</li><li>提供 getState() 方法获取 state；</li><li>提供 dispatch(action) 方法更新 state；</li><li>通过 subscribe(listener) 注册监听器;</li><li>通过 subscribe(listener) 返回的函数注销监听器。</li></ul><p>我们可以通过store.getState()来了解工厂中商品的状态，<br>使用store.dispatch发送action指令。</p><h2 id="5-经典案例"><a href="#5-经典案例" class="headerlink" title="5. 经典案例"></a>5. 经典案例</h2><p>这是一个redux的经典案例</p><ul><li>定义reducer函数根据action的类型改变state</li><li>actions 定义指令</li><li>通过createStore创建store</li><li>调用store.dispatch()发出修改state的命令</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = &#123;count: 0&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREASE'</span>: <span class="keyword">return</span> &#123;count: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREASE'</span>: <span class="keyword">return</span> &#123;count: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increase: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;<span class="keyword">type</span>: <span class="string">'INCREASE'</span>&#125;),</span><br><span class="line">  decrease: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;<span class="keyword">type</span>: <span class="string">'DECREASE'</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 1&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 2&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 3&#125;</span></span><br></pre></td></tr></table></figure><p>我们可以直接在react component上使用store.dispatch，但是这样不太方便，这个时候我们需要react-redux</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todos</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div onCLick=&#123;()=&gt;store.dispatch(actions.delTodo()) &#125;&gt;test&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-react-redux"><a href="#6-react-redux" class="headerlink" title="6. react-redux"></a>6. react-redux</h2><p>Redux 官方提供的 React 绑定库。 具有高效且灵活的特性。</p><h3 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1 安装"></a>6.1 安装</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save react-redux</span></span><br></pre></td></tr></table></figure><h3 id="6-2-核心"><a href="#6-2-核心" class="headerlink" title="6.2 核心"></a>6.2 核心</h3><ul><li>&lt; Provider store&gt;</li><li>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</li></ul><p>Provider 内的任何一个组件（比如这里的 Comp），如果需要使用 state 中的数据，就必须是「被 connect 过的」组件——使用 connect 方法对「你编写的组件（MyComp）」进行包装后的产物。</p><p>这个函数允许我们将 store 中的数据作为 props 绑定到组件上。<br>简单的流程如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95e279721bec4ec4a9f3314a470d2f9c~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p><p>react-redux中的connect方法将store上的getState 和 dispatch 包装成组件的props。<br>将之前直接在组件上dispatch的代码修改为如下：</p><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span>;</span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'../store/actions/list'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todos</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div onCLick=&#123;()=&gt;<span class="keyword">this</span>.props.del_todo() &#125;&gt;test&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default connect(</span></span><br><span class="line"><span class="regexp">    state=&gt;state,</span></span><br><span class="line"><span class="regexp">    actions</span></span><br><span class="line"><span class="regexp">)(Todos);</span></span><br></pre></td></tr></table></figure><p>Provider 能拿到关键的store并传递给每个子组件</p><h2 id="7-connect如何工作的？"><a href="#7-connect如何工作的？" class="headerlink" title="7. connect如何工作的？"></a>7. connect如何工作的？</h2><p>connect() 接收四个参数，它们分别是 mapStateToProps ， mapDispatchToProps， mergeProps 和 options 。</p><h3 id="7-1-mapStateToProps这个函数允许我们将-store-中的数据作为-props-绑定到组件上。"><a href="#7-1-mapStateToProps这个函数允许我们将-store-中的数据作为-props-绑定到组件上。" class="headerlink" title="7.1 mapStateToProps这个函数允许我们将 store 中的数据作为 props 绑定到组件上。"></a>7.1 mapStateToProps这个函数允许我们将 store 中的数据作为 props 绑定到组件上。</h3><p>reducer.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> function (<span class="keyword">state</span> = &#123; lists: [&#123;text:'移动端计划'&#125;],newType:'<span class="literal">all</span>'&#125;, action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case types.ADD_TODO:</span><br><span class="line">            return &#123;...<span class="keyword">state</span>,lists:[...<span class="keyword">state</span>.lists,&#123;text:action.text&#125;]&#125;</span><br><span class="line">        case types.TOGGLE_TODO:</span><br><span class="line">            return &#123;...<span class="keyword">state</span>,lists:<span class="keyword">state</span>.lists.map((item,index)=&gt;&#123;</span><br><span class="line">                if(index == action.index)&#123;</span><br><span class="line">                    item.completed = !item.completed</span><br><span class="line">                &#125;</span><br><span class="line">                return item</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        case types.DEL_TODO:</span><br><span class="line">            return &#123;...<span class="keyword">state</span>,lists:[...<span class="keyword">state</span>.lists.slice(<span class="number">0</span>,action.index),...<span class="keyword">state</span>.lists.slice(action.index+<span class="number">1</span>)]&#125;</span><br><span class="line">        case types.SWITCH_TYPE:</span><br><span class="line">            console.<span class="keyword">log</span>(&#123;...<span class="keyword">state</span>,newType:action.newType&#125;)</span><br><span class="line">            return &#123;...<span class="keyword">state</span>,newType:action.newType&#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            return <span class="keyword">state</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在reducer.js中，定义了初始化的state，通过connect方法，我们就能使用this.props.lists拿到初始化的state。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"><span class="keyword">import</span> store from '../store';</span><br><span class="line"><span class="keyword">import</span> actions from '../store/actions/list';</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; from <span class="symbol">'react</span>-redux';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todos</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &#123;</span><br><span class="line">                + &lt;ul&gt;</span><br><span class="line">                +    <span class="keyword">this</span>.props.state.lists.map(list =&gt;(</span><br><span class="line">                +        &lt;li&gt;&#123;list.text&#125;&lt;/li&gt;</span><br><span class="line">                +    ))</span><br><span class="line">                + &lt;/ul&gt;   </span><br><span class="line">            &#125;</span><br><span class="line">            &lt;div onCLick=&#123;()=&gt;<span class="keyword">this</span>.props.del_todo() &#125;&gt;test&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> connect(</span><br><span class="line">    state=&gt;state,</span><br><span class="line">    actions</span><br><span class="line">)(<span class="type">Todos</span>);</span><br></pre></td></tr></table></figure><p>当 state 变化，或者 ownProps 变化的时候，mapStateToProps 都会被调用，计算出一个新的 stateProps，（在与 ownProps merge 后）更新给 MyComp。</p><p>7.2 mapDispatchToProps(dispatch, ownProps): dispatchProps connect 的第二个参数是 mapDispatchToProps，它的功能是，将 action 作为 props 绑定到 MyComp 上。</p><p>action.js</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import * <span class="keyword">as</span> types from <span class="string">"../action-types"</span>;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span>&#123;</span><br><span class="line">    add_todo(text)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="class"><span class="keyword">type</span>: <span class="title">types</span>.<span class="title">ADD_TODO</span>, <span class="title">text</span>: <span class="title">text</span>&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    del_todo(idx)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="class"><span class="keyword">type</span>:<span class="title">types</span>.<span class="title">DEL_TODO</span>, <span class="title">index</span>: <span class="title">idx</span>&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    toggle_todo(index)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="class"><span class="keyword">type</span>:<span class="title">types</span>.<span class="title">TOGGLE_TODO</span>, <span class="title">index</span>&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    del_todo(index)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="class"><span class="keyword">type</span>:<span class="title">types</span>.<span class="title">DEL_TODO</span>, <span class="title">index</span>&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    switch_type(newType)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="class"><span class="keyword">type</span>:<span class="title">types</span>.<span class="title">SWITCH_TYPE</span>, <span class="title">newType</span>&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在action.js中定义的修改状态的命令，会通过connect 的 mapDispatchToProps方法变为props绑定在reac组件上。<br>我们可以方便得使用去调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> onCLick=&#123;()=&gt;this<span class="selector-class">.props</span><span class="selector-class">.del_todo</span>() &#125;&gt;test&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="8-深入"><a href="#8-深入" class="headerlink" title="8. 深入"></a>8. 深入</h2><p>了解到这里，我们会发现并没有使用store.dispatch方法去发出命令，但是state已经修改，view也变化了，那么到底发生了什么？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">store</span><span class="selector-class">.dispatch</span>(<span class="selector-tag">actions</span><span class="selector-class">.increase</span>())</span><br></pre></td></tr></table></figure><p><strong>关键的是connect()</strong></p><p>connect原理简化版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;bindActionCreators&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> propTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">mapStateToProps,mapDispatchToProps</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">WrapedComponent</span>)</span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">ProxyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">          <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">              store:propTypes.object</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">constructor</span>(props,context)&#123;</span><br><span class="line">            <span class="keyword">super</span>(props,context);</span><br><span class="line">            <span class="keyword">this</span>.store = context.store;</span><br><span class="line">            <span class="keyword">this</span>.state = mapStateToProps(<span class="keyword">this</span>.store.getState());</span><br><span class="line">          &#125;</span><br><span class="line">          componentWillMount()&#123;</span><br><span class="line">              <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.store.subscribe(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                  <span class="keyword">this</span>.setState(mapStateToProps(<span class="keyword">this</span>.store.getState()));</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          componentWillUnmount()&#123;</span><br><span class="line">              <span class="keyword">this</span>.unsubscribe();</span><br><span class="line">          &#125;</span><br><span class="line">          render()&#123;</span><br><span class="line">              <span class="keyword">let</span> actions= &#123;&#125;;</span><br><span class="line">              <span class="keyword">if</span>(<span class="keyword">typeof</span> mapDispatchToProps == <span class="string">'function'</span>)&#123;</span><br><span class="line">                actions = mapDispatchToProps(<span class="keyword">this</span>.store.disaptch);</span><br><span class="line">              &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> mapDispatchToProps == <span class="string">'object'</span>)&#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(<span class="string">'object'</span>, mapDispatchToProps)</span><br><span class="line">                actions = bindActionCreators(mapDispatchToProps,<span class="keyword">this</span>.store.dispatch);</span><br><span class="line">              &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapedComponent</span> &#123;<span class="attr">...this.state</span>&#125; &#123;<span class="attr">...actions</span>&#125;/&gt;</span></span></span><br><span class="line"><span class="xml">         &#125;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      return ProxyComponent;</span></span><br><span class="line"><span class="xml">   &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>1.state的返回<br>connect中对于Provided父组件上传来的store,通过将状态返回</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapStateToProps(<span class="name">this</span>.store.getState())<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>通过 Redux 的辅助函数 bindActionCreators()，用dispatch监听每一个action。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bindActionCreators</span>(<span class="selector-tag">mapDispatchToProps</span>,<span class="selector-tag">this</span><span class="selector-class">.store</span><span class="selector-class">.dispatch</span>);</span><br></pre></td></tr></table></figure><p>所以调用props上的方法时，会自动发起store.dispach（XXX）事件，发出命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;1-目录&quot;&gt;&lt;a href=&quot;#1-目录&quot; class=&quot;headerlink&quot; title=&quot;1. 目录&quot;&gt;&lt;/a&gt;1. 目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;redu
      
    
    </summary>
    
      <category term="react" scheme="https://chongdee.github.io/categories/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/categories/react/redux/"/>
    
    
      <category term="react" scheme="https://chongdee.github.io/tags/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>redux入门（二）</title>
    <link href="https://chongdee.github.io/2021/07/28/react/redux/redux%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://chongdee.github.io/2021/07/28/react/redux/redux入门（二）/</id>
    <published>2021-07-27T16:06:18.789Z</published>
    <updated>2021-07-27T16:07:19.013Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="中间件与异步操作"><a href="#中间件与异步操作" class="headerlink" title="中间件与异步操作"></a>中间件与异步操作</h2><p>上一篇文章，我介绍了 Redux 的基本做法：用户发出 Action，Reducer 函数算出新的 State，View 重新渲染。</p><p>但是，一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。</p><p>怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：<strong>中间件（middleware）。</strong></p><h2 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h2><p>为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？</p><ul><li>（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</li><li>（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</li><li>（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</li></ul><p>想来想去，只有发送 Action 的这个步骤，即store.dispatch()方法，可以添加功能。举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对store.dispatch进行如下改造。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="built_in">next</span> = store.dispatch;</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span><span class="params">(action)</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'dispatching'</span>, action);</span><br><span class="line">  <span class="built_in">next</span>(action);</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'next state'</span>, store.getState());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，对store.dispatch进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。</p><p>中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p><h2 id="二、中间件的用法"><a href="#二、中间件的用法" class="headerlink" title="二、中间件的用法"></a>二、中间件的用法</h2><p>本教程不涉及如何编写中间件，因为常用的中间件都有现成的，只要引用别人写好的模块即可。比如，上一节的日志中间件，就有现成的redux-logger模块。这里只介绍怎么使用中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">'redux-logger'</span>;</span><br><span class="line"><span class="keyword">const</span> logger = createLogger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，redux-logger提供一个生成器createLogger，可以生成日志中间件logger。然后，将它放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强。</p><p>这里有两点需要注意：</p><p>（1）createStore方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware就是第三个参数了。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  initial_state,</span><br><span class="line">  applyMiddleware(<span class="name">logger</span>)</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>（2）中间件的次序有讲究。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(<span class="name">thunk</span>, promise, logger)</span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面代码中，applyMiddleware方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，logger就一定要放在最后，否则输出结果会不正确。</p><h2 id="三、applyMiddlewares"><a href="#三、applyMiddlewares" class="headerlink" title="三、applyMiddlewares()"></a>三、applyMiddlewares()</h2><p>看到这里，你可能会问，applyMiddlewares这个方法到底是干什么的？</p><p>它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span><span class="params">(<span class="rest_arg">...middlewares</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);</span><br><span class="line">    <span class="keyword">var</span> dispatch = store.dispatch;</span><br><span class="line">    <span class="keyword">var</span> chain = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: (action) =&gt; dispatch(action)</span><br><span class="line">    &#125;;</span><br><span class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;...store, dispatch&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，所有中间件被放进了一个数组chain，然后嵌套执行，最后执行store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法。</p><h2 id="四、异步操作的基本思路"><a href="#四、异步操作的基本思路" class="headerlink" title="四、异步操作的基本思路"></a>四、异步操作的基本思路</h2><p>理解了中间件以后，就可以处理异步操作了。</p><p>同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</p><ul><li>操作发起时的 Action</li><li>操作成功时的 Action</li><li>操作失败时的 Action<br>以向服务器取出数据为例，三种 Action 可以有两种不同的写法。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一：名称相同，参数不同</span></span><br><span class="line">&#123; <span class="string">type:</span> <span class="string">'FETCH_POSTS'</span> &#125;</span><br><span class="line">&#123; <span class="string">type:</span> <span class="string">'FETCH_POSTS'</span>, <span class="string">status:</span> <span class="string">'error'</span>, <span class="string">error:</span> <span class="string">'Oops'</span> &#125;</span><br><span class="line">&#123; <span class="string">type:</span> <span class="string">'FETCH_POSTS'</span>, <span class="string">status:</span> <span class="string">'success'</span>, <span class="string">response:</span> &#123; ... &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：名称不同</span></span><br><span class="line">&#123; <span class="string">type:</span> <span class="string">'FETCH_POSTS_REQUEST'</span> &#125;</span><br><span class="line">&#123; <span class="string">type:</span> <span class="string">'FETCH_POSTS_FAILURE'</span>, <span class="string">error:</span> <span class="string">'Oops'</span> &#125;</span><br><span class="line">&#123; <span class="string">type:</span> <span class="string">'FETCH_POSTS_SUCCESS'</span>, <span class="string">response:</span> &#123; ... &#125; &#125;</span><br></pre></td></tr></table></figure><p>除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">state</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span> </span><br><span class="line"><span class="attr">  isFetching:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">  didInvalidate:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">  lastUpdated:</span> <span class="string">'xxxxxxx'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>上面代码中，State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间。</p><p>现在，整个异步操作的思路就很清楚了。</p><ul><li>操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染</li><li>操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染<h2 id="五、redux-thunk-中间件"><a href="#五、redux-thunk-中间件" class="headerlink" title="五、redux-thunk 中间件"></a>五、redux-thunk 中间件</h2>异步操作至少要送出两个 Action：用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？</li></ul><p>奥妙就在 Action Creator 之中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; dispatch, selectedPost &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    dispatch(fetchPosts(selectedPost))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>上面代码是一个异步组件的例子。加载成功后（componentDidMount方法），它送出了（dispatch方法）一个 Action，向服务器要求数据 fetchPosts(selectedSubreddit)。这里的fetchPosts就是 Action Creator。</p><p>下面就是fetchPosts的代码，关键之处就在里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPosts = <span class="function"><span class="params">postTitle</span> =&gt;</span> (dispatch, getState) =&gt; &#123;</span><br><span class="line">  dispatch(requestPosts(postTitle));</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`/some/API/<span class="subst">$&#123;postTitle&#125;</span>.json`</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">    .then(<span class="function"><span class="params">json</span> =&gt;</span> dispatch(receivePosts(postTitle, json)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法一</span></span><br><span class="line">store.dispatch(fetchPosts(<span class="string">'reactjs'</span>));</span><br><span class="line"><span class="comment">// 使用方法二</span></span><br><span class="line">store.dispatch(fetchPosts(<span class="string">'reactjs'</span>)).then(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，fetchPosts是一个Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个Action（requestPosts(postTitle)），然后进行异步操作。拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ receivePosts(postTitle, json)）。</p><p>上面代码中，有几个地方需要注意。</p><p>（1）fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象。</p><p>（2）返回的函数的参数是dispatch和getState这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。</p><p>（3）在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始。</p><p>（4）异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束。</p><p>这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由store.dispatch方法发送的。而store.dispatch方法正常情况下，参数只能是对象，不能是函数。</p><p>这时，就要使用中间件redux-thunk。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: this API requires redux@&gt;=3.1.0</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。</p><p>因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch。</p><h2 id="六、redux-promise-中间件"><a href="#六、redux-promise-中间件" class="headerlink" title="六、redux-promise 中间件"></a>六、redux-promise 中间件</h2><p>既然 Action Creator 可以返回函数，当然也可以返回其他值。另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象。</p><p>这就需要使用redux-promise中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> promiseMiddleware <span class="keyword">from</span> <span class="string">'redux-promise'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(promiseMiddleware)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这个中间件使得store.dispatch方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fetchPosts = </span><br><span class="line">  (<span class="name">dispatch</span>, postTitle) =&gt; new Promise(<span class="name">function</span> (<span class="name">resolve</span>, reject) &#123;</span><br><span class="line">     dispatch(<span class="name">requestPosts</span>(<span class="name">postTitle</span>))<span class="comment">;</span></span><br><span class="line">     return fetch(`/some/API/$&#123;postTitle&#125;.json`)</span><br><span class="line">       .then(<span class="name">response</span> =&gt; &#123;</span><br><span class="line">         type: 'FETCH_POSTS',</span><br><span class="line">         payload: response.json()</span><br><span class="line">       &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>写法二，Action 对象的payload属性是一个 Promise 对象。这需要从redux-actions模块引入createAction方法，并且写法也要变成下面这样。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createAction &#125; from <span class="symbol">'redux</span>-actions';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; dispatch, selectedPost &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="comment">// 发出同步 Action</span></span><br><span class="line">    dispatch(requestPosts(selectedPost));</span><br><span class="line">    <span class="comment">// 发出异步 Action</span></span><br><span class="line">    dispatch(createAction(</span><br><span class="line">      <span class="symbol">'FETCH_POST</span>S', </span><br><span class="line">      fetch(`/some/<span class="type">API</span>/$&#123;postTitle&#125;.json`)</span><br><span class="line">        .then(response =&gt; response.json())</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个dispatch方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出。注意，createAction的第二个参数必须是一个 Promise 对象。</p><p>看一下redux-promise的源码，就会明白它内部是怎么操作的。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span></span> promiseMiddleware(&#123; dispatch &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> next =&gt; <span class="keyword">action</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">!isFSA(action)) &#123;</span></span><br><span class="line">      <span class="keyword">return</span> isPromise(<span class="keyword">action</span>)</span><br><span class="line">        ? <span class="keyword">action</span>.<span class="keyword">then</span>(dispatch)</span><br><span class="line">        : next(<span class="keyword">action</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isPromise(<span class="keyword">action</span>.payload)</span><br><span class="line">      ? <span class="keyword">action</span>.payload.<span class="keyword">then</span>(</span><br><span class="line">          result =&gt; dispatch(&#123; ...<span class="keyword">action</span>, payload: result &#125;),</span><br><span class="line">          error =&gt; &#123;</span><br><span class="line">            dispatch(&#123; ...<span class="keyword">action</span>, payload: error, error: true &#125;);</span><br><span class="line">            <span class="keyword">return</span> Promise.reject(error);</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      : next(<span class="keyword">action</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，如果 Action 本身是一个 Promise，它 resolve 以后的值应该是一个 Action 对象，会被dispatch方法送出（action.then(dispatch)），但 reject 以后不会有任何动作；如果 Action 对象的payload属性是一个 Promise 对象，那么无论 resolve 和 reject，dispatch方法都会发出 Action。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;中间件与异步操作&quot;&gt;&lt;a href=&quot;#中间件与异步操作&quot; class=&quot;headerlink&quot; title=&quot;中间件与异步操作&quot;&gt;&lt;/a&gt;中间件与异步操作&lt;/h2
      
    
    </summary>
    
      <category term="react" scheme="https://chongdee.github.io/categories/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/categories/react/redux/"/>
    
    
      <category term="react" scheme="https://chongdee.github.io/tags/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>redux入门（三）</title>
    <link href="https://chongdee.github.io/2021/07/28/react/redux/redux%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://chongdee.github.io/2021/07/28/react/redux/redux入门（三）/</id>
    <published>2021-07-27T16:06:18.403Z</published>
    <updated>2021-07-27T16:07:52.561Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Redux-入门教程（三）：React-Redux-的用法"><a href="#Redux-入门教程（三）：React-Redux-的用法" class="headerlink" title="Redux 入门教程（三）：React-Redux 的用法"></a>Redux 入门教程（三）：React-Redux 的用法</h2><p>前两篇教程介绍了 Redux 的基本用法和异步操作，今天是最后一部分，介绍如何在 React 项目中使用 Redux。</p><p>为了方便使用，Redux 的作者封装了一个 React 专用的库 React-Redux，本文主要介绍它。</p><p>这个库是可以选用的。实际项目中，你应该权衡一下，是直接使用 Redux，还是使用 React-Redux。后者虽然提供了便利，但是需要掌握额外的 API，并且要遵守它的组件拆分规范。</p><h2 id="一、UI-组件"><a href="#一、UI-组件" class="headerlink" title="一、UI 组件"></a>一、UI 组件</h2><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。</p><p>UI 组件有以下几个特征。</p><ul><li>只负责 UI 的呈现，不带有任何业务逻辑</li><li>没有状态（即不使用this.state这个变量）</li><li>所有数据都由参数（this.props）提供</li><li>不使用任何 Redux 的 API</li></ul><p>下面就是一个 UI 组件的例子。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Title =</span><br><span class="line">  <span class="keyword">value</span> =&gt; &lt;h1&gt;&#123;<span class="keyword">value</span>&#125;&lt;/h1&gt;;</span><br></pre></td></tr></table></figure><p>因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值。</p><h2 id="二、容器组件"><a href="#二、容器组件" class="headerlink" title="二、容器组件"></a>二、容器组件</h2><p>容器组件的特征恰恰相反。</p><ul><li>负责管理数据和业务逻辑，不负责 UI 的呈现</li><li>带有内部状态</li><li>使用 Redux 的 API</li></ul><p>总之，只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p><p>你可能会问，如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。</p><p>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p><h2 id="三、connect"><a href="#三、connect" class="headerlink" title="三、connect()"></a>三、connect()</h2><p>React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="built_in">connect</span> &#125; from <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = <span class="built_in">connect</span>()(TodoList);</span><br></pre></td></tr></table></figure><p>上面代码中，TodoList是 UI 组件，VisibleTodoList就是由 React-Redux 通过connect方法自动生成的容器组件。</p><p>但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。</p><p>（1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数</p><p>（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。</p><p>因此，connect方法的完整 API 如下。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="built_in">connect</span> &#125; from <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = <span class="built_in">connect</span>(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure><p>上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p><h2 id="四、mapStateToProps"><a href="#四、mapStateToProps" class="headerlink" title="四、mapStateToProps()"></a>四、mapStateToProps()</h2><p>mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。</p><p>作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (<span class="keyword">state</span>) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    todos: getVisibleTodos(<span class="keyword">state</span>.todos, <span class="keyword">state</span>.visibilityFilter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。</p><p>下面就是getVisibleTodos的一个例子，用来算出todos。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (filter) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'SHOW_ALL'</span>:</span><br><span class="line">      <span class="keyword">return</span> todos</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'SHOW_COMPLETED'</span>:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> t.completed)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'SHOW_ACTIVE'</span>:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unknown filter: '</span> + filter)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p><p>mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 容器组件的代码</span><br><span class="line">//    <span class="variable">&lt;FilterLink filter="SHOW_ALL"&gt;</span></span><br><span class="line">//      All</span><br><span class="line">//    &lt;/FilterLink&gt;</span><br><span class="line"></span><br><span class="line">const mapStateToProps = (<span class="keyword">state</span>, ownProps) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    active: ownProps.filter === <span class="keyword">state</span>.visibilityFilter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</p><p>connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p><h2 id="五、mapDispatchToProps"><a href="#五、mapDispatchToProps" class="headerlink" title="五、mapDispatchToProps()"></a>五、mapDispatchToProps()</h2><p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p><p>如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = (</span><br><span class="line">  dispatch,</span><br><span class="line">  ownProps</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">        filter: ownProps.filter</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p><p>如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  onClick: (<span class="built_in">filter</span>) =&gt; &#123;</span><br><span class="line">    type: <span class="string">'SET_VISIBILITY_FILTER'</span>,</span><br><span class="line">    <span class="built_in">filter</span>: <span class="built_in">filter</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、-组件"><a href="#六、-组件" class="headerlink" title="六、 组件"></a>六、<provider> 组件</provider></h2><p>connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。</p><p>一种解决方法是将state对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将state传下去就很麻烦。</p><p>React-Redux 提供Provider组件，可以让容器组件拿到state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。</p><p>它的原理是React组件的context属性，请看源码。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store: <span class="keyword">this</span>.props.store</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Provider</span>.childContextTypes = &#123;</span><br><span class="line">  store: <span class="type">React</span>.<span class="type">PropTypes</span>.<span class="keyword">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，store放在了上下文对象context上面。然后，子组件就可以从context拿到store，代码大致如下。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisibleTodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    const &#123; store &#125; = <span class="keyword">this</span>.context;</span><br><span class="line">    <span class="keyword">this</span>.unsubscribe = store.subscribe(() =&gt;</span><br><span class="line">      <span class="keyword">this</span>.forceUpdate()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const props = <span class="keyword">this</span>.props;</span><br><span class="line">    const &#123; store &#125; = <span class="keyword">this</span>.context;</span><br><span class="line">    const state = store.getState();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">VisibleTodoList</span>.contextTypes = &#123;</span><br><span class="line">  store: <span class="type">React</span>.<span class="type">PropTypes</span>.<span class="keyword">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React-Redux自动生成的容器组件的代码，就类似上面这样，从而拿到store。</p><h2 id="七、实例：计数器"><a href="#七、实例：计数器" class="headerlink" title="七、实例：计数器"></a>七、实例：计数器</h2><p>我们来看一个实例。下面是一个计数器组件，它是一个纯的 UI 组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value, onIncreaseClick &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;&#123;value&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;onIncreaseClick&#125;&gt;Increase&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，这个 UI 组件有两个参数：value和onIncreaseClick。前者需要从state计算得到，后者需要向外发出 Action。</p><p>接着，定义value到state的映射，以及onIncreaseClick到dispatch的映射。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onIncreaseClick: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(increaseAction)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Action Creator</span></span><br><span class="line"><span class="keyword">const</span> increaseAction = &#123; <span class="attr">type</span>: <span class="string">'increase'</span> &#125;</span><br></pre></td></tr></table></figure><p>然后，使用connect方法生成容器组件。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const App = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(<span class="name">Counter</span>)</span><br></pre></td></tr></table></figure><p>然后，定义这个组件的 Reducer。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Reducer</span><br><span class="line">function counter(<span class="keyword">state</span> = &#123; count: <span class="number">0</span> &#125;, action) &#123;</span><br><span class="line">  const count = <span class="keyword">state</span>.count</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case 'increase':</span><br><span class="line">      return &#123; count: count + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      return <span class="keyword">state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，生成store对象，并使用Provider在根组件外面包一层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loadState, saveState &#125; <span class="keyword">from</span> <span class="string">'./localStorage'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> persistedState = loadState();</span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  todoApp,</span><br><span class="line">  persistedState</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.subscribe(throttle(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  saveState(&#123;</span><br><span class="line">    todos: store.getState().todos,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><h2 id="八、React-Router-路由库"><a href="#八、React-Router-路由库" class="headerlink" title="八、React-Router 路由库"></a>八、React-Router 路由库</h2><p>使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层，毕竟Provider的唯一功能就是传入store对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Root = <span class="function">(<span class="params">&#123; store &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Provider&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Redux-入门教程（三）：React-Redux-的用法&quot;&gt;&lt;a href=&quot;#Redux-入门教程（三）：React-Redux-的用法&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="react" scheme="https://chongdee.github.io/categories/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/categories/react/redux/"/>
    
    
      <category term="react" scheme="https://chongdee.github.io/tags/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>redux、react-redux、redux-saga总结</title>
    <link href="https://chongdee.github.io/2021/07/28/react/redux/redux%E3%80%81react-redux%E3%80%81redux-saga%E6%80%BB%E7%BB%93/"/>
    <id>https://chongdee.github.io/2021/07/28/react/redux/redux、react-redux、redux-saga总结/</id>
    <published>2021-07-27T16:06:18.045Z</published>
    <updated>2021-07-27T16:09:03.755Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p>React有props和state:</p><ol><li>props意味着父级分发下来的属性</li><li>state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，这就是react的单向数据流</li></ol><p>这就意味着如果是一个数据状态非常复杂的应用，更多的时候发<strong>现React根本无法让两个组件互相交流</strong>，使用对方的数据，react的通过层级传递数据的这种方法是非常难受的，这个时候，迫切需要一个机制：</p><p><strong>把所有的state集中到组件顶部，能够灵活的将所有state各取所需的分发给所有的组件，是的，这就是redux</strong></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>redux是的诞生是为了给 React 应用提供「可预测化的状态管理」机制。</li><li>Redux会将整个应用状态(其实也就是数据)存储到到一个地方，称为store</li><li>这个store里面保存一棵状态树(state tree)</li><li>组件改变state的唯一方法是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，于是state完成更新</li><li>组件可以派发(dispatch)行为(action)给store,而不是直接通知其它组件</li><li>其它组件可以通过订阅store中的状态(state)来刷新自己的视图</li></ol><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p><strong>1. 创建reducer</strong></p><ul><li>可以使用单独的一个reducer,也可以将多个reducer合并为一个reducer，即：combineReducers()</li><li>action发出命令后将state放入reucer加工函数中，返回新的state,对state进行加工处理</li></ul><p><strong>2. 创建action</strong></p><ul><li>用户是接触不到state的，只能有view触发，所以，这个action可以理解为指令，需要发出多少动作就有多少指令</li><li>action是一个对象，必须有一个叫type的参数，定义action类型</li></ul><p><strong>3. 创建的store，使用createStore方法</strong></p><ul><li>store 可以理解为有多个加工机器的总工厂</li><li>提供subscribe，dispatch，getState这些方法。</li></ul><h3 id="按步骤手把手实战。"><a href="#按步骤手把手实战。" class="headerlink" title="按步骤手把手实战。"></a>按步骤手把手实战。</h3><p>上述步骤，对应的序号，我会在相关代码标出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">npm install redux -S <span class="comment">// 安装</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span> <span class="comment">// 引入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = &#123;count: 0&#125;, action</span>) =&gt;</span> &#123;----------&gt; ⑴</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREASE'</span>: <span class="keyword">return</span> &#123;count: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREASE'</span>: <span class="keyword">return</span> &#123;count: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;----------&gt;⑵</span><br><span class="line">  increase: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;<span class="keyword">type</span>: <span class="string">'INCREASE'</span>&#125;),</span><br><span class="line">  decrease: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;<span class="keyword">type</span>: <span class="string">'DECREASE'</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);----------&gt;⑶</span><br><span class="line"></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 1&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 2&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 3&#125;</span></span><br></pre></td></tr></table></figure><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>刚开始就说了，如果把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">顶层组件</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">顶层组件</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不就ok了吗？这就是 react-redux。Redux 官方提供的 React 绑定库。 具有高效且灵活的特性。</p><h3 id="React-Redux-将组件区分为-容器组件-和-UI-组件"><a href="#React-Redux-将组件区分为-容器组件-和-UI-组件" class="headerlink" title="React Redux 将组件区分为 容器组件 和 UI 组件"></a>React Redux 将组件区分为 容器组件 和 UI 组件</h3><ul><li>前者会处理逻辑</li><li>后者只负责显示和交互，内部不处理逻辑，状态完全由外部掌控</li></ul><h3 id="两个核心"><a href="#两个核心" class="headerlink" title="两个核心"></a>两个核心</h3><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>看我上边那个代码的顶层组件4个字。对，你没有猜错。这个顶级组件就是Provider,一般我们都将顶层组件包裹在Provider组件之中，这样的话，所有组件就都可以在react-redux的控制之下了,但是store必须作为参数放到Provider组件中去</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span> = <span class="string">&#123;store&#125;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这个组件的目的是让所有组件都能够访问到Redux中的数据。 </strong></p><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>这个才是react-redux中比较难的部分，我们详细解释一下</p><p>首先，先记住下边的这行代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="name">mapStateToProps</span>, mapDispatchToProps)(<span class="name">MyComponent</span>)</span><br></pre></td></tr></table></figure><p><strong>mapStateToProps</strong><br>这个单词翻译过来就是<strong>把state映射到props中去</strong>,</p><p>其实也就是<strong>把Redux中的数据映射到React中的props中去。</strong><br>举个栗子：</p><pre><code>const mapStateToProps = (state) =&gt; {  return {      // prop : state.xxx  | 意思是将state中的某个数据映射到props中    foo: state.bar  }}</code></pre><p>然后渲染的时候就可以使用this.props.foo</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        <span class="comment">// 这样子渲染的其实就是state.bar的数据了</span></span><br><span class="line">            &lt;div&gt;<span class="keyword">this</span>.props.foo&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Foo</span> = connect()(<span class="type">Foo</span>);</span><br><span class="line">export <span class="keyword">default</span> <span class="type">Foo</span>;</span><br></pre></td></tr></table></figure><p>然后这样就可以完成渲染了</p><p><strong>mapDispatchToProps</strong></p><p>这个单词翻译过来就是就是把各种dispatch也变成了props让你可以直接使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123; <span class="comment">// 默认传递参数就是dispatch</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onClick: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">'increatment'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">        </span><br><span class="line">             &lt;button onClick = &#123;<span class="keyword">this</span>.props.onClick&#125;&gt;点击increase&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Foo</span> = connect()(<span class="type">Foo</span>);</span><br><span class="line">export <span class="keyword">default</span> <span class="type">Foo</span>;</span><br></pre></td></tr></table></figure><p>组件也就改成了上边这样，可以直接通过this.props.onClick，来调用dispatch,这样子就不需要在代码中来进行store.dispatch了</p><p>react-redux的基本介绍就到这里了</p><h2 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h2><p>如果按照原始的redux工作流程，当组件中产生一个action后会直接触发reducer修改state，reducer又是一个纯函数，也就是不能再reducer中进行异步操作；</p><p><strong>而往往实际中，组件中发生的action后，在进入reducer之前需要完成一个异步任务,比如发送ajax请求后拿到数据后，再进入reducer,显然原生的redux是不支持这种操作的</strong></p><p>这个时候急需一个中间件来处理这种业务场景，目前最优雅的处理方式自然就是redux-saga</p><h3 id="核心讲解"><a href="#核心讲解" class="headerlink" title="核心讲解"></a>核心讲解</h3><h4 id="1、Saga-辅助函数"><a href="#1、Saga-辅助函数" class="headerlink" title="1、Saga 辅助函数"></a>1、Saga 辅助函数</h4><p>redux-saga提供了一些辅助函数，用来在一些特定的action 被发起到Store时派生任务，下面我先来讲解两个辅助函数：takeEvery 和 takeLatest</p><ul><li>takeEvery</li></ul><p><strong>takeEvery就像一个流水线的洗碗工，过来一个脏盘子就直接执行后面的洗碗函数，一旦你请了这个洗碗工他会一直执行这个工作，绝对不会停止接盘子的监听过程和触发洗盘子函数</strong></p><p>例如：每次点击  按钮去Fetch获取数据时时，我们发起一个 FETCH_REQUESTED 的 action。 我们想通过启动一个任务从服务器获取一些数据，来处理这个action，类似于</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventLister(<span class="string">'xxx'</span>,fn)</span><br></pre></td></tr></table></figure><p>当dispatch xxx的时候，就会执行fn方法，<br>首先我们创建一个将执行异步 action 的任务(也就是上边的fn)：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put：你就认为put就等于 dispatch就可以了；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call：可以理解为实行一个异步函数,是阻塞型的，只有运行完后面的函数，才会继续往下；</span></span><br><span class="line"><span class="comment">// 在这里可以片面的理解为async中的await！但写法直观多了！</span></span><br><span class="line"><span class="keyword">import</span> &#123; call, put &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">fetchData</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> apiAjax = <span class="function">(<span class="params">params</span>) =&gt;</span> fetch(url, params);</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">yield</span> call(apiAjax);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;<span class="keyword">type</span>: <span class="string">"FETCH_SUCCEEDED"</span>, data&#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;<span class="keyword">type</span>: <span class="string">"FETCH_FAILED"</span>, error&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在每次 FETCH_REQUESTED action 被发起时启动上面的任务,也就相当于每次触发一个名字为 FETCH_REQUESTED 的action就会执行上边的任务,代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeEvery &#125; <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">yield</span>* takeEvery(<span class="string">"FETCH_REQUESTED"</span>, fetchData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面的 takeEvery 函数可以使用下面的写法替换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">     <span class="keyword">yield</span> take(<span class="string">'FETCH_REQUESTED'</span>);</span><br><span class="line">     <span class="keyword">yield</span> fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>takeLatest</li></ul><p>在上面的例子中，takeEvery 允许多个 fetchData 实例同时启动，在某个特定时刻，我们可以启动一个新的 fetchData 任务， 尽管之前还有一个或多个 fetchData 尚未结束<br>如果我们只想得到最新那个请求的响应（例如，始终显示最新版本的数据），我们可以使用 takeLatest 辅助函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; takeLatest &#125; <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* takeLatest(<span class="string">'FETCH_REQUESTED'</span>, fetchData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和takeEvery不同，在任何时刻 takeLatest 只允许执行一个 fetchData 任务，并且这个任务是最后被启动的那个，如果之前已经有一个任务在执行，那之前的这个任务会自动被取消</p><h4 id="2、Effect-Creators"><a href="#2、Effect-Creators" class="headerlink" title="2、Effect Creators"></a>2、Effect Creators</h4><p>redux-saga框架提供了很多创建effect的函数，下面我们就来简单的介绍下开发中最常用的几种</p><ul><li>take(pattern)</li><li>put(action)</li><li>call(fn, …args)</li><li>fork(fn, …args)</li><li>select(selector, …args)</li></ul><p><strong>take(pattern)</strong></p><p>take函数可以理解为监听未来的action，它创建了一个命令对象，告诉middleware等待一个特定的action， Generator会暂停，直到一个与pattern匹配的action被发起，才会继续执行下面的语句，也就是说，take是一个阻塞的 effect</p><p>用法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchFetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">   // 监听一个<span class="built_in">type</span>为 <span class="string">'FETCH_REQUESTED'</span> 的action的执行，直到等到这个Action被触发，才会接着执行下面的 <span class="built_in">yield</span> fork(fetchData)  语句</span><br><span class="line">     <span class="built_in">yield</span> take(<span class="string">'FETCH_REQUESTED'</span>);</span><br><span class="line">     <span class="built_in">yield</span> fork(fetchData);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>put(action)</strong></p><p>put函数是用来发送action的 effect，你可以简单的把它理解成为redux框架中的dispatch函数，当put一个action后，reducer中就会计算新的state并返回，注意： put 也是阻塞 effect</p><p>用法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export <span class="function"><span class="keyword">function</span>* <span class="title">toggleItemFlow</span><span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">list</span> = []</span><br><span class="line">    // 发送一个<span class="built_in">type</span>为 <span class="string">'UPDATE_DATA'</span> 的Action，用来更新数据，参数为 `data：<span class="keyword">list</span>`</span><br><span class="line">    yield <span class="keyword">put</span>(&#123;</span><br><span class="line">      <span class="built_in">type</span>: actionTypes.UPDATE_DATA,</span><br><span class="line">      dat<span class="variable">a:</span> <span class="keyword">list</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>call(fn, …args)</strong></p><p>call函数你可以把它简单的理解为就是可以调用其他函数的函数，它命令 middleware 来调用fn 函数， args为函数的参数，注意：  fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数，call 函数也是阻塞 effect</p><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> delay = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">removeItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> call(delay, <span class="number">500</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123;<span class="attr">type</span>: actionTypes.ERROR&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fork(fn, …args)</strong></p><p>fork 函数和 call 函数很像，都是用来调用其他函数的，但是fork函数是非阻塞函数，也就是说，程序执行完 yield fork(fn， args) 这一行代码后，会立即接着执行下一行代码语句，而不会等待fn函数返回结果后，在执行下面的语句</p><p>用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fork &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的四个 Generator 函数会一次执行，不会阻塞执行</span></span><br><span class="line">  <span class="keyword">yield</span> fork(addItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(removeItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(toggleItemFlow)</span><br><span class="line">  <span class="keyword">yield</span> fork(modifyItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select(selector, …args)</strong></p><p>select 函数是用来指示 middleware调用提供的选择器获取Store上的state数据，你也可以简单的把它理解为redux框架中获取store上的 state数据一样的功能 ：store.getState()</p><p>用法：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export function* toggleItemFlow() &#123;</span><br><span class="line">     // 通过 select effect 来获取 全局 <span class="keyword">state</span>上的 `getTodoList` 中的 list</span><br><span class="line">     let tempList = yield select(<span class="keyword">state</span> =&gt; <span class="keyword">state</span>.getTodoList.list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个具体的实例"><a href="#一个具体的实例" class="headerlink" title="一个具体的实例"></a>一个具体的实例</h2><p><strong>index.js</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rootSaga <span class="keyword">from</span> <span class="string">'./sagas'</span></span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = createSagaMiddleware() <span class="comment">// 创建了一个saga中间件实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下边这句话和下边的两行代码创建store的方式是一样的</span></span><br><span class="line"><span class="comment">// const store = createStore(reducers,applyMiddlecare(middlewares))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createStoreWithMiddleware = applyMiddleware(middlewares)(createStore)</span><br><span class="line"><span class="keyword">const</span> store = createStoreWithMiddleware(rootReducer)</span><br><span class="line"></span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = <span class="function"><span class="params">type</span> =&gt;</span> store.dispatch(&#123; <span class="keyword">type</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Counter</span><br><span class="line">      value=&#123;store.getState()&#125;</span><br><span class="line">      onIncrement=&#123;<span class="function"><span class="params">()</span> =&gt;</span> action(<span class="string">'INCREMENT'</span>)&#125;</span><br><span class="line">      onDecrement=&#123;<span class="function"><span class="params">()</span> =&gt;</span> action(<span class="string">'DECREMENT'</span>)&#125;</span><br><span class="line">      onIncrementAsync=&#123;<span class="function"><span class="params">()</span> =&gt;</span> action(<span class="string">'INCREMENT_ASYNC'</span>)&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()</span><br><span class="line"></span><br><span class="line">store.subscribe(render)</span><br></pre></td></tr></table></figure><p><strong>sagas.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; put, call, take,fork &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; takeEvery, takeLatest &#125; <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> delay = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 延迟 1s 在执行 + 1操作</span></span><br><span class="line">  <span class="keyword">yield</span> call(delay, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// while(true)&#123;</span></span><br><span class="line">  <span class="comment">//   yield take('INCREMENT_ASYNC');</span></span><br><span class="line">  <span class="comment">//   yield fork(incrementAsync);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的写法与上面的写法上等效</span></span><br><span class="line">  <span class="keyword">yield</span>* takeEvery(<span class="string">"INCREMENT_ASYNC"</span>, incrementAsync)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>reducer.js</strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> function counter(<span class="keyword">state</span> = <span class="number">0</span>, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case 'INCREMENT':</span><br><span class="line">      return <span class="keyword">state</span> + <span class="number">1</span></span><br><span class="line">    case 'DECREMENT':</span><br><span class="line">      return <span class="keyword">state</span> - <span class="number">1</span></span><br><span class="line">    case 'INCREMENT_ASYNC':</span><br><span class="line">      return <span class="keyword">state</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      return <span class="keyword">state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码结构可以看出，redux-saga的使用方式还是比较简单的，相比较之前的redux框架的CounterApp，多了一个sagas的文件，reducers文件还是之前的使用方式</p><h2 id="redux-saga基本用法总结："><a href="#redux-saga基本用法总结：" class="headerlink" title="redux-saga基本用法总结："></a>redux-saga基本用法总结：</h2><ol><li><p>使用 createSagaMiddleware 方法创建 saga 的 Middleware ，然后在创建的 redux 的 store 时，使用 applyMiddleware 函数将创建的 saga Middleware 实例绑定到 store 上，最后可以调用 saga Middleware 的 run 函数来执行某个或者某些 Middleware 。</p></li><li><p>在 saga 的 Middleware 中，可以使用 takeEvery 或者 takeLatest 等 API 来监听某个 action ，当某个 action 触发后， saga 可以使用 call 发起异步操作，操作完成后使用 put 函数触发 action ，同步更新 state ，从而完成整个 State 的更新。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;redux&quot;&gt;&lt;a href=&quot;#redux&quot; class=&quot;headerlink&quot; title=&quot;redux&quot;&gt;&lt;/a&gt;redux&lt;/h2&gt;&lt;p&gt;React有pr
      
    
    </summary>
    
      <category term="react" scheme="https://chongdee.github.io/categories/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/categories/react/redux/"/>
    
    
      <category term="react" scheme="https://chongdee.github.io/tags/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>redux入门（一）</title>
    <link href="https://chongdee.github.io/2021/07/28/react/redux/redux%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://chongdee.github.io/2021/07/28/react/redux/redux入门（一）/</id>
    <published>2021-07-27T16:06:03.148Z</published>
    <updated>2021-07-27T16:07:36.306Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Redux-入门教程（一）：基本用法"><a href="#Redux-入门教程（一）：基本用法" class="headerlink" title="Redux 入门教程（一）：基本用法"></a>Redux 入门教程（一）：基本用法</h2><p>React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。</p><ul><li>代码结构</li><li>组件之间的通信<br>对于大型的复杂应用来说，这两方面恰恰是最关键的。因此，只用 React 没法写大型应用。</li></ul><p>为了解决这个问题，2014年 Facebook 提出了 Flux 架构的概念，引发了很多的实现。2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。</p><h2 id="零、你可能不需要-Redux"><a href="#零、你可能不需要-Redux" class="headerlink" title="零、你可能不需要 Redux"></a>零、你可能不需要 Redux</h2><p>首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。</p><p>曾经有人说过这样一句话。</p><blockquote><p>“如果你不知道是否需要 Redux，那就是不需要它。”</p></blockquote><p>Redux 的创造者 Dan Abramov 又补充了一句。</p><blockquote><p>“只有遇到 React 实在解决不了的问题，你才需要 Redux 。”</p></blockquote><p>简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。</p><ul><li>用户的使用方式非常简单</li><li>用户之间没有协作</li><li>不需要与服务器大量交互，也没有使用 WebSocket</li><li>视图层（View）只从单一来源获取数据</li></ul><p>上面这些情况，都不需要使用 Redux。</p><ul><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或者使用了WebSocket</li><li>View要从多个来源获取数据</li></ul><p>上面这些情况才是 Redux 的适用场景：多交互、多数据源。</p><p>从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux。</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><p>发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。</p><h2 id="一、设计思想"><a href="#一、设计思想" class="headerlink" title="一、设计思想"></a>一、设计思想</h2><p>Redux 的设计思想很简单，就两句话。</p><ul><li><p>（1）Web 应用是一个状态机，视图与状态是一一对应的。</p></li><li><p>（2）所有的状态，保存在一个对象里面。</p></li></ul><p>请务必记住这两句话，下面就是详细解释。</p><h2 id="二、基本概念和-API"><a href="#二、基本概念和-API" class="headerlink" title="二、基本概念和 API"></a>二、基本概念和 API</h2><h3 id="2-1-Store"><a href="#2-1-Store" class="headerlink" title="2.1 Store"></a>2.1 Store</h3><p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p><p>Redux 提供createStore这个函数，用来生成 Store。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br></pre></td></tr></table></figure><p>上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。</p><h3 id="2-2-State"><a href="#2-2-State" class="headerlink" title="2.2 State"></a>2.2 State</h3><p>Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。</p><p>当前时刻的 State，可以通过store.getState()拿到。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; <span class="keyword">from</span> 'redux';</span><br><span class="line">const store = createStore(fn);</span><br><span class="line"></span><br><span class="line">const <span class="keyword">state</span> = store.getState();</span><br></pre></td></tr></table></figure><p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p><h3 id="2-3-Action"><a href="#2-3-Action" class="headerlink" title="2.3 Action"></a>2.3 Action</h3><p>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p><p>Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个规范可以参考。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const action</span> = &#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。</p><p>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p><h3 id="2-4-Action-Creator"><a href="#2-4-Action-Creator" class="headerlink" title="2.4 Action Creator"></a>2.4 Action Creator</h3><p>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'添加 TODO'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span><span class="params">(text)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = addTodo(<span class="string">'Learn Redux'</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，addTodo函数就是一个 Action Creator。</p><h3 id="2-5-store-dispatch"><a href="#2-5-store-dispatch" class="headerlink" title="2.5 store.dispatch()"></a>2.5 store.dispatch()</h3><p>store.dispatch()是 View 发出 Action 的唯一方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。</p><p>结合 Action Creator，这段代码可以改写如下。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">store</span><span class="selector-class">.dispatch</span>(addTodo(<span class="string">'Learn Redux'</span>));</span><br></pre></td></tr></table></figure><h3 id="2-6-Reducer"><a href="#2-6-Reducer" class="headerlink" title="2.6 Reducer"></a>2.6 Reducer</h3><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> <span class="params">(state, action)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> new_state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">default</span>State = <span class="number">0</span>;</span><br><span class="line">const reducer = (<span class="keyword">state</span> = <span class="keyword">default</span>State, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case 'ADD':</span><br><span class="line">      return <span class="keyword">state</span> + action.payload;</span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      return <span class="keyword">state</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const <span class="keyword">state</span> = reducer(<span class="number">1</span>, &#123;</span><br><span class="line">  type: 'ADD',</span><br><span class="line">  payload: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。</p><p>实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure><p>上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。</p><p>为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const actions = [</span><br><span class="line">  &#123; <span class="string">type:</span> <span class="string">'ADD'</span>, <span class="string">payload:</span> <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="string">type:</span> <span class="string">'ADD'</span>, <span class="string">payload:</span> <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="string">type:</span> <span class="string">'ADD'</span>, <span class="string">payload:</span> <span class="number">2</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const total = actions.reduce(reducer, <span class="number">0</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。</p><h3 id="2-7-纯函数"><a href="#2-7-纯函数" class="headerlink" title="2.7 纯函数"></a>2.7 纯函数</h3><p>Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p><p>纯函数是函数式编程的概念，必须遵守以下一些约束。</p><ul><li>不得改写参数</li><li>不能调用系统 I/O 的API</li><li>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</li></ul><p>由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// State 是一个对象</span><br><span class="line">function reducer(<span class="keyword">state</span>, action) &#123;</span><br><span class="line">  return Object.assign(&#123;&#125;, <span class="keyword">state</span>, &#123; thingToChange &#125;);</span><br><span class="line">  // 或者</span><br><span class="line">  return &#123; ...<span class="keyword">state</span>, ...newState &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// State 是一个数组</span><br><span class="line">function reducer(<span class="keyword">state</span>, action) &#123;</span><br><span class="line">  return [...<span class="keyword">state</span>, newItem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。</p><h3 id="2-8-store-subscribe"><a href="#2-8-store-subscribe" class="headerlink" title="2.8 store.subscribe()"></a>2.8 store.subscribe()</h3><p>Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure><p>显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。</p><p>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure><h2 id="三、Store-的实现"><a href="#三、Store-的实现" class="headerlink" title="三、Store 的实现"></a>三、Store 的实现</h2><p>上一节介绍了 Redux 涉及的基本概念，可以发现 Store 提供了三个方法。</p><ul><li>store.getState()</li><li>store.dispatch()</li><li>store.subscribe()</li></ul><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; from <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; subscribe, dispatch, getState &#125; = createStore(reducer);</span><br></pre></td></tr></table></figure><p>createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = createStore(todoApp, <span class="built_in">window</span>.STATE_FROM_SERVER)</span><br></pre></td></tr></table></figure><p>上面代码中，window.STATE_FROM_SERVER就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。</p><p>下面是createStore方法的一个简单实现，可以了解一下 Store 是怎么生成的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> state;</span><br><span class="line">  <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    state = reducer(state, action);</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener());</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">    listeners.push(listener);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      listeners = listeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、Reducer-的拆分"><a href="#四、Reducer-的拆分" class="headerlink" title="四、Reducer 的拆分"></a>四、Reducer 的拆分</h2><p>Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。</p><p>请看下面的例子。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const chatReducer = (<span class="keyword">state</span> = <span class="keyword">default</span>State, action = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  const &#123; type, payload &#125; = action;</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case ADD_CHAT:</span><br><span class="line">      return Object.assign(&#123;&#125;, <span class="keyword">state</span>, &#123;</span><br><span class="line">        chatLog: <span class="keyword">state</span>.chatLog.concat(payload)</span><br><span class="line">      &#125;);</span><br><span class="line">    case CHANGE_STATUS:</span><br><span class="line">      return Object.assign(&#123;&#125;, <span class="keyword">state</span>, &#123;</span><br><span class="line">        statusMessage: payload</span><br><span class="line">      &#125;);</span><br><span class="line">    case CHANGE_USERNAME:</span><br><span class="line">      return Object.assign(&#123;&#125;, <span class="keyword">state</span>, &#123;</span><br><span class="line">        <span class="keyword">user</span>Name: payload</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">default</span>: return <span class="keyword">state</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，三种 Action 分别改变 State 的三个属性。</p><ul><li>ADD_CHAT：chatLog属性</li><li>CHANGE_STATUS：statusMessage属性</li><li>CHANGE_USERNAME：userName属性</li></ul><p>这三个属性之间没有联系，这提示我们可以把 Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的 Reducer 即可。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const chatReducer = (<span class="keyword">state</span> = <span class="keyword">default</span>State, action = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    chatLog: chatLog(<span class="keyword">state</span>.chatLog, action),</span><br><span class="line">    statusMessage: statusMessage(<span class="keyword">state</span>.statusMessage, action),</span><br><span class="line">    <span class="keyword">user</span>Name: <span class="keyword">user</span>Name(<span class="keyword">state</span>.<span class="keyword">user</span>Name, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，Reducer 函数被拆成了三个小函数，每一个负责生成对应的属性。</p><p>这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。</p><p>Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chatReducer = combineReducers(&#123;</span><br><span class="line">  chatLog,</span><br><span class="line">  statusMessage,</span><br><span class="line">  userName</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp;</span><br></pre></td></tr></table></figure><p>上面的代码通过combineReducers方法将三个子 Reducer 合并成一个大的函数。</p><p>这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const reducer = combineReducers(&#123;</span><br><span class="line">  a: doSomethingWithA,</span><br><span class="line">  b: processB,</span><br><span class="line">  c: c</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function reducer(<span class="keyword">state</span> = &#123;&#125;, action) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    a: doSomethingWithA(<span class="keyword">state</span>.a, action),</span><br><span class="line">    b: processB(<span class="keyword">state</span>.b, action),</span><br><span class="line">    c: c(<span class="keyword">state</span>.c, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。</p><p>下面是combineReducer的简单实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combineReducers = <span class="function"><span class="params">reducers</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(reducers).reduce(</span><br><span class="line">      (nextState, key) =&gt; &#123;</span><br><span class="line">        nextState[key] = reducers[key](state[key], action);</span><br><span class="line">        <span class="keyword">return</span> nextState;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;&#125; </span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以把所有子 Reducer 放在一个文件里面，然后统一引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(reducers)</span><br></pre></td></tr></table></figure><h2 id="五、工作流程"><a href="#五、工作流程" class="headerlink" title="五、工作流程"></a>五、工作流程</h2><p>本节对 Redux 的工作流程，做一个梳理。</p><p>首先，用户发出 Action。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(action)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let nextState</span> = todoApp(previousState, action);</span><br></pre></td></tr></table></figure><p>State 一旦有变化，Store 就会调用监听函数。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置监听函数</span></span><br><span class="line">store.subscribe<span class="comment">(listener)</span>;</span><br></pre></td></tr></table></figure><p>listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listerner</span></span>() &#123;</span><br><span class="line">  let <span class="keyword">new</span><span class="type">State</span> = store.getState();</span><br><span class="line">  component.setState(<span class="keyword">new</span><span class="type">State</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、实例：计数器"><a href="#六、实例：计数器" class="headerlink" title="六、实例：计数器"></a>六、实例：计数器</h2><p>下面我们来看一个最简单的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function">(<span class="params">&#123; value &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;h1&gt;&#123;value&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const render = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter value=&#123;store.getState()&#125;/</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">store.subscribe(render);</span><br><span class="line">render();</span><br></pre></td></tr></table></figure><p>上面是一个简单的计数器，唯一的作用就是把参数value的值，显示在网页上。Store 的监听函数设置为render，每次 State 的变化都会导致网页重新渲染。</p><p>下面加入一点变化，为Counter添加递增和递减的 Action。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = <span class="function">(<span class="params">&#123; value, onIncrement, onDecrement &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;h1&gt;&#123;value&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button onClick=&#123;onIncrement&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">  &lt;button onClick=&#123;onDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const reducer = (state = 0, action) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  switch (action.type) &#123;</span></span><br><span class="line"><span class="regexp">    case 'INCREMENT': return state + 1;</span></span><br><span class="line"><span class="regexp">    case 'DECREMENT': return state - 1;</span></span><br><span class="line"><span class="regexp">    default: return state;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const store = createStore(reducer);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const render = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter</span></span><br><span class="line"><span class="regexp">      value=&#123;store.getState()&#125;</span></span><br><span class="line"><span class="regexp">      onIncrement=&#123;() =&gt; store.dispatch(&#123;type: 'INCREMENT'&#125;)&#125;</span></span><br><span class="line"><span class="regexp">      onDecrement=&#123;() =&gt; store.dispatch(&#123;type: 'DECREMENT'&#125;)&#125;</span></span><br><span class="line"><span class="regexp">    /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">render();</span><br><span class="line">store.subscribe(render);</span><br></pre></td></tr></table></figure><h2 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h2><p><a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">阮一峰Redux 入门教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Redux-入门教程（一）：基本用法&quot;&gt;&lt;a href=&quot;#Redux-入门教程（一）：基本用法&quot; class=&quot;headerlink&quot; title=&quot;Redux 
      
    
    </summary>
    
      <category term="react" scheme="https://chongdee.github.io/categories/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/categories/react/redux/"/>
    
    
      <category term="react" scheme="https://chongdee.github.io/tags/react/"/>
    
      <category term="redux" scheme="https://chongdee.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>柯里化</title>
    <link href="https://chongdee.github.io/2021/07/27/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>https://chongdee.github.io/2021/07/27/函数式编程/柯里化/</id>
    <published>2021-07-27T15:55:18.878Z</published>
    <updated>2021-07-27T15:57:33.112Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="理解JavaScript的柯里化"><a href="#理解JavaScript的柯里化" class="headerlink" title="理解JavaScript的柯里化"></a>理解JavaScript的柯里化</h1><p>函数式编程是一种编程风格，它可以将函数作为参数传递，并返回没有副作用（改变程序状态）的函数</p><p>许多计算机语言都采用了这种编程风格。在这些语言中，JavaScript、Haskell、Clojure、Erlang 和 Scala 是最流行的几种。</p><p>由于这种风格具有传递和返回函数的能力，它带来了许多概念：</p><ul><li>纯函数</li><li>柯里化</li><li>高阶函数</li></ul><p>我们接下来要谈到的概念就是这其中的<strong>柯里化</strong>。</p><p>在这篇文章📄中，我们会看到柯里化如何工作以及它是如何被软件开发者运用到实践中的。</p><p><strong>提示</strong>：除了复制粘贴，你可以使用 <a href="https://bitsrc.io/" target="_blank" rel="noopener">Bit</a> 把可复用的 JavaScript 功能转换为组件，这样可以快速地和你的团队在项目之间共享。</p><h2 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h2><p>柯里化其实是函数式编程的一个过程，在这个过程中我们能把一个带有多个参数的函数转换成一系列的嵌套函数。它返回一个新函数，这个新函数期望传入下一个参数。</p><p>它不断地返回新函数（像我们之前讲的，这个新函数期望当前的参数），直到所有的参数都被使用。参数会一直保持 <code>alive</code> （通过闭包），当柯里化函数链中最后一个函数被返回和调用的时候，它们会用于执行。</p><blockquote><p>柯里化是一个把具有较多 arity 的函数转换成具有较少 arity 函数的过程 – Kristina Brainwave</p></blockquote><p><strong>注意</strong>：上面的术语 arity ，指的是函数的参数数量。举个例子，</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_fn</span><span class="params">(a, b, c)</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数<code>fn</code>接受两个参数（2-arity函数），<code>_fn</code>接受3个参数（3-arity函数）</p><p>所以，柯里化把一个多参数函数转换为一系列只带<strong>单个参数</strong>的函数。</p><p>让我们来看一个简单的示例：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">multiply</span>(a, b, c) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">a</span> * b * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受3个数字，将数字相乘并返回结果。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiply(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>你看，我们如何调用这个具有完整参数的乘法函数。让我们创建一个柯里化后的版本，然后看看在一系列的调用中我们如何调用相同的函数（并且得到相同的结果）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b * c</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">log(multiply(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>我们已经将 <code>multiply(1,2,3)</code> 函数调用转换为多个 <code>multiply(1)(2)(3)</code> 的多个函数调用。</p><p>一个独立的函数已经被转换为一系列函数。为了得到<code>1</code>, <code>2</code> 和 <code>3</code>三个数字想成的结果，这些参数一个接一个传递，每个数字都预先传递给下一个函数以便在内部调用。</p><p>我们可以拆分 <code>multiply(1)(2)(3)</code> 以便更好的理解它：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">mul1 </span>= <span class="keyword">multiply(1);</span></span><br><span class="line"><span class="keyword">const </span><span class="keyword">mul2 </span>= <span class="keyword">mul1(2);</span></span><br><span class="line"><span class="keyword">const </span>result = <span class="keyword">mul2(3);</span></span><br><span class="line">log(result); // 6</span><br></pre></td></tr></table></figure><p>让我们依次调用他们。我们传递了<code>1</code>给<code>multiply</code>函数：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">mul1</span> = multiply(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>它返回这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b * c</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在，<code>mul1</code>持有上面这个函数定义，它接受一个参数<code>b</code>。</p><p>我们调用<code>mul1</code>函数，传递<code>2</code>：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">mul</span><span class="number">2</span> = <span class="keyword">mul</span><span class="number">1</span>(<span class="number">2</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>num1会返回第三个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的参数现在存储在变量<code>mul2</code>。</p><p><code>mul2</code>会变成：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mul2</span> = <span class="params">(c)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b * c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传递参数<code>3</code>给函数<code>mul2</code>并调用它，</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const result</span> = mul2(3);</span><br></pre></td></tr></table></figure><p>它和之前传递进来的参数：<code>a = 1</code>, <code>b = 2</code>做了计算，返回了<code>6</code>。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="built_in">result</span>);<span class="comment"> // 6</span></span><br></pre></td></tr></table></figure><p>作为嵌套函数，<code>mul2</code>可以访问外部函数的变量作用域。</p><p>这就是<code>mul2</code>能够使用在已经退出的函数中定义的变量做加法运算的原因。尽管这些函数很早就返回了，并且从内存进行了垃圾回收，但是它们的变量仍然保持 <code>alive</code>。</p><p>你会看到，三个数字一个接一个地应用于函数调用，并且每次都返回一个新函数，直到所有数字都被应用。</p><p>让我们看另一个示例：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span><span class="params">(l,w,h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l * w * h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> aCylinder = volume(<span class="number">100</span>,<span class="number">20</span>,<span class="number">90</span>) <span class="comment">// 180000</span></span><br></pre></td></tr></table></figure><p>我们有一个函数<code>volume</code>来计算任何一个固体形状的体积。</p><p>被柯里化的版本将接受一个参数并且返回一个函数，这个新函数依然会接受一个参数并且返回一个新函数。这个过程会一直持续，直到最后一个参数到达并且返回最后一个函数，最后返回的函数会使用之前接受的参数和最后一个参数进行乘法运算。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">w</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">h</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> l * w * h</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> aCylinder = volume(<span class="number">100</span>)(<span class="number">20</span>)(<span class="number">90</span>) <span class="comment">// 180000</span></span><br></pre></td></tr></table></figure><p>像我们在函数<code>multiply</code>一样，最后一个函数只接受参数<code>h</code>，但是会使用早已返回的其它作用域的变量来进行运算。由于<strong>闭包</strong>的原因，它们仍然可以工作。</p><p>柯里化背后的想法是，接受一个函数并且得到一个函数，这个函数返回<strong>专用</strong>的函数。</p><h2 id="数学中的柯里化"><a href="#数学中的柯里化" class="headerlink" title="数学中的柯里化"></a>数学中的柯里化</h2><p>我比较喜欢数学插图👉<a href="https://en.m.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">Wikipedia</a>，它进一步演示了柯里化的概念。让我们看看我们自己的示例。</p><p>假设我们有一个方程式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span><span class="params">(x,y)</span></span> = x^<span class="number">2</span> + y = z</span><br></pre></td></tr></table></figure><p>这里有两个变量 x 和 y 。如果这两个变量被赋值，<code>x=3</code>、<code>y=4</code>，最后得到 <code>z</code> 的值。</p><p>:如果我们在方法<code>f(z,y)</code>中，给<code>y</code> 赋值<code>4</code>，给<code>x</code>赋值<code>3</code>，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x,y) = f(<span class="number">3</span>,<span class="number">4</span>) = x^<span class="number">2</span> + y = <span class="number">3</span>^<span class="number">2</span> + <span class="number">4</span> = <span class="number">13</span> = z</span><br></pre></td></tr></table></figure><p>我们会的到结果，<code>13</code>。</p><p>我们可以柯里化<code>f(x,y)</code>，分离成一系列函数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h = x^<span class="number">2</span> + y = f(x,y)</span><br><span class="line"><span class="function"><span class="title">hy</span><span class="params">(x)</span></span> = x^<span class="number">2</span> + y = hx(y) = x^<span class="number">2</span> + y</span><br><span class="line">[hx =&gt; w<span class="selector-class">.r</span><span class="selector-class">.t</span> x] and [hy =&gt; w<span class="selector-class">.r</span><span class="selector-class">.t</span> y]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>hx</strong>，<strong>x</strong>是 <strong>h</strong> 的下标；<strong>hy</strong>，<strong>y</strong> 是 <strong>h</strong> 的下标。</p><p>如果我们在方程式 <code>hx(y) = x^2 + y</code> 中设置 <code>x=3</code>，它会返回一个新的方程式，这个方程式有一个变量<code>y</code>：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">h3</span><span class="params">(y)</span></span> = <span class="number">3</span>^<span class="number">2</span> + y = <span class="number">9</span> + y</span><br><span class="line">Note: <span class="selector-tag">h3</span> is h subscript <span class="number">3</span></span><br></pre></td></tr></table></figure><p>它和下面是一样的：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h3(y) = h(<span class="number">3</span>)(y) = f(<span class="number">3</span>,y) = <span class="number">3</span>^<span class="number">2</span> + y = <span class="number">9</span> + y</span><br></pre></td></tr></table></figure><p>这个值并没有被求出来，它返回了一个新的方程式<code>9 + y</code>，这个方程式接受另一个变量, <code>y</code>。</p><p>接下来，我们设置<code>y=4</code>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h3(<span class="number">4</span>) = h(<span class="number">3</span>)(<span class="number">4</span>) = f(<span class="number">3</span>,<span class="number">4</span>) = <span class="number">9</span> + <span class="number">4</span> = <span class="number">13</span></span><br></pre></td></tr></table></figure><p><code>y</code>是这条链中的最后一个变量，加法操作会对它和依然存在的之前的变量<code>x = 3</code>做运算并得出结果，<code>13</code>。</p><p>基本上，我们柯里化这个方程式，将<code>f(x,y) = 3^2 + y</code>划分成了一个方程组：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>^<span class="number">2</span> + y -&gt; <span class="number">9</span> + y</span><br><span class="line">f(<span class="number">3</span>,y) = h3(y) = <span class="number">3</span>^<span class="number">2</span> + y = <span class="number">9</span> + y</span><br><span class="line">f(<span class="number">3</span>,y) = <span class="number">9</span> + y</span><br><span class="line">f(<span class="number">3</span>,<span class="number">4</span>) = h3(<span class="number">4</span>) = <span class="number">9</span> + <span class="number">4</span> = <span class="number">13</span></span><br></pre></td></tr></table></figure><p>在最后得到结果之前。</p><p>Wow！！这是一些数学问题，如果你觉得不够清晰😕。可以在<a href="https://en.m.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">Wikipedia</a>查看📖完整的细节。 </p><h2 id="柯里化和部分函数应用"><a href="#柯里化和部分函数应用" class="headerlink" title="柯里化和部分函数应用"></a>柯里化和部分函数应用</h2><p>现在，有些人可能开始认为，被柯里化的函数所具有的嵌套函数数量取决于它所依赖的参数个数。是的，这是决定它成为<strong>柯里化</strong>的原因。</p><p>我设计了一个被柯里化的求体积的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">l</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">w, h</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l * w * h</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以如下调用L：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const hCy = volume(<span class="number">70</span>);</span><br><span class="line">hCy(<span class="number">203</span>,<span class="number">142</span>);</span><br><span class="line">hCy(<span class="number">220</span>,<span class="number">122</span>);</span><br><span class="line">hCy(<span class="number">120</span>,<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volume(<span class="number">70</span>)(<span class="number">90</span>,<span class="number">30</span>);</span><br><span class="line">volume(<span class="number">70</span>)(<span class="number">390</span>,<span class="number">320</span>);</span><br><span class="line">volume(<span class="number">70</span>)(<span class="number">940</span>,<span class="number">340</span>);</span><br></pre></td></tr></table></figure><p>我们定义了一个用于专门计算任何长度的圆柱体体积（<code>l</code>）的函数，<code>70</code>。</p><p>它有3个参数和2个嵌套函数。不像我们之前的版本，有3个参数和3个嵌套函数。</p><p>这不是一个柯里化的版本。我们只是做了体积计算函数的部分应用。</p><p>柯里化和部分应用是相似的，但是它们是不同的概念。</p><p>部分应用将一个函数转换为另一个较小的函数。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">acidityRatio</span>(x, y, z) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">performOp(x,y,z)</span></span><br><span class="line">&#125;</span><br><span class="line">|</span><br><span class="line">V</span><br><span class="line"><span class="keyword">function</span> <span class="title">acidityRatio</span>(x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">(y,z)</span> =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> performOp(x,y,z)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：我故意忽略了<code>performOp</code>函数的实现。在这里，它不是必要的。你只需要知道柯里化和部分应用背后的概念。</p><p>这是 acidityRatio 函数的部分应用。这里面不涉及到柯里化。acidityRatio被部分应用化，它期望接受比原始函数更少的参数。</p><p>让它变成柯里化，会是这样：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">acidityRatio</span>(x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">(y)</span> = &gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (z) = &gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> performOp(x,y,z)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化根据函数的参数数量创建嵌套函数。每个函数接受一个参数。如果没有参数，那就不是柯里化。</p><blockquote><p>柯里化在具有两个参数以上的函数工作 -  <a href="https://en.m.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">Wikipedia</a></p><p>柯里化将一个函数转换为一系列只接受单个参数的函数。、</p></blockquote><p>这里有一个柯里化和部分应用相同的例子。假设我们有一个函数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">div</span>(x,y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">x/y</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们部分应用化这个函数。会得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x/y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且，柯里化会得出相同的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">div</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x/y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管柯里化和部分应用得出了相同的结果，但是它们是两个完全不同的概念。</p><p>像我们之前说的，柯里化和部分应用是相似的，但是实际上定义却不同。它们之间的相同点就是依赖闭包。</p><h2 id="柯里化有用吗"><a href="#柯里化有用吗" class="headerlink" title="柯里化有用吗?"></a>柯里化有用吗?</h2><p>当然，只要你想，柯里化就信手拈来：</p><p><strong>1、编写小模块的代码，可以更轻松的重用和配置，就行 npm 做的那样：</strong></p><p>举个例子，你有一个商店🏠，你想给你的顾客 10% 的折扣：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">discount</span>(price, discount) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">price</span> * discount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个有价值的客户买了一件$500的商品，你会给他：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const price = discount(<span class="number">500</span>,<span class="number">0.10</span>); <span class="regexp">//</span> <span class="variable">$50</span> </span><br><span class="line"><span class="regexp">//</span> <span class="variable">$500</span>  - <span class="variable">$50</span> = <span class="variable">$450</span></span><br></pre></td></tr></table></figure><p>你会发现从长远来看，我们每天都自己计算10%的折扣。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const price = discount(<span class="number">1500</span>,<span class="number">0.10</span>); <span class="regexp">//</span> <span class="variable">$150</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$1</span>,<span class="number">500</span> - <span class="variable">$150</span> = <span class="variable">$1</span>,<span class="number">350</span></span><br><span class="line">const price = discount(<span class="number">2000</span>,<span class="number">0.10</span>); <span class="regexp">//</span> <span class="variable">$200</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$2</span>,<span class="number">000</span> - <span class="variable">$200</span> = <span class="variable">$1</span>,<span class="number">800</span></span><br><span class="line">const price = discount(<span class="number">50</span>,<span class="number">0.10</span>); <span class="regexp">//</span> <span class="variable">$5</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$50</span> - <span class="variable">$5</span> = <span class="variable">$45</span></span><br><span class="line">const price = discount(<span class="number">5000</span>,<span class="number">0.10</span>); <span class="regexp">//</span> <span class="variable">$500</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$5</span>,<span class="number">000</span> - <span class="variable">$500</span> = <span class="variable">$4</span>,<span class="number">500</span></span><br><span class="line">const price = discount(<span class="number">300</span>,<span class="number">0.10</span>); <span class="regexp">//</span> <span class="variable">$30</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$300</span> - <span class="variable">$30</span> = <span class="variable">$270</span></span><br></pre></td></tr></table></figure><p>我们可以柯里化这个折扣函数，这样就不需要每天都添加0.10这个折扣值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">discount</span>(<span class="params">discount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">price</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price * discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tenPercentDiscount = discount(<span class="number">0.1</span>);</span><br></pre></td></tr></table></figure><p>现在，我们可以只用你有价值的客户购买的商品价格来进行计算了：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tenPercentDiscount(<span class="number">500</span>); <span class="regexp">//</span> <span class="variable">$50</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$500</span> - <span class="variable">$50</span> = <span class="variable">$450</span></span><br></pre></td></tr></table></figure><p>再一次，发生了这样的情况，有一些有价值的客户比另一些有价值的客户更重要 – 我们叫他们超级价值客户。并且我们想给超级价值客户20%的折扣。</p><p>我们使用被柯里化的折扣函数：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const twentyPercentDiscount</span> = discount(0.2);</span><br></pre></td></tr></table></figure><p>我们为超级价值客户设置了一个新函数，这个新函数调用了接受折扣值为0.2的柯里化函数。</p><p>返回的函数<code>twentyPercentDiscount</code>将被用于计算超级价值客户的折扣：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">twentyPercentDiscount(<span class="number">500</span>); <span class="regexp">//</span> <span class="number">100</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$500</span> - <span class="variable">$100</span> = <span class="variable">$400</span></span><br><span class="line">twentyPercentDiscount(<span class="number">5000</span>); <span class="regexp">//</span> <span class="number">1000</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$5</span>,<span class="number">000</span> - <span class="variable">$1</span>,<span class="number">000</span> = <span class="variable">$4</span>,<span class="number">000</span></span><br><span class="line">twentyPercentDiscount(<span class="number">1000000</span>); <span class="regexp">//</span> <span class="number">200000</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$1</span>,<span class="number">000</span>,<span class="number">000</span> - <span class="variable">$200</span>,<span class="number">000</span> = <span class="variable">$600</span>,<span class="number">000</span></span><br></pre></td></tr></table></figure><p><strong>2、避免频繁调用具有相同参数的函数：</strong></p><p>举个例子，我们有一个函数来计算圆柱体的体积：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">volume</span>(l, w, h) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">l</span> * w * h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>碰巧，你的仓库所有的圆柱体高度都是 100m。你会发现你会重复调用接受高度为 100 的参数的函数：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volume(<span class="number">200</span>,<span class="number">30</span>,<span class="number">100</span>) <span class="comment">// 2003000l</span></span><br><span class="line">volume(<span class="number">32</span>,<span class="number">45</span>,<span class="number">100</span>); <span class="comment">//144000l</span></span><br><span class="line">volume(<span class="number">2322</span>,<span class="number">232</span>,<span class="number">100</span>) <span class="comment">// 53870400l</span></span><br></pre></td></tr></table></figure><p>为了解决这个问题，需要柯里化这个计算体积的函数（像我们之前做的一样）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">w</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">l</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> l * w * h</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以定义一个特定的函数，这个函数用于计算特定的圆柱体高度：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const hCylinderHeight = volume(<span class="number">100</span>);</span><br><span class="line">hCylinderHeight(<span class="number">200</span>)(<span class="number">30</span>); <span class="comment">// 600,000l</span></span><br><span class="line">hCylinderHeight(<span class="number">2322</span>)(<span class="number">232</span>); <span class="comment">// 53,870,400l</span></span><br></pre></td></tr></table></figure><h2 id="通用的柯里化函数"><a href="#通用的柯里化函数" class="headerlink" title="通用的柯里化函数"></a>通用的柯里化函数</h2><p>让我们开发一个函数，它能接受任何函数并返回一个柯里化版本的函数。</p><p>为了做到这一点，我们需要这个（尽管你自己使用的方法和我的不同）：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span><span class="params">(fn, <span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (..._arg) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> fn(...args, ..._arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里做了什么呢？我们的柯里化函数接受一个我们希望柯里化的函数（fn），还有一系列的参数（…args）。扩展运算符是用来收集<code>fn</code>后面的参数到<code>...args</code>中。</p><p>接下来，我们返回一个函数，这个函数同样将剩余的参数收集为<code>..._args</code>。这个函数将<code>...args</code>传入原始函数<code>fn</code>并调用它，通过使用扩展运算符将<code>..._args</code>也作为参数传入，然后，得到的值会返回给用户。</p><p>现在我们可以使用我们自己的<code>curry</code>函数来创造专用的函数了。</p><p>让我们使用自己的柯里化函数来创建更多的专用函数（其中一个就是专门用来计算高度为100m的圆柱体体积的方法）</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">volume</span><span class="params">(l,h,w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l * h * w</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> hCy = curry(volume,<span class="number">100</span>);</span><br><span class="line">hCy(<span class="number">200</span>,<span class="number">900</span>); <span class="comment">// 18000000l</span></span><br><span class="line">hCy(<span class="number">70</span>,<span class="number">60</span>); <span class="comment">// 420000l</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>闭包使柯里化在JavaScript中得以实现。它保持着已经执行过的函数的状态，使我们能够创建工厂函数 - 一种我们能够添加特定参数的函数。</p><p>要想将你的头脑充满着柯里化、闭包和函数式编程是非常困难的。但我向你保证，花时间并且在日常应用，你会掌握它的诀窍并看到价值😘。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>👉<a href="https://en.m.wikipedia.org/wiki/Currying" target="_blank" rel="noopener">Currying — Wikipedia</a><br>👉<a href="https://en.m.wikipedia.org/wiki/Partial_application" target="_blank" rel="noopener">Partial Application Function — Wikipedia</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;理解JavaScript的柯里化&quot;&gt;&lt;a href=&quot;#理解JavaScript的柯里化&quot; class=&quot;headerlink&quot; title=&quot;理解JavaScri
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://chongdee.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://chongdee.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://chongdee.github.io/2021/07/27/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://chongdee.github.io/2021/07/27/函数式编程/函数式编程/</id>
    <published>2021-07-27T15:50:52.088Z</published>
    <updated>2021-07-27T15:53:01.933Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文较长，总共分为三大部分：(对于函数式编程以及其优点有一定理解的童鞋，可以直接从  第二部分 开始阅读)</p><p>第一部分：首先会通过实际代码介绍一下什么是函数式编程以及使用它的意义。</p><p>第二部分：我会着重介绍一下函数式编程中最重要的两个方法：柯里化和函数组合，以及他们的使用方法和实践经验。</p><p>第三部分：实战篇，主要是通过一个实战让大家对这种编程范式有一个更深刻的理解。<br>最后会总结一下函数式编程的优点和局限，并给出一些建议。</p><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><p>早在 1950 年代，随着 Lisp 语言的创建，函数式编程（ Functional Programming，简称 FP）就已经开始出现在大家视野。</p><p>而直到近些年，函数式以其优雅，简单的特点开始重新风靡整个编程界，主流语言在设计的时候无一例外都会更多的参考函数式特性（ Lambda 表达式，原生支持 map ，reduce ……），Java8 开始支持函数式编程。</p><p>而在前端领域，我们同样能看到很多函数式编程的影子：ES6 中加入了箭头函数，Redux 引入 Elm 思路降低 Flux 的复杂性，React16.6 开始推出 React.memo()，使得 pure functional components 成为可能，16.8 开始主推 Hook，建议使用 pure function 进行组件编写……</p><p>这些无一例外的说明，函数式编程这种古老的编程范式并没有随着岁月而褪去其光彩，反而愈加生机勃勃。<br>另外还有一些例子能证明函数式编程也适应于大型软件的编写：</p><blockquote><p>WhatsApp：通过 Erlang，WhatsApp 可以支持 9 亿用户，而其团队中只有 50 名工程师。<br>Discord：使用 Elixir，类似方式的 Discord  每分钟处理超过一百万个请求。</p></blockquote><p>于我个人而言，函数式编程就像第三次工业革命，前两次分别为命令式编程（Imperative programming）和面向对象编程（Object Oriented Programming）。</p><h2 id="初窥"><a href="#初窥" class="headerlink" title="初窥"></a>初窥</h2><p>概念说的再多也不够例子直观</p><blockquote><p>Talk is cheap, show me the code</p></blockquote><p>假设我们有这么个需求，我们登记了一系列人名存在数组中，现在需要对这个结构进行一些修改，需要把字符串数组变成一个对象数组，方便后续的扩展，并且需要把人名做一些转换：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'john-reese'</span>, <span class="string">'harold-finch'</span>, <span class="string">'sameen-shaw'</span>] </span><br><span class="line"><span class="comment">// 转换成 </span></span><br><span class="line">[&#123;<span class="string">name:</span> <span class="string">'John Reese'</span>&#125;, &#123;<span class="string">name:</span> <span class="string">'Harold Finch'</span>&#125;, &#123;<span class="string">name:</span> <span class="string">'Sameen Shaw'</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h3><p>用传统的编程思路，我们一上来就可以撸代码，临时变量，循环走起来：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const arr = [<span class="string">'john-reese'</span>, <span class="string">'harold-finch'</span>, <span class="string">'sameen-shaw'</span>];</span><br><span class="line">const <span class="keyword">new</span><span class="type">Arr</span> = [];</span><br><span class="line"><span class="keyword">for</span> (let i = <span class="number">0</span>, len = arr.length; i &lt; len ; i++) &#123;</span><br><span class="line">  let name = arr[i];</span><br><span class="line">  let names = name.split(<span class="string">'-'</span>);</span><br><span class="line">  let <span class="keyword">new</span><span class="type">Name</span> = [];</span><br><span class="line">  <span class="keyword">for</span> (let j = <span class="number">0</span>, naemLen = names.length; j &lt; naemLen; j++) &#123;</span><br><span class="line">    let nameItem = names[j][<span class="number">0</span>].toUpperCase() + names[j].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span><span class="type">Name</span>.push(nameItem);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span><span class="type">Arr</span>.push(&#123; name : <span class="type">newName</span>.join(<span class="string">' '</span>) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span><span class="type">Arr</span>;</span><br></pre></td></tr></table></figure><p>完成，这几乎是所有人下意识的编程思路，完全的面向过程。你会想我需要依次完成：</p><ul><li>定义一个临时变量 newArr。</li><li>我需要做一个循环。</li><li>循环需要做 arr.length 次。</li><li>每次把名字的首位取出来大写，然后拼接剩下的部分。</li><li>……</li><li>最后返回结果。</li></ul><p>这样当然能完成任务，最后的结果就是<strong>一堆中间临时变量</strong>，光想变量名就让人感到崩溃。同时过程中掺杂了大量逻辑，通常一个函数需要<strong>从头读到尾才知道它具体做了什么</strong>，而且一旦出问题很难定位。</p><h3 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h3><p>一直以来，我也没觉得这样编程有什么问题，直到我遇到了函数式编程。我们来看一看一个 FPer 会如何思考这个问题：</p><ol><li>我只需要一个函数能实现从 String 数组 到 Object 数组 的转换：</li></ol><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convertNames :: <span class="string">[String]</span> -&gt; <span class="string">[Object]</span></span><br></pre></td></tr></table></figure><ol><li>这里面涉及到一个 String -&gt; Object 的转换，那我需要有这么个函数实现这种转换：</li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert2Obj :: String -&gt; Object</span><br></pre></td></tr></table></figure><ol><li>至于这种转换，可以轻松想到需要两个函数完成：</li></ol><ul><li>capitalizeName：把名称转换成指定形式</li><li>genObj：把任意类型转换成对象</li></ul><ol><li>如果再细想一下，capitalizeName 其实也是几个方法的组合（split, join, capitalize），剩下的几个函数都是非常容易实现的。</li></ol><p>好了，我们的任务完成了，可以 运行代码</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> capitalize = x =&gt; x[<span class="number">0</span>].toUpperCase() + x.slice(<span class="number">1</span>).toLowerCase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genObj = curry((<span class="built_in">key</span>, x) =&gt; &#123;</span><br><span class="line">  let obj = &#123;&#125;;</span><br><span class="line">  obj[<span class="built_in">key</span>] = x;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> capitalizeName = compose(<span class="built_in">join</span>(<span class="string">' '</span>), <span class="built_in">map</span>(capitalize), <span class="built_in">split</span>(<span class="string">'-'</span>));</span><br><span class="line"><span class="keyword">const</span> convert2Obj = compose(genObj(<span class="string">'name'</span>), capitalizeName)</span><br><span class="line"><span class="keyword">const</span> convertName = <span class="built_in">map</span>(convert2Obj);</span><br><span class="line"></span><br><span class="line">convertName([<span class="string">'john-reese'</span>, <span class="string">'harold-finch'</span>, <span class="string">'sameen-shaw'</span>])</span><br></pre></td></tr></table></figure><p>你可以先忽略其中的 curry 和 compose 函数（后面 会介绍)。只是看这个编程思路，可以清晰看出，函数式编程的思维过程是完全不同的，它的着眼点是<strong>函数</strong>，而不是<strong>过程</strong>，它强调的是如何通过函数的组合变换去解决问题，而不是我通过写什么样的语句去解决问题，当你的代码越来越多的时候，这种函数的拆分和组合就会产生出强大的力量。</p><h3 id="为什么叫函数式编程"><a href="#为什么叫函数式编程" class="headerlink" title="为什么叫函数式编程"></a>为什么叫函数式编程</h3><p>之前我们已经初窥了函数式编程，知道了它的魅力，现在我们继续深入了解一下函数式编程吧。<br>其实函数我们从小就学，什么一次函数，二次函数……根据学术上函数的定义，函数即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值。</p><p>所以，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合。还记得之前写的 convert2Obj这个函数：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const convert2Obj = compose(<span class="name">genObj</span>('name'), capitalizeName)</span><br></pre></td></tr></table></figure><p>它实际上就完成了映射关系的组合，把一个数据从 String 转换成了 String 然后再转换成 Object。数学好的童鞋就知道，这就是数学上的复合运算：g°f = g(f(x))</p><p>在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数。我们所谓的编程工作也不过就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据罢了。</p><p>我特别喜欢用流水线去形容这种工作，把输入当做原料，把输出当做产品，数据可以不断的从一个函数的输出可以流入另一个函数输入，最后再输出结果，这不就是一套流水线嘛？</p><p>所以，现在你明确了函数式编程是什么了吧？它其实就是强调在编程过程中把更多的关注点放在如何去构建关系。通过构建一条高效的建流水线，一次解决所有问题。而不是把精力分散在不同的加工厂中来回奔波传递数据。</p><h3 id="函数式编程的特点"><a href="#函数式编程的特点" class="headerlink" title="函数式编程的特点"></a>函数式编程的特点</h3><h4 id="函数是“一等公民”-First-Class-Functions"><a href="#函数是“一等公民”-First-Class-Functions" class="headerlink" title="函数是“一等公民”  (First-Class Functions)"></a>函数是“一等公民”  (First-Class Functions)</h4><p>这是函数式编程得以实现的前提，因为我们基本的操作都是在操作函数。这个特性意味着函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值，例如前面的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const convert2Obj = compose(<span class="name">genObj</span>('name'), capitalizeName)</span><br></pre></td></tr></table></figure><h4 id="声明式编程-Declarative-Programming"><a href="#声明式编程-Declarative-Programming" class="headerlink" title="声明式编程  (Declarative Programming)"></a>声明式编程  (Declarative Programming)</h4><p>通过上面的例子可以看出来，函数式编程大多时候都是在声明我需要做什么，而非怎么去做。这种编程风格称为 声明式编程 。这样有个好处是代码的可读性特别高，因为声明式代码大多都是接近自然语言的，同时，它解放了大量的人力，因为它不关心具体的实现，因此它可以把优化能力交给具体的实现，这也方便我们进行分工协作。</p><p>SQL 语句就是声明式的，你无需关心 Select 语句是如何实现的，不同的数据库会去实现它自己的方法并且优化。React 也是声明式的，你只要描述你的 UI，接下来状态变化后 UI 如何更新，是 React 在运行时帮你处理的，而不是靠你自己去渲染和优化 diff 算法。</p><h4 id="惰性执行（Lazy-Evaluation）"><a href="#惰性执行（Lazy-Evaluation）" class="headerlink" title="惰性执行（Lazy Evaluation）"></a>惰性执行（Lazy Evaluation）</h4><p>所谓惰性执行指的是函数只在需要的时候执行，即不产生无意义的中间变量。像刚才的例子，函数式编程跟命令式编程最大的区别就在于几乎没有中间变量，它从头到尾都在写函数，只有在最后的时候才通过调用 convertName 产生实际的结果。</p><h4 id="无状态和数据不可变-Statelessness-and-Immutable-data"><a href="#无状态和数据不可变-Statelessness-and-Immutable-data" class="headerlink" title="无状态和数据不可变  (Statelessness and Immutable data)"></a>无状态和数据不可变  (Statelessness and Immutable data)</h4><p>这是函数式编程的核心概念：</p><ul><li><strong>数据不可变</strong>： 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。</li><li><strong>无状态</strong>： 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</li></ul><p>为了实现这个目标，函数式编程提出函数应该具备的特性：没有副作用和纯函数。</p><h4 id="没有副作用（No-Side-Effects）"><a href="#没有副作用（No-Side-Effects）" class="headerlink" title="没有副作用（No Side Effects）"></a>没有副作用（No Side Effects）</h4><p>副作用这个词我们可算听的不少，它的含义是：在完成函数主要功能之外完成的其他副要功能。在我们函数中最主要的功能当然是根据输入返回结果，而在函数中我们最常见的副作用就是随意操纵外部变量。由于 JS 中对象传递的是引用地址，哪怕我们用 const 关键词声明对象，它依旧是可以变的。而正是这个“漏洞”让我们有机会随意修改对象。<br>例如： map 函数的本来功能是将输入的数组根据一个函数转换，生成一个新的数组：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map :: <span class="string">[a]</span> -&gt; <span class="string">[b]</span></span><br></pre></td></tr></table></figure><p>而在 JS 中，我们经常可以看到下面这种对 map 的 “错误” 用法，把 map 当作一个循环语句，然后去直接修改数组中的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">list</span> = [...];</span><br><span class="line"><span class="comment">// 修改 list 中的 type 和 age</span></span><br><span class="line"><span class="built_in">list</span>.<span class="built_in">map</span>(item =&gt; &#123;</span><br><span class="line">  item.type = <span class="number">1</span>;</span><br><span class="line">  item.age++;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样函数最主要的输出功能没有了，变成了直接修改了外部变量，这就是它的副作用。而没有副作用的写法应该是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">list</span> = [...];</span><br><span class="line"><span class="comment">// 修改 list 中的 type 和 age</span></span><br><span class="line"><span class="keyword">const</span> newList = <span class="built_in">list</span>.<span class="built_in">map</span>(item =&gt; (&#123;...item, type: <span class="number">1</span>, age:item.age + <span class="number">1</span>&#125;));</span><br></pre></td></tr></table></figure><p>保证函数没有副作用，一来能保证数据的不可变性，二来能避免很多因为共享状态带来的问题。当你一个人维护代码时候可能还不明显，但随着项目的迭代，项目参与人数增加，大家对同一变量的依赖和引用越来越多，这种问题会越来越严重。最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生 Bug。</p><blockquote><p>传递引用一时爽，代码重构火葬场</p></blockquote><h4 id="纯函数-pure-functions"><a href="#纯函数-pure-functions" class="headerlink" title="纯函数 (pure functions)"></a>纯函数 (pure functions)</h4><p>纯函数算是在 “没有副作用” 的要求上再进一步了。相信你已经在很多地方接触过这个词，在 Redux 的三大原则中，我们看到，它要求所有的修改必须使用纯函数。</p><blockquote><p>Changes are made with pure functions</p></blockquote><p>其实纯函数的概念很简单就是两点：</p><ul><li><strong>不依赖外部状态（无状态）</strong>： 函数的的运行结果不依赖全局变量，this 指针，IO 操作等。</li></ul><ul><li><strong>没有副作用（数据不变）</strong>： 不修改全局变量，不修改入参。</li></ul><p>所以纯函数才是真正意义上的 “函数”， 它意味着<strong>相同的输入，永远会得到相同的输出</strong>。<br>以下几个函数都是不纯的，因为他们都依赖外部变量，试想一下，如果有人调用了 changeName 对 curUser 进行了修改，然后你在另外的地方调用了 saySth ，这样就会产生你预料之外的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curUser = &#123;</span><br><span class="line">  name: <span class="string">'Peter'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saySth = <span class="function"><span class="params">str</span> =&gt;</span> curUser.name + <span class="string">': '</span> + str;   <span class="comment">// 引用了全局变量</span></span><br><span class="line"><span class="keyword">const</span> changeName = <span class="function">(<span class="params">obj, name</span>) =&gt;</span> obj.name = name;  <span class="comment">// 修改了输入参数</span></span><br><span class="line">changeName(curUser, <span class="string">'Jay'</span>);  <span class="comment">// &#123; name: 'Jay' &#125;</span></span><br><span class="line">saySth(<span class="string">'hello!'</span>); <span class="comment">// Jay: hello!</span></span><br></pre></td></tr></table></figure><p>如果改成纯函数的写法会是怎么样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curUser = &#123;</span><br><span class="line">  name: <span class="string">'Peter'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saySth = <span class="function">(<span class="params">user, str</span>) =&gt;</span> user.name + <span class="string">': '</span> + str;   <span class="comment">// 不依赖外部变量</span></span><br><span class="line"><span class="keyword">const</span> changeName = <span class="function">(<span class="params">user, name</span>) =&gt;</span> (&#123;...user, name &#125;);  <span class="comment">// 未修改外部变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newUser = changeName(curUser, <span class="string">'Jay'</span>);  <span class="comment">// &#123; name: 'Jay' &#125;</span></span><br><span class="line">saySth(curUser, <span class="string">'hello!'</span>); <span class="comment">// Peter: hello!</span></span><br></pre></td></tr></table></figure><p>这样就没有之前说的那些问题了。<br>我们这么强调使用纯函数，纯函数的意义是什么？</p><ul><li><strong>便于测试和优化</strong>：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。这十分符合<strong>测试驱动开发 TDD（Test-Driven Development ) </strong>的思想，这样产生的代码往往健壮性更强。</li></ul><ul><li><strong>可缓存性</strong>：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果，有很多库有所谓的 memoize 函数，下面以一个简化版的 memoize 为例，这个函数就能缓存函数的结果，对于像 fibonacci 这种计算，就可以起到很好的缓存效果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">var</span> value = cache[key];</span><br><span class="line">      <span class="keyword">if</span>(!value) &#123;</span><br><span class="line">        value = [fn.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)];  <span class="comment">// 放在一个数组中，方便应对 undefined，null 等异常情况</span></span><br><span class="line">        cache[key] = value; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fibonacci = memoize(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">2</span> ? n: fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(fibonacci(<span class="number">4</span>))  <span class="comment">// 执行后缓存了 fibonacci(2), fibonacci(3),  fibonacci(4)</span></span><br><span class="line">  <span class="built_in">console</span>.log(fibonacci(<span class="number">10</span>)) <span class="comment">// fibonacci(2), fibonacci(3),  fibonacci(4)</span></span><br></pre></td></tr></table></figure><p> 的结果直接从缓存中取出，同时缓存其他的</p><ul><li><strong>自文档化</strong>：由于纯函数没有副作用，所以其依赖很明确，因此更易于观察和理解（配合后面介绍的 <a href="#hindly-milner 类型签名）更佳">类型签名</a>。</li></ul><ul><li><strong>更少的 Bug</strong>：使用纯函数意味着你的函数中<strong>不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改</strong>，这些共享状态往往是绝大多数 bug 的源头。</li></ul><p>好了，说了这么多，接下来就让我们看看在 JS 中如何使用函数式编程吧。</p><h2 id="流水线的构建"><a href="#流水线的构建" class="headerlink" title="流水线的构建"></a>流水线的构建</h2><p>如果说函数式编程中有两种操作是必不可少的那无疑就是<strong>柯里化（Currying）和函数组合（Compose）</strong>，柯里化其实就是流水线上的加工站，函数组合就是我们的流水线，它由多个加工站组成。<br>接下来，就让我们看看如何在 JS 中利用函数式编程的思想去组装一套高效的流水线。</p><h3 id="加工站——柯里化"><a href="#加工站——柯里化" class="headerlink" title="加工站——柯里化"></a>加工站——柯里化</h3><p>柯里化的意思是将一个多元函数，转换成一个依次调用的单元函数。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f<span class="comment">(a,b,c)</span> → f<span class="comment">(a)</span><span class="comment">(b)</span><span class="comment">(c)</span></span><br></pre></td></tr></table></figure><p>我们尝试写一个 curry 版本的 add 函数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> increment = add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">increment(<span class="number">10</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>为什么这个单元函数很重要？还记得我们之前说过的，函数的返回值，<strong>有且只有一个嘛？</strong> 如果我们想顺利的组装流水线，那我就必须保证我每个加工站的输出刚好能流向下个工作站的输入。<strong>因此，在流水线上的加工站必须都是单元函数</strong>。<br>现在很好理解为什么柯里化配合函数组合有奇效了，因为柯里化处理的结果刚好就是单输入的。</p><h4 id="部分函数应用-vs-柯里化"><a href="#部分函数应用-vs-柯里化" class="headerlink" title="部分函数应用 vs 柯里化"></a>部分函数应用 vs 柯里化</h4><p>经常有人搞不清柯里化和<strong>部分函数应用 ( Partial Function Application )</strong>，经常把他们混为一谈，其实这是不对的，在维基百科里有明确的定义，部分函数应用强调的是固定一定的参数，返回一个更小元的函数。通过以下表达式展示出来就明显了：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line">f<span class="comment">(a,b,c)</span> → f<span class="comment">(a)</span><span class="comment">(b)</span><span class="comment">(c)</span></span><br><span class="line"><span class="comment">// 部分函数调用</span></span><br><span class="line">f<span class="comment">(a,b,c)</span> → f<span class="comment">(a)</span><span class="comment">(b,c)</span> / f<span class="comment">(a,b)</span><span class="comment">(c)</span></span><br></pre></td></tr></table></figure><p><strong>柯里</strong>化强调的是生成<strong>单元函数</strong>，<strong>部分函数</strong>应用的强调的<strong>固定任意元参数</strong>，而我们平时生活中常用的其实是<strong>部分函数应用</strong>，这样的好处是可以固定参数，降低函数通用性，提高函数的适合用性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设一个通用的请求 API</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="function">(<span class="params"><span class="keyword">type</span>, url, options</span>) =&gt;</span> ...</span><br><span class="line"><span class="comment">// GET 请求</span></span><br><span class="line">request(<span class="string">'GET'</span>, <span class="string">'http://....'</span>)</span><br><span class="line"><span class="comment">// POST 请求</span></span><br><span class="line">request(<span class="string">'POST'</span>, <span class="string">'http://....'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是通过部分调用后，我们可以抽出特定 type 的 request</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = request(<span class="string">'GET'</span>);</span><br><span class="line"><span class="keyword">get</span>(<span class="string">'http://'</span>, &#123;..&#125;)</span><br></pre></td></tr></table></figure><h4 id="高级柯里化"><a href="#高级柯里化" class="headerlink" title="高级柯里化"></a>高级柯里化</h4><p>通常我们不会自己去写 curry 函数，现成的库大多都提供了 curry 函数的实现，但是使用过的人肯定有会有疑问，我们使用的 Lodash，Ramda 这些库中实现的 curry 函数的行为好像和柯里化不太一样呢，他们实现的好像是部分函数应用呢？</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">add</span><span class="bash"> = R.curry((x, y, z) =&gt;  x + y + z);</span></span><br><span class="line"><span class="bash">const add7 = add(7);</span></span><br><span class="line"><span class="bash">add7(1,2) // 10</span></span><br><span class="line"><span class="bash">const add1_2 = add(1,2);</span></span><br><span class="line"><span class="bash">add1_2(7) // 10</span></span><br></pre></td></tr></table></figure><p>其实，这些库中的 curry 函数都做了很多优化，导致这些库中实现的柯里化其实不是纯粹的柯里化，我们可以把他们理解为“高级柯里化”。这些版本实现可以根据你输入的参数个数，返回一个<strong>柯里化函数/结果值</strong>。即，<strong>如果你给的参数个数满足了函数条件，则返回值</strong>。这样可以解决一个问题，就是如果一个函数是多输入，就可以避免使用 (a)(b)(c) 这种形式传参了。<br>所以上面的 add7(1, 2) 能直接输出结果不是因为 add(7) 返回了一个接受 2 个参数的函数，而是你刚好传了 2 个参数，满足了所有参数，因此给你计算了结果，下面的代码就很明显了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">add</span><span class="bash"> = R.curry((x, y, z) =&gt;  x + y + z);</span></span><br><span class="line"><span class="bash">const add7 = add(7);</span></span><br><span class="line"><span class="bash">add(7)(1) // <span class="keyword">function</span></span></span><br></pre></td></tr></table></figure><p>如果 add7 是一个接受 2 个参数的函数，那么 add7(1) 就不应该返回一个 function 而是一个值了。<br>因此，记住这句话：<strong>我们可以用高级柯里化去实现部分函数应用，但是柯里化不等于部分函数应用</strong>。</p><h4 id="柯里化的应用"><a href="#柯里化的应用" class="headerlink" title="柯里化的应用"></a>柯里化的应用</h4><p>通常，我们在实践中使用柯里化都是为了把某个函数变得单值化，这样可以增加函数的多样性，使得其适用性更强：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const replace</span> = curry((a, b, str) =&gt; str.replace(a, b));</span><br><span class="line"><span class="attribute">const replaceSpaceWith</span> = replace(/\s*/);</span><br><span class="line"><span class="attribute">const replaceSpaceWithComma</span> = replaceSpaceWith(<span class="string">','</span>);</span><br><span class="line"><span class="attribute">const replaceSpaceWithDash</span> = replaceSpaceWith(<span class="string">'-'</span>);</span><br></pre></td></tr></table></figure><p>通过上面这种方式，我们从一个 replace 函数中产生很多新函数，可以在各种场合进行使用。<br>更重要的是，单值函数是我们即将讲到的<strong>函数组合的基础</strong>。</p><h3 id="流水线——函数组合"><a href="#流水线——函数组合" class="headerlink" title="流水线——函数组合"></a>流水线——函数组合</h3><p>上面我们借助 curry，已经可以很轻松的构造一个加工站了，现在就是我们组合成流水线的时候了。</p><h4 id="函数组合概念"><a href="#函数组合概念" class="headerlink" title="函数组合概念"></a>函数组合概念</h4><p>函数组合的目的是将多个函数组合成一个函数。下面来看一个简化版的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> x =&gt; f(g(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> fg = compose(f, g);</span><br><span class="line">fg(<span class="number">1</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>我们可以看到 compose 就实现了一个简单的功能：形成了一个全新的函数，而这个函数就是一条从 g -&gt; f 的流水线。同时我们可以很轻易的发现 compose 其实是满足结合律的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose(<span class="name">f</span>, compose(<span class="name">g</span>, <span class="literal">t</span>)) = compose(<span class="name">compose</span>(<span class="name">f</span>, g), <span class="literal">t</span>)  = f(<span class="name">g</span>(<span class="name">t</span>(<span class="name">x</span>)))</span><br></pre></td></tr></table></figure><p>只要其顺序一致，最后的结果是一致的，因此，我们可以写个更高级的 compose，支持多个函数组合：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose(<span class="name">f</span>, g, <span class="literal">t</span>) =&gt; x =&gt; f(<span class="name">g</span>(<span class="name">t</span>(<span class="name">x</span>))</span><br></pre></td></tr></table></figure><p>简单实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> (...args) =&gt; fns.reduceRight(<span class="function">(<span class="params">val, fn</span>) =&gt;</span> fn.apply(<span class="literal">null</span>, [].concat(val)), args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> t = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fgt = compose(f, g, t);</span><br><span class="line">fgt(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3 -&gt; 6 -&gt; 7</span></span><br></pre></td></tr></table></figure><h4 id="函数组合应用"><a href="#函数组合应用" class="headerlink" title="函数组合应用"></a>函数组合应用</h4><p>考虑一个小功能：将数组最后一个元素大写，假设 log, head，reverse，toUpperCase 函数存在（我们通过 curry 可以很容易写出来）<br>命令式的写法：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log(<span class="name">toUpperCase</span>(<span class="name">head</span>(<span class="name">reverse</span>(<span class="name">arr</span>))))</span><br></pre></td></tr></table></figure><p>面向对象的写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arr</span><span class="selector-class">.reverse</span>()</span><br><span class="line">  <span class="selector-class">.head</span>()</span><br><span class="line">  <span class="selector-class">.toUpperCase</span>()</span><br><span class="line">  <span class="selector-class">.log</span>()</span><br></pre></td></tr></table></figure><p>链式调用看起来顺眼多了，然而问题在于，原型链上可供我们链式调用的函数是有限的，而需求是无限的 ，这限制了我们的逻辑表现力。</p><p>再看看，现在通过组合，我们如何实现之前的功能：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> upperLastItem = compose(<span class="built_in">log</span>, toUpperCase, head, <span class="built_in">reverse</span>);</span><br></pre></td></tr></table></figure><p>通过参数我们可以很清晰的看出发生了 uppderLastItem 做了什么，它完成了一套流水线，所有经过这条流水线的参数都会经历：reverse -&gt; head -&gt; toUpperCase -&gt; log 这些函数的加工，最后生成结果。</p><p>最完美的是，这些函数都是非常简单的纯函数，你可以随意组合，随意拿去用，不用有任何的顾忌。<br>其实有些经验丰富的程序猿已经看出来一些蹊跷，这不就是所谓管道 ( pipe ) 的概念嘛？在 Linux 命令中常会用到，类似ps grep的组合</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> nginx</span><br></pre></td></tr></table></figure><p>只是管道的执行方向和 compose (从右往左的组合 ) 好像刚好相反，因此很多函数库（Lodash，Ramda）中也提供了另一种组合方式：pipe（从左往右的组合）</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> upperLastItem = R.pipe(<span class="built_in">reverse</span>, head, toUppderCase, <span class="built_in">log</span>);</span><br></pre></td></tr></table></figure><p>其实函数式编程的理念和 Linux 的设计哲学很像：</p><blockquote><p>有众多单一目的的小程序，一个程序只实现一个功能，多个程序组合完成复杂任务。</p></blockquote><h4 id="函数组合的好处"><a href="#函数组合的好处" class="headerlink" title="函数组合的好处"></a>函数组合的好处</h4><p>函数组合的好处显而易见，它让代码变得简单而富有可读性，同时通过不同的组合方式，我们可以轻易组合出其他常用函数，让我们的代码更具表现力</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合方式 1</span></span><br><span class="line"><span class="keyword">const</span> last = compose(head, <span class="built_in">reverse</span>);</span><br><span class="line"><span class="keyword">const</span> shout = compose(<span class="built_in">log</span>, toUpperCase);</span><br><span class="line"><span class="keyword">const</span> shoutLast = compose(shout, last);</span><br><span class="line"><span class="comment">// 组合方式 2</span></span><br><span class="line"><span class="keyword">const</span> lastUppder = compose(toUpperCase, head, <span class="built_in">reverse</span>);</span><br><span class="line"><span class="keyword">const</span> logLastUpper = compose(<span class="built_in">log</span>, lastUppder);</span><br></pre></td></tr></table></figure><p>这个过程，就像搭乐高积木一样。</p><p>由此可见，大型的程序，都可以通过这样一步步的拆分组合实现，而剩下要做的，就是去构造足够多的积木块（函数）。</p><h3 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h3><p>在使用柯里化和函数组合的时候，有一些经验可以借鉴一下：</p><h4 id="柯里化中把要操作的数据放到最后"><a href="#柯里化中把要操作的数据放到最后" class="headerlink" title="柯里化中把要操作的数据放到最后"></a>柯里化中把要操作的数据放到最后</h4><p>因为我们的输出通常是需要操作的数据，这样当我们固定了之前的参数（我们可以称为配置）后，可以变成一个单元函数，直接被<strong>函数组合</strong>使用，这也是其他的函数式语言遵循的规范：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const split = curry((<span class="name">x</span>, str) =&gt; str.split(<span class="name">x</span>))<span class="comment">;</span></span><br><span class="line">const join = curry((<span class="name">x</span>, arr) =&gt; arr.join(<span class="name">x</span>))<span class="comment">;</span></span><br><span class="line">const replaceSpaceWithComma = compose(<span class="name">join</span>(','), split(' '))<span class="comment">;</span></span><br><span class="line">const replaceCommaWithDash = compose(<span class="name">join</span>('-'), split(','))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>复制代码但是如果有些函数没遵循这个约定，我们的函数该如何组合？当然也不是没办法，很多库都提供了占位符的概念，例如 Ramda 提供了一个占位符号（R.__）。假设我们的 split 把 str 放在首位</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const split = curry((<span class="name">str</span>, x) =&gt; str.split(<span class="name">x</span>))<span class="comment">;</span></span><br><span class="line">const replaceSpaceWithComma = compose(<span class="name">join</span>(','), split(<span class="name">R</span>.__, ' '))<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="函数组合中函数要求单输入"><a href="#函数组合中函数要求单输入" class="headerlink" title="函数组合中函数要求单输入"></a>函数组合中函数要求单输入</h4><p>函数组合有个使用要点，就是中间的函数一定是<strong>单输入</strong>的，这个很好理解，之前也说过了，因为函数的输出都是单个的（数组也只是一个元素）。</p><h4 id="函数组合的-Debug"><a href="#函数组合的-Debug" class="headerlink" title="函数组合的 Debug"></a>函数组合的 Debug</h4><p>当遇到函数出错的时候怎么办？我们想知道在哪个环节出错了，这时候，我们可以借助一个辅助函数 trace，它会临时输出当前阶段的结果。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const trace = curry((<span class="name">tip</span>, x) =&gt; &#123; console.log(<span class="name">tip</span>, x)<span class="comment">; return x; &#125;);</span></span><br><span class="line">const lastUppder = compose(<span class="name">toUpperCase</span>, head, trace('after reverse'), reverse)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="多参考-Ramda"><a href="#多参考-Ramda" class="headerlink" title="多参考 Ramda"></a>多参考 Ramda</h4><p>现有的函数式编程工具库很多，Lodash/fp 也提供了，但是不是很推荐使用 Lodash/fp 的函数库，因为它的很多函数把需要处理的参数放在了首位（ 例如 map ）这不符合我们之前说的最佳实践。<br>这里推荐使用 <strong>Ramda</strong>，它应该是目前最符合函数式编程的工具库，它里面的所有函数都是 curry 的，而且需要操作的参数都是放在最后的。上述的 split，join，replace 这些基本的都在 Ramda 中可以直接使用，它一共提供了 200 多个超实用的函数，合理使用可以大大提高你的编程效率（目前我的个人经验来说，我需要的功能它 90%都提供了）。</p><h2 id="实战一下"><a href="#实战一下" class="headerlink" title="实战一下"></a>实战一下</h2><p>现在你已经基本学会了所有的基础概念，那让我们来实战一下吧！<br>假设我现在有一套数据：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">data</span> <span class="string">=</span> <span class="string">[</span></span><br><span class="line">  <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">'Peter'</span><span class="string">,</span></span><br><span class="line"><span class="attr">    sex:</span> <span class="string">'M'</span><span class="string">,</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">18</span><span class="string">,</span></span><br><span class="line"><span class="attr">    grade:</span> <span class="number">99</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">……</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><p>实现以下几个常用功能：</p><ol><li>获取所有年龄小于 18 岁的对象，并返回他们的名称和年龄。</li><li>查找所有男性用户。</li><li>更新一个指定名称用户的成绩（不影响原数组）。</li><li>取出成绩最高的 10 名，并返回他们的名称和分数。</li></ol><p>我这边提供以下 Ramda 库中的参考函数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 对象操作（最后一个参数是对象），均会返回新的对象拷贝</span><br><span class="line">R.prop(<span class="string">'name'</span>)    <span class="regexp">//</span> 获取对象 name 字段的值</span><br><span class="line">R.propEq(<span class="string">'name'</span>, <span class="string">'123'</span>)   <span class="regexp">//</span> 判断对象 name 字段是否等于‘<span class="number">123</span>’</span><br><span class="line">R.assoc(<span class="string">'name'</span>, <span class="string">'123'</span>)   <span class="regexp">//</span> 更新对象的<span class="string">'name'</span>的值为<span class="string">'123'</span></span><br><span class="line">R.pick([<span class="string">'a'</span>, <span class="string">'d'</span>]); <span class="regexp">//</span>=&gt; &#123;a: <span class="number">1</span>, d: <span class="number">4</span>&#125;  <span class="regexp">//</span> 获取对象某些属性，如果对应属性不存在则不返回</span><br><span class="line">R.pickAll([<span class="string">'a'</span>, <span class="string">'d'</span>]); <span class="regexp">//</span>=&gt; &#123;a: <span class="number">1</span>, d: <span class="number">4</span>&#125;  <span class="regexp">//</span> 获取对象某些属性，如果对应属性不存在则返回`key : undefined`</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 数组操作</span><br><span class="line">R.map(<span class="keyword">func</span>)  <span class="regexp">//</span> 传统的 map 操作</span><br><span class="line">R.filter(<span class="keyword">func</span>)  <span class="regexp">//</span> 传统的 filter 操作</span><br><span class="line">R.reject(<span class="keyword">func</span>)  <span class="regexp">//</span> filter 的补集</span><br><span class="line">R.take(n)    <span class="regexp">//</span> 取出数组前 n 个元素</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 比较操作</span><br><span class="line">R.equals(a, b)  <span class="regexp">//</span> 判断 b 是否等于 a </span><br><span class="line">R.gt(<span class="number">2</span>, <span class="number">1</span>) =&gt; true  <span class="regexp">//</span> 判断第一个参数是否大于第二个参数</span><br><span class="line">R.lt(<span class="number">2</span>, <span class="number">1</span>) =&gt; false <span class="regexp">//</span> 判断第一个参数是否小于第二个参数</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 排序操作</span><br><span class="line">R.sort(<span class="keyword">func</span>)    <span class="regexp">//</span> 根据某个排序函数排序</span><br><span class="line">R.ascend(<span class="keyword">func</span>)    <span class="regexp">//</span> 根据 <span class="keyword">func</span> 转换后的值，生成一个升序比较函数</span><br><span class="line">R.descend(<span class="keyword">func</span>)    <span class="regexp">//</span> 根据 <span class="keyword">func</span> 转换后的值，生成一个降序比较函数</span><br><span class="line"><span class="regexp">//</span> 例子：</span><br><span class="line">R.sort(R.ascend(R.prop(<span class="string">'age'</span>)))  <span class="regexp">//</span> 根据 age 进行升序排序 </span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 必备函数</span><br><span class="line">R.pipe()   <span class="regexp">//</span>compose 的反向，从前往后组合</span><br><span class="line">R.compose()  <span class="regexp">//</span> 从后到前组合</span><br><span class="line">R.curry()  <span class="regexp">//</span> 柯里化</span><br></pre></td></tr></table></figure><p>可以想想看，如果是你会如何写这些函数，我这里提供了一个 codepen 的模板，可以在这里写你的答案，会自动测试。</p><p>（我的答案放在文章后面，请先思考完再看）</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="Hindly-Milner-类型签名"><a href="#Hindly-Milner-类型签名" class="headerlink" title="Hindly Milner 类型签名"></a>Hindly Milner 类型签名</h3><p>之前我们遇到了类似这样的说明：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:: String -&gt; Object</span><br></pre></td></tr></table></figure><p>这叫类型签名，最早是在 Hindley-Milner 类型系统中提出来的。<br>你也能在 Ramda 的官网上看到类似的类型签名：</p><p>引入它的好处显而易见，短短一行，就能暴露函数的行为和目的，方便我们了解语义。有时候一个函数可能很长，光从代码上很难理解它到底做了什么：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const replace = <span class="string">reg =&gt;</span> <span class="string">sub =&gt;</span> <span class="string">str =&gt;</span> str.replace(reg, <span class="function"><span class="keyword">sub</span>)</span>;</span><br></pre></td></tr></table></figure><p>而加上类型签名，我们至少能知道每一步它做了哪些转换，最后输出一个什么样的结果。<br>例如这个 replace ，通过类型签名我们知道它接受一个 正则表达 式和两个 String，最后会返回一个 String。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  <span class="built_in">replace</span> :: Regex -&gt; String -&gt; String -&gt; String</span><br><span class="line">const <span class="built_in">replace</span> = reg =&gt; sub =&gt; str =&gt; str.<span class="built_in">replace</span>(reg, sub);</span><br></pre></td></tr></table></figure><p>这样的连续箭头看起来可能很头疼，其实稍微组合一下可以发现，它就是柯里化的意思：先传一个 正则表达式 会返回一个函数，如果再传一个 String，也会返回函数……直到你输入了最后一个 String，就会返回一个 String 的结果。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//  <span class="built_in">replace</span> :: Regex -&gt; （String -&gt; （String -&gt; String))</span><br></pre></td></tr></table></figure><p>同时类型签名可以避免我们在合并函数的时候输入和输出的类型不一致。<br>例如 join 函数通过类型签名很明显是传入一个 String 的配置，然后就可以将一个 String 数组 转换成 String。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// join :: <span class="built_in">String</span> -&gt; [<span class="built_in">String</span>] -&gt; <span class="built_in">String</span></span><br><span class="line"><span class="keyword">const</span> join = curry((sep, arr) =&gt; arr.join(sep))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>同样，下面这个函数，它接受一个 String，然后经过 strLen 转换能返回一个 Number。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">strLen </span>:: <span class="keyword">String </span>-&gt; Number</span><br><span class="line"><span class="symbol">const</span> <span class="keyword">strLen </span>= <span class="keyword">str </span>=&gt; <span class="keyword">str.length();</span></span><br></pre></td></tr></table></figure><p>那我们很容易知道，以上两个函数完全可以组合，因为他们输入和输出类型一致，通过组合我们可以完成一个 String 数组 到 Number 的流水线。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> joinDash = <span class="keyword">join</span>(<span class="string">'-'</span>);</span><br><span class="line"><span class="keyword">const</span> lengthWithDash = compose(strLen, joinDash);</span><br><span class="line">lengthWithDash([<span class="string">'abc'</span>, <span class="string">'def'</span>]);  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>当然还有时候你的函数可能不是接受特定的类型，而只是做一些通用的事情，此时我们可以用 a, b, c…… 这些来替代一些通用类型，例如 map ，它传入一个可以把 a 转换成 b 的函数，然后把a 数组 转换成b 数组。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class="line"><span class="keyword">var</span> map = curry(<span class="function"><span class="keyword">function</span><span class="params">(f, xs)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> xs.map(f);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  head :: [a] -&gt; a</span></span><br><span class="line"><span class="keyword">var</span> head = <span class="function"><span class="keyword">function</span><span class="params">(xs)</span></span>&#123; <span class="keyword">return</span> xs[<span class="number">0</span>]; &#125;</span><br></pre></td></tr></table></figure><p>现在你就学会了类型签名的使用了，我们推荐你写的每个函数都加上类型签名，方便他人，方便自己。</p><h3 id="Pointfree-编程风格"><a href="#Pointfree-编程风格" class="headerlink" title="Pointfree 编程风格"></a>Pointfree 编程风格</h3><p>我之前提过一下 Pointfree 这种编程风格，它其实就是强调在整个函数编写过程中不出现参数（point），而只是通过函数的组合生成新的函数，实际数据只需要在最后使用函数的时候再传入即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pointfree  没有出现需要操作的参数</span></span><br><span class="line"><span class="keyword">const</span> upperLastItem = compose(toUpperCase, head, reverse);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非 Pointfree 出现了需要操作的参数</span></span><br><span class="line"><span class="keyword">const</span> upperLastItem = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> reverseArr = arr.reverse();</span><br><span class="line">  <span class="keyword">const</span> head = reverseArr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> head.toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用函数式编程的时候，其实自然就会形成这种风格，它有什么好处呢？</p><ul><li><strong>无需考虑参数命名</strong>：能减轻不少思维负担，毕竟参数命名也是个很费事的过程。</li><li><strong>关注点集中</strong>：你无需考虑数据，只需要把所有的注意力集中在转换关系上。</li><li><strong>代码精简</strong>：可以省去通过中间变量不断的去传递数据的过程。</li><li><strong>可读性强</strong>：一眼就可以看出来数据的整个的转换关系。</li></ul><p>刚开始使用这种编程风格肯定会有很多不适应，但是当你能合理运用这种编程风格后确实会让代码更加简洁和易于理解了。但是凡事无绝对，学了 Pointfree 这种风格并不意味着你要强迫自己做到一个参数都不能出现（比如很多基础函数，他们本身的编写就不是 Pointfree 的），函数式编程也不是所有场合都完全适用的，具体情况具体分析。</p><p>记住，你学习各种编程范式的<strong>最终目的都是为了让自己的编码更加高效，易懂，同时减少出错概率</strong>，不能因为学了一种编程范式，反而导致自己的编程成本大大增加，这就有点本末倒置了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面介绍了很多函数式编程的概念可以总结出函数式编程的优点：</p><ul><li><strong>代码简洁，开发快速</strong>：函数式编程大量使用函数的组合，函数的复用率很高，减少了代码的重复，因此程序比较短，开发速度较快。Paul Graham 在《黑客与画家》一书中写道：同样功能的程序，极端情况下，Lisp 代码的长度可能是 C 代码的二十分之一。</li><li><strong>接近自然语言，易于理解</strong>：函数式编程大量使用声明式代码，基本都是接近自然语言的，加上它没有乱七八糟的循环，判断的嵌套，因此特别易于理解。</li><li><strong>易于”并发编程”</strong>：函数式编程没有副作用，所以函数式编程不需要考虑“死锁”（Deadlock），所以根本不存在“锁”线程的问题。</li><li><strong>更少的出错概率</strong>：因为每个函数都很小，而且相同输入永远可以得到相同的输出，因此测试很简单，同时函数式编程强调使用纯函数，没有副作用，因此也很少出现奇怪的 Bug。</li></ul><p>因此，如果用一句话来形容函数式编程，应该是：Less code, fewer bugs 。因为写的代码越少，出错的概率就越小。人是最不可靠的，我们应该尽量把工作交给计算机。</p><p>一眼看下来好像函数式可以解决所有的问题，但是实际上，函数式编程也不是什么万能的灵丹妙药。正因为函数式编程有以上特点，所以它天生就有以下缺陷：</p><ul><li><strong>性能</strong>：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销。同时，在 JS 这种非函数式语言中，函数式的方式必然会比直接写语句指令慢（引擎会针对很多指令做特别优化）。就拿原生方法 map 来说，它就要比纯循环语句实现迭代慢 8 倍。</li></ul><ul><li><strong>资源占用</strong>：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收（Garbage Collection）所产生的压力远远超过其他编程方式。这在某些场合会产生十分严重的问题。</li></ul><ul><li><strong>递归陷阱</strong>：在函数式编程中，为了实现迭代，通常会采用递归操作，为了减少递归的性能开销，我们往往会把递归写成尾递归形式，以便让解析器进行优化。但是众所周知，JS 是不支持尾递归优化的（虽然 ES6 中将尾递归优化作为了一个规范，但是真正实现的少之又少，传送门）</li></ul><p>因此，在性能要求很严格的场合，函数式编程其实并不是太合适的选择。</p><p>但是换种思路想，软件工程界从来就没有停止过所谓的银弹之争，却也从来没诞生过什么真正的银弹，各种编程语言层出不穷，各种框架日新月异，各种编程范式推陈出新，结果谁也没有真正的替代谁。</p><p>学习函数式编程真正的意义在于：让你意识到在指令式编程，面向对象编程之外，还有一种全新的编程思路，一种用函数的角度去抽象问题的思路。学习函数式编程能大大丰富你的武器库，不然，当你手中只有一个锤子，你看什么都像钉子。</p><p>我们完全可以在日常工作中将函数式编程作为一种辅助手段，在条件允许的前提下，借鉴函数式编程中的思路，例如：</p><ul><li>多使用纯函数减少副作用的影响。</li><li>使用柯里化增加函数适用率。</li><li>使用 Pointfree 编程风格，减少无意义的中间变量，让代码更且可读性。</li></ul><p>最后，还是那句老生常谈的话：</p><blockquote><p>没有最好的，只有最适合的</p></blockquote><p>希望大家在实际项目中，能根据自己的需求选择最适合自己的编程范式，也希望通过学习这种新的编程范式，可以让我们在二进制的世界行走得更加游刃有余。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://legacy.gitbook.com/book/llh911001/mostly-adequate-guide-chinese" target="_blank" rel="noopener">mostly-adequate-guide-chinese</a></p><p><a href="http://djyde.github.io/blog/declarative-programming-is-the-future/" target="_blank" rel="noopener">未来属于声明式编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;本文较长，总共分为三大部分：(对于函数式编程以及其优点有一定理解的童鞋，可以直接从  第二部分 开始阅读)&lt;/p&gt;
&lt;p&gt;第一部分：首先会通过实际代码介绍一下什么是函数式编程
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://chongdee.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://chongdee.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>跨页面通信</title>
    <link href="https://chongdee.github.io/2021/07/21/wxmini/%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1/"/>
    <id>https://chongdee.github.io/2021/07/21/wxmini/跨页面通信/</id>
    <published>2021-07-20T18:30:20.539Z</published>
    <updated>2021-07-20T16:39:28.555Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="1-直接通过跳转二级时候加上参名和参值"><a href="#1-直接通过跳转二级时候加上参名和参值" class="headerlink" title="1.直接通过跳转二级时候加上参名和参值"></a>1.直接通过跳转二级时候加上参名和参值</h2><p>比如我跳转url给的是:rich/rich?url=<a href="https://xxxx" target="_blank" rel="noopener">https://xxxx</a></p><p>然后在二级用</p><p>onLoad: function (options) {}</p><p>读取，其中options就是传过来的值，验证很简单，你直接console看一下就好</p><p>上面案例就能看到键名为url的键的键值是<a href="https://xxxx" target="_blank" rel="noopener">https://xxxx</a></p><h2 id="2-设定一个全局，然后读取全局就OK"><a href="#2-设定一个全局，然后读取全局就OK" class="headerlink" title="2.设定一个全局，然后读取全局就OK"></a>2.设定一个全局，然后读取全局就OK</h2><p>在app.js里面设置为:</p><p>this.globalData.变量名 = xxxx;</p><p>其他页面设置为:</p><p>app.globalData.变量名 = xxxx;</p><p>读取的话。。。</p><p>var xxx = getApp().globalData.变量名;</p><h2 id="3-直接存缓存中"><a href="#3-直接存缓存中" class="headerlink" title="3.直接存缓存中"></a>3.直接存缓存中</h2><p>wx.setStorageSync(键名, 键值);</p><p>获取的话</p><p>var xxx = wx.getStorageSync(键名);</p><p>当然，你也可以去掉getStorageSync的Sync，这样就能异步获取了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;1-直接通过跳转二级时候加上参名和参值&quot;&gt;&lt;a href=&quot;#1-直接通过跳转二级时候加上参名和参值&quot; class=&quot;headerlink&quot; title=&quot;1.直接
      
    
    </summary>
    
      <category term="wxmini" scheme="https://chongdee.github.io/categories/wxmini/"/>
    
    
      <category term="wxmini" scheme="https://chongdee.github.io/tags/wxmini/"/>
    
  </entry>
  
  <entry>
    <title>微信支付，h5支付，jsapi支付</title>
    <link href="https://chongdee.github.io/2021/07/21/wxmini/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%8Ch5%E6%94%AF%E4%BB%98%EF%BC%8Cjsapi%E6%94%AF%E4%BB%98/"/>
    <id>https://chongdee.github.io/2021/07/21/wxmini/微信支付，h5支付，jsapi支付/</id>
    <published>2021-07-20T18:30:20.533Z</published>
    <updated>2021-07-20T16:18:59.850Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>因业务需要，开发微信支付功能，涉及三种支付方式：</p><ul><li>JSAPI 支付：微信内网页支付，需要开通微信服务号</li><li>小程序支付：在小程序中支付，需要开通小程序</li><li>H5 支付：在手机浏览器（出微信内网爷）中网页支付</li></ul><p>使用微信支付的前提必开通微信商户号，要使用到那种的支付方式要前需在商户平台开通（要审核）。</p><p>支付的钱最终都会到商户号里（一般由公司财务开通）。</p><p>开发微信支付的过程中大大小小坑还是踩了不少，终于做完了，整理下开发流程。</p><p>参考：</p><ul><li>微信支付-接入指引</li><li>微信支付-开发文档</li></ul><h2 id="小程序支付"><a href="#小程序支付" class="headerlink" title="小程序支付"></a>小程序支付</h2><p>开发流程</p><ul><li>小程序端请求创建订单接口，后端统一下单获取 orderId 并返回</li><li>小程序端获取通过wx.login()获取code</li><li>小程序端拿这code和orderId请求后端接口，获取支付所需数据</li><li>获取支付所需数据之后，小程序端调用wx.requestPayment()接口，直接调用起支付页面</li><li>判断是否支付成功后的逻辑</li></ul><p>伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">wxPay</span>(<span class="params">goodId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 创建订单 获取orderId</span></span><br><span class="line">  <span class="keyword">let</span> orderId = <span class="keyword">await</span> ajax(<span class="string">"POST"</span>, <span class="string">"/api/OrderProgram/CreateTheOrder"</span>, &#123;</span><br><span class="line">    goodId, <span class="comment">// 商品id</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 2. 获得 code</span></span><br><span class="line">  <span class="keyword">let</span> code = <span class="keyword">await</span> wxlogin(); <span class="comment">// 基于pr封装的wx.login()方法</span></span><br><span class="line">  <span class="comment">// 3. 获取支付的数据</span></span><br><span class="line">  <span class="keyword">let</span> payData = <span class="keyword">await</span> ajax(<span class="string">"POST"</span>, <span class="string">"/api/OrderProgram/WxXcxPay"</span>, &#123;</span><br><span class="line">    orderId,</span><br><span class="line">    code,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 4. 发起支付</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> payment(payData); <span class="comment">// 基于pr封装的wx.requestPayment()方法</span></span><br><span class="line">  <span class="comment">// 5. 判断是否支付成功</span></span><br><span class="line">  <span class="keyword">let</span> payResult = res.errMsg;</span><br><span class="line">  <span class="keyword">if</span> (payResult == <span class="string">"requestPayment:ok"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"支付成功"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (payResult == <span class="string">"requestPayment:fail cancel"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"用户取消支付"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"支付失败"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>申请微信小程序账号</li></ol><p>申请成功可拿到 AppID（小程序 id）和 AppSecret（小程序密钥）<br>申请类型为企业性质，否则无法接入微信支付</p><ol><li>微信小程序认证</li></ol><p>通过认证的小程序才能接入微信支付和绑定商户平台</p><ol><li>申请商户平台账号</li></ol><p>需要第一步申请的 AppID<br>申请成功可拿到 MchID（商户 id）和 MchKey（商户密钥）</p><ol><li>信小程序关联商户号</li></ol><p>微信和商户都认证成功后，在微信后台微信支付菜单中进行关联</p><ol><li><p>接入微信支付</p><p>在微信后台微信支付菜单中进行接入</p></li></ol><p>参考</p><ul><li>小程序支付文档</li><li>小程序开发文档<h2 id="H5-支付"><a href="#H5-支付" class="headerlink" title="H5 支付"></a>H5 支付</h2>开发流程</li></ul><ol><li>前端端请求创建订单接口，后端统一下单获取 orderId 并返回</li><li>前端带着 orderId 请求支付接口，获得 mweb_url，</li><li>然后跳转 mweb_url 会跳转微信自动调用微信支付</li><li><p>支付后返回支付页，判断是否支付成功（需发送请求后端查询）</p><p> 刷新页面，获取最新的支付（订单）状态。</p><p> 设置一个的按钮”我已支付”，让用户点击自动查询状态。<br>伪代码</p></li></ol><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async function wxH5Pay(goodId) &#123;</span><br><span class="line">  // <span class="number">1</span>. 创建订单 获取orderId</span><br><span class="line">  let orderId = await ajax(<span class="string">"<span class="keyword">POST</span>"</span>, <span class="string">"/api/OrderProgram/CreateTheOrder"</span>, &#123;</span><br><span class="line">    goodId, // 商品id</span><br><span class="line">  &#125;);</span><br><span class="line">  // <span class="number">2</span>. 获取支付跳转的URL</span><br><span class="line">  let mweb_url = await ajax(<span class="string">"<span class="keyword">POST</span>"</span>, <span class="string">"/api/OrderProgram/WxH5Pay"</span>, &#123; orderId &#125;);</span><br><span class="line">  // <span class="number">3</span>. 跳转URL去微信支付</span><br><span class="line">  if (mweb_url) &#123;</span><br><span class="line">    location.href = mweb_url;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(<span class="string">"回调地址出错"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  // <span class="number">4</span>. 支付后返回支付页，判断是否支付成功</span><br><span class="line">  // <span class="number">4</span>.<span class="number">1</span> 刷新页面，获取最新的订单(商品)状态。</span><br><span class="line">  // <span class="number">4</span>.<span class="number">2</span> 设置一个<span class="string">"我已支付"</span>的按钮，让用户点击之后查询状态。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>在商户平台设置正确的支付域名</li><li>调试需要在线上，如果嫌麻烦可以使用内网穿透（Ngrok 或花生壳）</li><li>需对redirect_url进行urlencode处理</li><li><p>H5 支付不能直接在微信客户端内调起，请在外部浏览器调起。<br>参考</p></li><li><p>微信支付-H5 支付-开发步骤</p><h2 id="JSAPI-支付（微信内网页支付）"><a href="#JSAPI-支付（微信内网页支付）" class="headerlink" title="JSAPI 支付（微信内网页支付）"></a>JSAPI 支付（微信内网页支付）</h2><p>开发流程</p></li></ul><h3 id="商品页"><a href="#商品页" class="headerlink" title="商品页"></a>商品页</h3><ol><li>前端商品页创建订单，在后端统一下单后获取 orderId</li><li>前端带着 orderId 跳转到支付页，<h3 id="支付页"><a href="#支付页" class="headerlink" title="支付页"></a>支付页</h3></li><li>获取 code</li></ol><ul><li>第一次进入页面，判断是否路径中有 code</li><li>没有 code，请求数据跳转授权页面，code 会通过回调地址一起返回回来</li><li>拿到 code，发送给后端，后端解析到 openid，保存好。</li></ul><ol><li><p>点击确定支付按钮，触发 wxPay() 方法</p></li><li><p>发送 orderId 给后端，获取 wxData</p></li><li>wxData 中包含 wx.config 和 wx.chooseWXPay 两个接口的数据。</li><li><p>先调用 wx.config()然后在调用 wx.chooseWXPay()，如果一切正常，支付页面就会弹出。</p></li><li><p>支付状态通过后端去查询<br>伪代码</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">商品页</span><br><span class="line"><span class="comment">// 1. 创建订单 获取orderId</span></span><br><span class="line"><span class="keyword">let</span> orderId = <span class="keyword">await</span> ajax(<span class="string">"POST"</span>, <span class="string">"/api/OrderProgram/CreateTheOrder"</span>, &#123;</span><br><span class="line">  goodId, <span class="comment">// 商品id</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2. 携带id 跳转到支付页</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123; name: <span class="string">"wx_pay_page"</span>, params: &#123; orderId: id &#125; &#125;);</span><br><span class="line">入口文件(main.js)</span><br><span class="line"><span class="comment">// main.js 引入 js-sdk</span></span><br><span class="line"><span class="keyword">import</span> wx <span class="keyword">from</span> <span class="string">"weixin-js-sdk"</span>;</span><br><span class="line">支付页 HTML</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button <span class="meta">@click</span>=<span class="string">"wxPay"</span>&gt;点击支付button&gt;</span><br><span class="line">  div&gt;</span><br><span class="line">template&gt;</span><br><span class="line">支付页 JS</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue</span></span><br><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        orderId: <span class="keyword">this</span>.$route.params.orderId, <span class="comment">// 订单id</span></span><br><span class="line">        url: <span class="string">''</span>,<span class="comment">// 获取code的url</span></span><br><span class="line">        wxData: <span class="literal">null</span>,<span class="comment">// js-sdk接口所需的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123;</span><br><span class="line">    <span class="comment">// 判断是否有code</span></span><br><span class="line">    <span class="keyword">this</span>.getCode()</span><br><span class="line">&#125;</span><br><span class="line">methods: &#123;</span><br><span class="line">    getCode() &#123;</span><br><span class="line">        <span class="keyword">var</span> code = <span class="keyword">this</span>.getUrlPram(<span class="string">"code"</span>);</span><br><span class="line">        <span class="keyword">if</span> (code != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.code = code;</span><br><span class="line">            <span class="comment">// 拿到 code 发给 后端</span></span><br><span class="line">            <span class="keyword">this</span>.sendCode(code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 去拿code</span></span><br><span class="line">            <span class="keyword">this</span>.getUrl();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getUrl() &#123;</span><br><span class="line">        <span class="comment">// 请求后端拿到url所需数据，然后跳转页面在通过回调地址返回，获取code.</span></span><br><span class="line">        <span class="keyword">this</span>.axios</span><br><span class="line">            .post(<span class="string">"/api/OrderProgram/GetOpenidAndAccessToken"</span>, &#123;</span><br><span class="line">                orderId: <span class="keyword">this</span>.orderId,</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.url = <span class="string">`https://open.weixin.qq.com/connect/oauth2/authorize?appid=<span class="subst">$&#123;data.appId&#125;</span>&amp;redirect_uri=<span class="subst">$&#123;data.redirect_uri&#125;</span>&amp;response_type=<span class="subst">$&#123;data.response_type&#125;</span>&amp;scope=<span class="subst">$&#123;data.scope&#125;</span>&amp;state=<span class="subst">$&#123;data.state&#125;</span>`</span>;</span><br><span class="line">                <span class="built_in">window</span>.location.href = <span class="keyword">this</span>.url;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    sendCode(code) &#123;</span><br><span class="line">        <span class="comment">// 发送code给后端 后端解析出openid</span></span><br><span class="line">        <span class="keyword">this</span>.axios</span><br><span class="line">            .post(<span class="string">"/api/OrderProgram/GetOpenidAndAccessTokenFromCode"</span>, &#123;</span><br><span class="line">                code: code,</span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res);</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    wxPay: <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 发送orderid，获取wx.chooseWXPay和wx.config所需的参数</span></span><br><span class="line">        <span class="keyword">this</span>.wxData = <span class="keyword">await</span> <span class="keyword">this</span>.axios.post(</span><br><span class="line">            <span class="string">"/api/OrderProgram/WxJSAPIPay"</span>,</span><br><span class="line">            &#123; orderId: <span class="keyword">this</span>.orderId &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">let</span> wxConfigData = <span class="keyword">this</span>.wxData.wxConfigData <span class="comment">// 获取wx.chooseWXPay()所需数据</span></span><br><span class="line">        <span class="keyword">let</span> wxPayData = <span class="keyword">this</span>.wxData.wxPayData;<span class="comment">// 获取wx.config()所需数据</span></span><br><span class="line">        <span class="keyword">this</span>.$wx.config(&#123;</span><br><span class="line">            debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span></span><br><span class="line">            appId: wxConfigData.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">            timestamp: wxConfigData.timeStamp, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">            nonceStr: wxConfigData.nonceStr, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">            signature: wxConfigData.paySign, <span class="comment">// 必填，签名</span></span><br><span class="line">            jsApiList: [</span><br><span class="line">                <span class="string">"chooseWXPay"</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 执行支付</span></span><br><span class="line">        <span class="keyword">this</span>.$wx.chooseWXPay(&#123;</span><br><span class="line">            timestamp: wxPayData.timeStamp, <span class="comment">// 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符</span></span><br><span class="line">            nonceStr: wxPayData.nonceStr, <span class="comment">// 支付签名随机串，不长于 32 位</span></span><br><span class="line">            package: wxPayData.package, <span class="comment">// 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*）</span></span><br><span class="line">            signType: wxPayData.signType, <span class="comment">// 签名方式，默认为'SHA1'，使用新版支付需传入'MD5'</span></span><br><span class="line">            paySign: wxPayData.paySign, <span class="comment">// 支付签名</span></span><br><span class="line">            success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.$toast(<span class="string">"支付成功"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            fail: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.$toast(<span class="string">"支付失败"</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时支持 H5 支付和 JSAPI 支付</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在创建订单之后，就判断环境使用哪种方法支付。</span></span><br><span class="line"><span class="keyword">if</span> (isWx()) &#123;</span><br><span class="line">  <span class="keyword">this</span>.WXPay(orderId); <span class="comment">// 带着orderId跳转到支付页逻辑</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.H5Pay(orderId); <span class="comment">// 执行上面H5支付中的创建订单之后的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否是微信浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWx</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> uAgent = navigator.userAgent.toLowerCase();</span><br><span class="line">  reutrn(<span class="regexp">/micromessenger/</span>.test(uAgent)) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项<br>开通微信商户号 - 设置支付目录（如果是 Vue 这类 SPA 页面，到根目录即可，也就是#号之前的地址）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;因业务需要，开发微信支付功能，涉及三种支付方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSAPI 支付：微信内网页支付，需要开通微信服务号&lt;/li&gt;
&lt;li&gt;小程序支付：在小程序中支付
      
    
    </summary>
    
      <category term="wxmini" scheme="https://chongdee.github.io/categories/wxmini/"/>
    
    
      <category term="wxmini" scheme="https://chongdee.github.io/tags/wxmini/"/>
    
  </entry>
  
  <entry>
    <title>wx页面跳转数据传递</title>
    <link href="https://chongdee.github.io/2021/07/21/wxmini/wx%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>https://chongdee.github.io/2021/07/21/wxmini/wx页面跳转数据传递/</id>
    <published>2021-07-20T18:30:20.527Z</published>
    <updated>2021-07-20T16:44:33.831Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在写小程序的时候经常会遇到子页面向主页面回传数据或者普通页面跳转到tabBar 页面携带数据</p><blockquote><p>下面写了四种方法大家根据自己的实际场景来选择使用哪种</p></blockquote><h3 id="wx-navigateTo-OBJECT"><a href="#wx-navigateTo-OBJECT" class="headerlink" title="wx.navigateTo(OBJECT)"></a>wx.navigateTo(OBJECT)</h3><ul><li>可以传递参数</li><li>会存入页面路径栈(目前页面路径最多只能十层)</li><li>可以通过 navigateBack 返回</li><li>不能跳转到带 tabBar 页面</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.navigateTo</span>(&#123;</span><br><span class="line">  <span class="attribute">url</span>: <span class="string">'test?key=value&amp;key2=value2'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="wx-redirectTo-OBJECT"><a href="#wx-redirectTo-OBJECT" class="headerlink" title="wx.redirectTo(OBJECT)"></a>wx.redirectTo(OBJECT)</h3><ul><li>可以传递参数</li><li>不会存入页面路径栈</li><li>不能通过 navigateBack 返回</li><li>不能跳转到带 tabBar 页面</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.redirectTo</span>(&#123;</span><br><span class="line">  <span class="attribute">url</span>: <span class="string">'test?key=value&amp;key2=value2'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="wx-switchTab-OBJECT"><a href="#wx-switchTab-OBJECT" class="headerlink" title="wx.switchTab(OBJECT)"></a>wx.switchTab(OBJECT)</h3><ul><li>不可以传递参数</li><li>不会存入页面路径栈</li><li>不可以通过 navigateBack 返回</li><li>只跳转到带 tabBar 页面并关闭其他所有非 tabBar 页面</li></ul><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"tabBar"</span>: &#123;</span><br><span class="line">    <span class="string">"list"</span>: [&#123;</span><br><span class="line">      <span class="string">"pagePath"</span>: <span class="string">"index"</span>,</span><br><span class="line">      <span class="string">"text"</span>: <span class="string">"首页"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">"pagePath"</span>: <span class="string">"other"</span>,</span><br><span class="line">      <span class="string">"text"</span>: <span class="string">"其他"</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">wx.switchTab(&#123;</span><br><span class="line">  url: '/index'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>tabBar 最少要有二个菜单, 最多5个</p></blockquote><h3 id="wx-navigateBack-OBJECT"><a href="#wx-navigateBack-OBJECT" class="headerlink" title="wx.navigateBack(OBJECT)"></a>wx.navigateBack(OBJECT)</h3><ul><li>关闭当前页面，返回上一页面或多级页面。</li><li>可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。</li><li>不可以传递参数 </li><li>返回上一页面或多级页面</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.navigateBack</span>(&#123;</span><br><span class="line">  <span class="attribute">delta</span>: <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>delta 参数: 返回的页面数，如果 delta 大于现有页面数，则返回到首页。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;我们在写小程序的时候经常会遇到子页面向主
      
    
    </summary>
    
      <category term="wxmini" scheme="https://chongdee.github.io/categories/wxmini/"/>
    
    
      <category term="wxmini" scheme="https://chongdee.github.io/tags/wxmini/"/>
    
  </entry>
  
  <entry>
    <title>uniapp开发总结</title>
    <link href="https://chongdee.github.io/2021/07/21/wxmini/uniapp%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
    <id>https://chongdee.github.io/2021/07/21/wxmini/uniapp开发总结/</id>
    <published>2021-07-20T18:30:20.501Z</published>
    <updated>2021-07-20T16:18:22.468Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="我认为的坑？"><a href="#我认为的坑？" class="headerlink" title="我认为的坑？"></a>我认为的坑？</h2><p>其实我觉得自己的水平不能够去评价一款框架的好坏，只是简单的说一下开发体验，我认为坑大概分三种。</p><ol><li>该框架确实没有的功能，存在不能实现的东西。</li><li>明显的bug，导致程序出现问题，影响开发进度和结果</li><li>在开发过程中，自己凭借直觉和经验在开发，结果和预期不同，阅读文档过后才发现和之前经验积累的写法不一样，会不由自主的说一句真坑，或者说在不同端有的不同写法，但自己没有做好兼容，就出现了不同端效果不一致，当再次阅读文档找到问题后也会来一句真坑。</li></ol><p>总的来讲，这次Uni-app的开发之旅还是比较通畅的。</p><h2 id="踩坑之旅"><a href="#踩坑之旅" class="headerlink" title="踩坑之旅"></a>踩坑之旅</h2><h3 id="像素单位"><a href="#像素单位" class="headerlink" title="像素单位"></a>像素单位</h3><p>使用upx/rpx 而不是 px<br>修改内容（评论区大佬的订正）： 1px = 2upx是不准确的，upx和rpx是响应式单位，以750px为基准宽度，根据设备屏幕宽度自动调整</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>uni-app的路由全部配置在page.json这个文件中，问题就在于多人开发的时候，路由无法拆分，如果处理的不好，经常发生冲突。至于其中的一些配置项，就请见官方文档。<br>在页面中没有专门的  $route 和 $router对象 仅能在页面的生命周期里面接受路由传参，详情见文档。</p><blockquote><p><a href="https://uniapp.dcloud.io/frame?id=%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC" target="_blank" rel="noopener">uniapp.dcloud.io/frame?id=路由…</a></p></blockquote><p>路由传参方式</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">url</span> = <span class="string">`/pages/shopManagement/sonPage/billDetails?StoreID=<span class="subst">$&#123;StoreID&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>路由接参方式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLoad</span><span class="params">(route)</span></span>&#123;</span><br><span class="line">this<span class="selector-class">.getData</span><span class="selector-class">.StoreID</span>=route.StoreID</span><br><span class="line">this.getCurryInfo()</span><br><span class="line">&#125;,</span><br><span class="line">onLoad接收到一个参数对象</span><br></pre></td></tr></table></figure><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>如果你的项目仅是h5,那可以放心大胆的使用dom操作，但如果要在小程序和app跑，就不要做dom操作了，不生效。<br>不过ref还是可以用的，一样可以获取到这个节点，该干啥干啥。</p><p>生命周期<br>说到ref我就要提一下生命周期<br>具体的生命周期在文档中可以看详情</p><blockquote><p><a href="https://uniapp.dcloud.io/frame?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener">uniapp.dcloud.io/frame?id=应用…</a></p></blockquote><p>大致上和vue的差不多，分成页面生命周期和应用生命周期，页面生命周期就是针对单页面的，应用生命周期就是针对整个小程序/app的，不过我提出在开发时的一些情况</p><p>在组件中，没有生命周期，对，你没看错！比如页面a引用了组件b 在组件b中，onLoad，onShow，onReady全部失效，不过用created和mounted是生效的，但是我在开发的时候还是没有用created和mounted，毕竟文档明确写到</p><ul><li>建议使用uni-app 的 onReady 代替 vue 的 mounted</li><li>建议使用uni-app 的 onLoad 代替 vue 的 created</li></ul><p>所以我在组件中规避使用原vue的生命周期，另外，在上面说了ref，如果要在初始化使用ref要注意生命周期，在onload和show的钩子中，内部如果是同步操作是用不了的，拿不到$refs，我不知道怎么解释这个问题，在vue中很好解释，在created拿不到ref是因为dom还没有渲染出来，只有在mounted时dom渲染出来了才能拿到ref，但是uniapp中不是没得dom嘛。。。。。我也没深究过，如果要用，只能异步，可以加setTimeout 或者 放在某个请求后用，这个时候是可以拿到ref的</p><p>其实在非页面组件里面使用vue自带的生命周期是可行的，之前我没有尝试过，所以一直规避了这种用法，把很多东西都放在页面的生命周期里面搞。</p><h3 id="关于请求"><a href="#关于请求" class="headerlink" title="关于请求"></a>关于请求</h3><p>我们最开始的时候是自己简单的封装了一下发送的请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> HttpRequest_ =  &#123;</span><br><span class="line">config: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> info = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line"><span class="keyword">var</span> name2 = name.split(<span class="string">"."</span>); <span class="comment">//字符分割</span></span><br><span class="line"><span class="keyword">if</span> (name2.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">info = configdata[name2[<span class="number">0</span>]][name2[<span class="number">1</span>]] || <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">info = configdata[name] || <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> web_config = cache.get(<span class="string">"web_config"</span>);</span><br><span class="line"><span class="keyword">if</span> (web_config) &#123;</span><br><span class="line"><span class="keyword">if</span> (name2.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">info = web_config[name2[<span class="number">0</span>]][name2[<span class="number">1</span>]] || <span class="literal">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">info = web_config[name] || <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> info;</span><br><span class="line">&#125;,</span><br><span class="line">post: <span class="function"><span class="keyword">function</span>(<span class="params">url, data, header</span>) </span>&#123;</span><br><span class="line">header = header || <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line"><span class="comment">//url = this.config("APIHOST")+url;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">succ, error</span>) =&gt;</span> &#123;</span><br><span class="line">showLoading_()</span><br><span class="line">uni.request(&#123;</span><br><span class="line">url: url,</span><br><span class="line">data: data,</span><br><span class="line">method: <span class="string">"POST"</span>,</span><br><span class="line">header: &#123;</span><br><span class="line"><span class="string">"content-type"</span>: header</span><br><span class="line">&#125;,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">hidLoading_()</span><br><span class="line">succ.call(self, result.data)</span><br><span class="line">&#125;,</span><br><span class="line">fail: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">hidLoading_()</span><br><span class="line">error.call(self, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'err：'</span>,err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params">url, data, header</span>) </span>&#123;</span><br><span class="line">header = header || <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line"><span class="comment">//url = this.config("APIHOST")+url;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">succ, error</span>) =&gt;</span> &#123;</span><br><span class="line">showLoading_()<span class="comment">// 加载中</span></span><br><span class="line">uni.request(&#123;</span><br><span class="line">url: url,</span><br><span class="line">data: data,</span><br><span class="line">method: <span class="string">"GET"</span>,</span><br><span class="line">header: &#123;</span><br><span class="line"><span class="string">"content-type"</span>: header</span><br><span class="line">&#125;,</span><br><span class="line">success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">hidLoading_() <span class="comment">//关闭加载中</span></span><br><span class="line">succ.call(self, result.data)</span><br><span class="line">&#125;,</span><br><span class="line">fail: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">hidLoading_() <span class="comment">//关闭加载中</span></span><br><span class="line">error.call(self, e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">uni.showToast(&#123;</span><br><span class="line">duration:<span class="number">2000</span>,</span><br><span class="line">title:<span class="string">'数据异常，请稍后再试'</span>,</span><br><span class="line">icon:<span class="string">'none'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'err：'</span>,err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我以为在Uniapp中发送请求只能用他们请求方法，后来同事说也可以用其他的。<br>我们便引入其他的库。这是uniapp插件市场别人封装好的，用起来还是比较舒服</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=561" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=5…</a></p></blockquote><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><p>导航栏注意的一个问题就是不同端的不同展示形式，所以需要处理兼容问题。</p><p>导航栏，可以用自定义的，可以用框架提供的，也有一些插件，都还是可以用的，就是注意显示的区别，如果有多端需求，一定要在不同端跑一下看看效果，不然到时候会很烦。我们一直用的colorUi的导航栏，自己稍微改动了一下</p><p>在支付宝小程序中，原生的导航栏是取消不了，所以不能用自定义的插件，就需要在page.json中配置原生的导航栏</p><p>随便找了一个页面，我们的头部导航是条件编译的:</p><h3 id="动态的class-style"><a href="#动态的class-style" class="headerlink" title="动态的class style"></a>动态的class style</h3><p>具体的文档在这里：</p><p><a href="https://uniapp.dcloud.io/use" target="_blank" rel="noopener">uniapp.dcloud.io/use</a></p><p>我一开始是没有注意到这一点，按照我的一些常规习惯写并且一直在用h5调试，没有任何问题，后来上真机和小程序开发工具之后才发现全部失效。</p><h3 id="打开第三方的网址或app"><a href="#打开第三方的网址或app" class="headerlink" title="打开第三方的网址或app"></a>打开第三方的网址或app</h3><p>在app端想要打开第三方的网址或者程序，一定要区分ios和安卓端。<br>首先，ios和安卓唤起第三方app的地址是不一样的。</p><p>不管是在调试还是打包，要唤起第三方程序，在ios端要配置白名单</p><h3 id="三方登录"><a href="#三方登录" class="headerlink" title="三方登录"></a>三方登录</h3><p>以微信登录位例：</p><p>在app端，uni-app集成的几个方法，可以很顺利的拿到unionId，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">openid等一些列信息</span><br><span class="line">    uni.getProvider(&#123;<span class="comment">//获取uniapp支持的第三方数据</span></span><br><span class="line">      service:<span class="string">'oauth'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> [err,res] = data</span><br><span class="line">      <span class="keyword">var</span> providers=res.provider<span class="comment">//类型（微信，新浪，小米，qq）</span></span><br><span class="line">      <span class="keyword">var</span> flagIndex=providers.indexOf(provider)</span><br><span class="line">      <span class="keyword">if</span>(flagIndex&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> providers[flagIndex] /</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> uni.login(&#123;<span class="comment">//登陆接口（可以获取用户信息）</span></span><br><span class="line">        provider:res,</span><br><span class="line">        scopes:<span class="string">'auth_base'</span>,</span><br><span class="line">        timeout:<span class="number">20000</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;<span class="comment">//返回一系列登陆信息</span></span><br><span class="line">        <span class="keyword">var</span> [err,res] = data</span><br><span class="line">        <span class="keyword">if</span>(res.errMsg===<span class="string">"login:ok"</span>)&#123;</span><br><span class="line">          self.authResult=res.authResult</span><br><span class="line">          <span class="keyword">return</span> res.authResult</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="comment">//获取用户的信息 头像，地址，等等等</span></span><br><span class="line">      <span class="keyword">return</span> uni.getUserInfo(&#123;</span><br><span class="line">        provider:provider,</span><br><span class="line">        timeout:<span class="number">20000</span>,</span><br><span class="line">        withCredentials:<span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;<span class="comment">//得到一些列用户信息</span></span><br><span class="line">      <span class="keyword">var</span> [err,res] = data </span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">if</span>(res.errMsg===<span class="string">"getUserInfo:ok"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>但是如果在小程序端，很多方法就失效了，因为小程序有一套自己的三方登录交互策略。</p><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html" target="_blank" rel="noopener">developers.weixin.qq.com/miniprogram…</a></p></blockquote><p>还记得当时刚在app上测成功微信三方登陆后，领导过来看进度，问小程序怎么样，我给他放了个体验版，让他看看，他问我这个微信登录也可以吗？我拍拍胸脯说没得问题，随便登，结果。。。。。。。。。。。。。。。脸疼</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">uni.login(&#123;<span class="comment">//登陆接口</span></span><br><span class="line">      provider:<span class="string">'weixin'</span>,</span><br><span class="line">      scopes:<span class="string">'auth_base'</span>,</span><br><span class="line">      timeout:<span class="number">20000</span>,</span><br><span class="line">    &#125;).then(data=&gt;&#123;<span class="comment">//返回一系列登陆信息</span></span><br><span class="line">        let [err,res] = data</span><br><span class="line">        <span class="keyword">if</span>(res.code)&#123;</span><br><span class="line">          let data =&#123;<span class="comment">//这个code很重要，需要拿到code向后台去换unionid等</span></span><br><span class="line">            js_code: res.code</span><br><span class="line">          &#125;</span><br><span class="line">      return this.<span class="variable">$Request</span>.get(this.<span class="variable">$store</span><span class="selector-class">.state</span><span class="selector-class">.getopenidUrl</span>,data)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      setTimeout(()=&gt;&#123;</span><br><span class="line">        this.<span class="variable">$api</span>.msg(<span class="string">'数据异常'</span>)</span><br><span class="line">      &#125;,<span class="number">500</span>)</span><br><span class="line">      uni.switchTab(&#123;</span><br><span class="line">        url:<span class="string">'/pages/index/index'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).then(res=&gt;&#123;</span><br><span class="line">        let res_ = JSON.parse(res.Data)</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'unionid'</span> <span class="keyword">in</span> res_)&#123;</span><br><span class="line">          this<span class="selector-class">.getIsBindData</span><span class="selector-class">.openid</span>=res_.unionid</span><br><span class="line">          this<span class="selector-class">.getDataWX</span><span class="selector-class">.openid</span> = res_.unionid</span><br><span class="line">          this<span class="selector-class">.getDataWX</span><span class="selector-class">.unionid</span> = res_.openid</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          this<span class="selector-class">.getIsBindData</span><span class="selector-class">.openid</span>=res_.openid</span><br><span class="line">          this<span class="selector-class">.getDataWX</span><span class="selector-class">.openid</span> = res_.openid</span><br><span class="line">          this<span class="selector-class">.getDataWX</span><span class="selector-class">.unionid</span> = res_.openid</span><br><span class="line">        &#125;</span><br><span class="line">        return this.WXuserInfo</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>其他的三方登录我没有试过，但是一定要注意各端之间的差异性</p><p>另外，支付宝三方登录uni-app没有集成，要是自己想做，就用原生来写，理论上是可以做的。由于我们团队没有会原生的，我们试过用webview做支付宝的三方登录，最后还是卡在了授权这一块，不得而终，遂阉了该需求。</p><p>在插件市场已经有了安卓端和ios端授权登录的插件（是付费插件）详情：</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=654" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=6…</a></p></blockquote><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>写成组件在小程序上失效，仅能在index页面上使用。在h5生效，封装成组件也可以，渲染效果也不是太好，app端没有试过，因为后来看效果不好就暂时搁置这个需求了。<br>评论区朋友的订正：</p><p>canvas在组件中使用时，记得传递第二个参数组件实例对象：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uni.createCanvasContext(canvasId, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure></p><p>我试过了，封装成组件的情况下，传入this，在小程序是生效的.之前是没有传入的</p><h3 id="注意权限模块与sdk的配置"><a href="#注意权限模块与sdk的配置" class="headerlink" title="注意权限模块与sdk的配置"></a>注意权限模块与sdk的配置</h3><p>我之前从未写过app和小程序，对一些东西不够敏感</p><p>在我调试地图，导航等功能的时候用的很顺畅，后来打包就失效了，就是因为没配好，原来在我们调试的时候用的是Uniapp的。</p><p>另外需要用到一些权限的时候记得也要去manifest.json中去配置，总的来讲，图形化界面配置还是比较友好，源码配置也没有那么复杂，基本上都能查到</p><p>个人建议只要是真机调试就用自定义基座，尽量不要用uniapp给的基座，这样可以避免一些干扰，在标准基座没问题，一打包就出问题，用自定义基座会好一些。</p><h3 id="nvue"><a href="#nvue" class="headerlink" title="nvue"></a>nvue</h3><p>weex魔幻的东西太多了，我就不一一列举了</p><p>比如weex中自带flex布局，但是排布顺序是竖着的，你说这个是不是头疼。</p><p>我用原生插件拼样式的时候真滴是痛苦，好几处觉得分分钟能解决的东西，半天搞不定，我当时还在想不会是记忆出错了？不是这么用的，还查了半天，结果依旧不生效，突然反应过来，别在weex里面就不是这么用，一看文档，果然如此！</p><p>个人建议先把weex的文档通读一下，或者用某个东西之前先去查查看怎么用。别一根筋去根据自己脑海里的css知识来对抗另一套标准的css，这样永远都对不准。</p><blockquote><p><a href="https://weex.apache.org/zh/docs/styles/common-styles.html#%E7%9B%92%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">weex.apache.org/zh/docs/sty…</a></p></blockquote><h3 id="开屏引导"><a href="#开屏引导" class="headerlink" title="开屏引导"></a>开屏引导</h3><p>uni-app没得开屏这个配置项，只能用一些策略来做。</p><blockquote><p><a href="https://note.youdao.com/" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=1…</a></p></blockquote><p>实质上是是用swiper组件+本地缓存做的模拟开屏引导，注意的是，如果产品一开始就定位了要做引导页，那就考虑好index的怎么写，我们是后期才打算加的，如果要把index改掉成本有点大，所以用了另一种策略，但如果在性能不好的手机上会出现尴尬的事情，就不细说怎么尴尬了，如果用上面的策略，再尴尬也不过是白屏，在上面的demo中，index仅是一个中转页面，什么都没有写。所以个人建议还是用以上的策略。</p><h3 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h3><p>至今我没有我没有找到如何配置路径别名的文件或者方法。</p><p>在uniapp中 @ 是表示根路径，不过整个文件结构还是很清晰的，没有那么多的配置文件，整个根文件很像常规的src目录，用@基本上也很舒服。</p><h3 id="插件市场和生态"><a href="#插件市场和生态" class="headerlink" title="插件市场和生态"></a>插件市场和生态</h3><p>总的来讲，Uniapp的插件市场还是不错的，大多数能用到的插件都可以找到，找不到的也可以从个别相似的插件中找到灵感，自己再魔改一下，论坛也还行，基本上自己遇到的问题都能找到答案，但是也有找不到的或者有人提出却无人回答的,官方qq群也还是比较热闹，有些东西自己没遇见的看看别人的问题和解决方案也算是一种成长，自己遇见过的给别人解答，换来一声谢谢也是很开心的。</p><h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>文档：</p><blockquote><p><a href="https://uniapp.dcloud.io/api/media/image?id=compressimage" target="_blank" rel="noopener">uniapp.dcloud.io/api/media/i…</a></p></blockquote><p>我不知道为什么 uni.compressImage(OBJECT) 这个接口在app端失效微信小程序生效，报错信息也很简单，就是说压缩失败，没有其他的提示，我在官方群问了一圈没人给我回答，看了下社区也没有太有价值的回答。</p><p>后来自己慢慢琢磨了一下，也参考了这位老哥的文章(文章中也包含了转换base64的方法)，简单的封装了个函数。</p><p>参考文章：</p><blockquote><p><a href="https://github.com/SilurianYang/uni-app-tools/blob/master/uni-app-customImg/custom-picture.js" target="_blank" rel="noopener">github.com/SilurianYan…</a></p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">src:图片的本地路径</span></span><br><span class="line"><span class="comment">quality：压缩范围 0-100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">zipImage</span>(<span class="params">src,quality=30</span>)</span>&#123;</span><br><span class="line"><span class="comment">// #ifdef APP-PLUS app</span></span><br><span class="line"><span class="keyword">let</span> index = src.lastIndexOf(<span class="string">"."</span>)</span><br><span class="line"><span class="keyword">let</span> imgDirname = src.substring(<span class="number">0</span>,index)<span class="comment">//图片的原始地址</span></span><br><span class="line"><span class="keyword">let</span> imgName = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();<span class="comment">//压缩后的文件</span></span><br><span class="line"><span class="keyword">let</span> imgType  = src.substring(index+<span class="number">1</span>,src.length);<span class="comment">//图片的类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,rej</span>)=&gt;</span>&#123;</span><br><span class="line">plus.zip.compressImage(&#123;</span><br><span class="line">src,</span><br><span class="line">dst: imgDirname+imgName+<span class="string">'.'</span>+imgType,</span><br><span class="line">quality,</span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">resolve(res.target)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">rej(err)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"><span class="comment">// #ifdef MP-WEIXIN   微信小程序</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,rej</span>)=&gt;</span>&#123;</span><br><span class="line">uni.compressImage(&#123;</span><br><span class="line">  src,</span><br><span class="line">  success:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> path = res.tempFilePath</span><br><span class="line">resolve(path)</span><br><span class="line"><span class="comment">// this.imgList.push(path)</span></span><br><span class="line">  <span class="comment">// this.imgList.push</span></span><br><span class="line">  &#125;,</span><br><span class="line">  fail:<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">uni.showToast(&#123;</span><br><span class="line">title:<span class="string">'上传失败，请重新上传'</span>,</span><br><span class="line">duration:<span class="number">2000</span></span><br><span class="line">&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  complete:<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val,<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候，直接会吐出来压缩后的图片路径</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">uni</span><span class="selector-class">.chooseImage</span>(&#123;</span><br><span class="line"><span class="attribute">success</span>:(res)=&gt;&#123;</span><br><span class="line">    res.tempFiles.<span class="built_in">forEach</span>(async (it)=&gt;&#123;</span><br><span class="line">let localPath =it.path</span><br><span class="line">localPath = await this.$api.<span class="built_in">zipImage</span>(localPath) //await一下就可以接住了</span><br><span class="line">this.imageList.<span class="built_in">push</span>(&#123;</span><br><span class="line">value:localPath</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最近又写了两个uniapp的项目 基本上没踩什么坑<br>倒是加入了几个新功能，在这里稍微总结一下<br>第一个是app推送 第二个是语音播报 第三个是直播</p><h3 id="app推送"><a href="#app推送" class="headerlink" title="app推送"></a>app推送</h3><blockquote><p><a href="https://ask.dcloud.net.cn/article/35622" target="_blank" rel="noopener">ask.dcloud.net.cn/article/356…</a></p></blockquote><p>这是官方的说明 按照配置配置结束以后 就可以开始测试了，但是测试之前需要拿到一个cid 拿cid的函数就是这个</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const clientInfo = plus.push.getClientInfo()</span><br><span class="line">    let pushInfo = &#123;</span><br><span class="line"><span class="symbol">clientid:</span> clientInfo.clientid,</span><br><span class="line"><span class="symbol">appid:</span> clientInfo.appid,</span><br><span class="line"><span class="symbol">appkey:</span> clientInfo.appkey   </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//这端代码可以拿到需要的一些信息，包括cid</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到cid就可以开始发送测试的推送了</span></span><br></pre></td></tr></table></figure><p>至于透传和通知栏信息的区别是什么，在百度或者谷歌一搜会有</p><p>很多讲的详细的文章，比我这个前端菜鸡说的仔细的多，所以我就不多加赘述了。</p><p>在收到推送之前，也可以检测一下用户是否看起了推送权限，直接上代码吧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pushPower</span>(<span class="params">phoneType</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(phoneType===<span class="string">'android'</span>)&#123;<span class="comment">//如果是安卓</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'安卓'</span>)</span><br><span class="line"><span class="keyword">let</span> main = plus.android.runtimeMainActivity();</span><br><span class="line"><span class="keyword">let</span> pkName = main.getPackageName();  </span><br><span class="line"><span class="keyword">let</span> NotificationManagerCompat plus.android.importClass(<span class="string">"android.support.v4.app.NotificationManagerCompat"</span>);  </span><br><span class="line"><span class="keyword">let</span> packageNames = NotificationManagerCompat.from(main);  </span><br><span class="line"><span class="comment">// console.log(JSON.stringify(packageNames));  </span></span><br><span class="line"><span class="keyword">if</span> (packageNames.areNotificationsEnabled()) &#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'已开启通知权限'</span>);  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">    <span class="comment">/*这段函数是自己封装的弹框询问*/</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.$api.showModal(&#123;</span><br><span class="line">title: <span class="string">'是否开启推送权限'</span>,</span><br><span class="line">content: <span class="string">'您还未开启推送权限，是否开启？不开启推送权限部分功能将不完善。'</span></span><br><span class="line">&#125;)</span><br><span class="line"> <span class="comment">/*这段函数是自己封装的弹框询问*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(res)&#123;</span><br><span class="line"><span class="keyword">let</span> Intent = plus.android.importClass(<span class="string">'android.content.Intent'</span>);</span><br><span class="line"><span class="keyword">let</span> intent = neIntent(<span class="string">'android.settings.APP_NOTIFICATION_SETTINGS'</span>);<span class="comment">//可设置表中所有Action字段  </span></span><br><span class="line">intent.putExtra(<span class="string">'android.provider.extra.APP_PACKAGE'</span>, pkName);  </span><br><span class="line">main.startActivity(intent);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(phoneType===<span class="string">'ios'</span>)&#123;<span class="comment">//如果是ios</span></span><br><span class="line"><span class="keyword">let</span> UIApplication = plus.ios.import(<span class="string">"UIApplication"</span>);  </span><br><span class="line"><span class="keyword">let</span> app = UIApplication.sharedApplication();  </span><br><span class="line"><span class="keyword">let</span> enabledTypes  = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">if</span> (app.currentUserNotificationSettings) &#123;  </span><br><span class="line">  <span class="keyword">let</span> settings = app.currentUserNotificationSettings();  </span><br><span class="line">  enabledTypes = settings.plusGetAttribute(<span class="string">"types"</span>);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">  <span class="comment">//针对低版本ios系统  </span></span><br><span class="line">  enabledTypes = app.enabledRemoteNotificationTypes();  </span><br><span class="line">&#125;  </span><br><span class="line">plus.ios.deleteObject(app);  </span><br><span class="line"><span class="keyword">if</span> ( <span class="number">0</span> == enabledTypes ) &#123;  </span><br><span class="line">     <span class="comment">/*这段函数是自己封装的弹框询问*/</span></span><br><span class="line"><span class="keyword">let</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.$api.showModal(&#123;</span><br><span class="line">title: <span class="string">'是否开启推送权限'</span>,</span><br><span class="line">content: <span class="string">'您还未开启推送权限，是否开启？不开启推送权限部分功能将不完善。'</span></span><br><span class="line">&#125;)</span><br><span class="line"> <span class="comment">/*这段函数是自己封装的弹框询问*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(res)&#123;</span><br><span class="line"><span class="keyword">let</span> UIApplication = plus.ios.import(<span class="string">"UIApplication"</span>);</span><br><span class="line"><span class="keyword">let</span> NSURL = plus.ios.import(<span class="string">"NSURL"</span>);  </span><br><span class="line"><span class="keyword">let</span> setting = NSURL.URLWithString(<span class="string">"app-settings:"</span>);  </span><br><span class="line"><span class="keyword">let</span> application = UIApplication.sharedApplication();  </span><br><span class="line">application.openURL(setting);  </span><br><span class="line">plus.ios.deleteObject(setting);  </span><br><span class="line">plus.ios.deleteObject(application);  </span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反正做不做权限检查也看各位的需求<br>最后一步就是监听推送信息了，在这里我就不放我的代码了，给大家提供一个文章，这个文章里面详细的撰写了怎么去监听推送等。</p><blockquote><p><a href="https://ask.dcloud.net.cn/article/35622" target="_blank" rel="noopener">ask.dcloud.net.cn/article/366…</a><br>前端这块只需要看他的【8】 里面 对接收不同信息做了详细代码演示。</p></blockquote><p>具体发透传信息还是通知栏信息，接到后怎么处理等，就看各位和后端怎么协商了。</p><h3 id="语音播报"><a href="#语音播报" class="headerlink" title="语音播报"></a>语音播报</h3><p>这个就很简单了。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=182" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=1…</a></p></blockquote><p>就用这个插件，该配置的一配置 对着文档写一下 啥都出来了</p><h3 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h3><p>直播的话 我觉得大概分成两个方面<br>第一就是自己的后端自己的搭建推送服务器</p><p>1，app的推送：</p><p>可以看这位掘金朋友的文章，我当时是请教他了，给我讲了很,但是最后我们没有做自己的直播服务器用的第三方的方案</p><blockquote><p><a href="https://juejin.cn/post/6844904056234704910" target="_blank" rel="noopener">juejin.im/post/684490…</a></p></blockquote><p>2,小程序的直播：</p><p>我只是看了下文档，后面没有做，他的拉流组件与app用的不是同一个</p><blockquote><p><a href="https://uniapp.dcloud.io/component/live-player?id=live-player" target="_blank" rel="noopener"> uniapp.dcloud.io/component/l…</a></p></blockquote><p><strong>第二是用现成的直播插件与服务，主要是腾讯云</strong></p><p>1，app的直播方案:<br>我们是花钱买的原生插件，这位作者售后很好，有问必答，而且也是永久维护。</p><p>第一款上手比较快，但不算是真正意义的直播，是实时音视，不能做到录屏等功能。但是单纯的播放画面和接收声音是完全没有问题的，连麦，美颜，闭麦静音等都可以。具体的逻辑可以根据自己的业务来做，我们的业务主要是讲课软件，不仅要直播，也需要连麦的功能，这个就很符合我们的需求。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=824" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=8…</a></p></blockquote><p>第二个款组件我没有用过，但是也放出来大家可以参考一下。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=1008" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=1…</a></p></blockquote><p>2，小程序的直播<br>目前我们没打算在小程序做直播，因为资格不够，但是我在看直播插件的时候，看了个很好的例子，放出来大家也可以看看做做参考。</p><p>ext.dcloud.net.cn/plugin?id=1…</p><p>他是把腾讯视频云小程序的功能做成了uniapp版本的，大家可以参考着来做。</p><blockquote><p>说一点感受，就是uniapp对针对三方SDK的集成支持度不是很好，或者说第三方的sdk针对uniapp的sdk集成不是很好？</p></blockquote><h3 id="App权限"><a href="#App权限" class="headerlink" title="App权限"></a>App权限</h3><p>昨日在打包的时候，发现我的摄像头权限从来没有被询问过是否使用，直接就给我反应说未授权，我琢磨是哪里没配置，我才去配置项里面找到并配置了，但是这些配置项很多也不太熟悉，索性在论坛里面搜索了很多相关的文章看了看。就发现一个好东西，是关于权限的判断和提示的。</p><p>上面推送的内容中，我写到了app推送权限的判断。我觉得还不如人家这个写得好，所以干脆我都改成了这个。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=594" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=5…</a></p></blockquote><p>这里面不仅把权限名称都放出来了，就算自己配置打包，也可以拿来做参考，并且也封装成了模块，调用查询用户的功能权限非常的方便！</p><h3 id="插件市场里面我看过or用过比较好的组件"><a href="#插件市场里面我看过or用过比较好的组件" class="headerlink" title="插件市场里面我看过or用过比较好的组件"></a>插件市场里面我看过or用过比较好的组件</h3><p>先后推荐不分排名顺序</p><p>colorUI  我们四个项目，都是以colorUI做的基础样式，他不是一个组件库，是个css样式库，唯一的缺点就是没有太详细的文档，不过源码都在，过一遍基本上也都熟悉了。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=239" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=2…</a></p></blockquote><p>===================================<br>uCharts 高性能跨全端图表,基本上所有类型的图表都包含了，而且文档也比较清楚，demo也全面 源码也可以根据自己的需求做改动，我自己在开发的时候也改动过源码，用起来很顺手。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=239" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=2…</a></p></blockquote><p>===================================<br>手写签名组件，方便易操作。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=331" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=3…</a></p></blockquote><p>===================================<br>答题模版，这个答题模板是基于colorUI做的，我当时自己懒得写了，就直接搬来用。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=451" target="_blank" rel="noopener"> ext.dcloud.net.cn/plugin?id=4…</a></p></blockquote><p>===================================<br>ThorUI组件库 这个库是个正儿八经的组件库，里面包含了常规的各种组件，我们也买了graceUI，其实对比一下，大体上不相上下的，有不同的需求也可以直接改源码啥的。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=556" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=5…</a></p></blockquote><p>===================================<br>侧边导航 不过侧边导航也实现起来也比较简单，这个是我看到的一个组件，看了下源码，如果是拿来练手实现的话，是个比较好的参照对象。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=72" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=7…</a></p></blockquote><p>===================================<br>O2O本地生活模版 这个模板用来快速开发电商项目很好，作者组件封装的很完善，有需求的只要自己改一下就可以用了。</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=1022" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=1…</a></p></blockquote><p>===================================<br>mescroll的uni版本, 是在 uni-app 运行的下拉刷新和上拉加载的组件 第一个项目用到了他 不过后来我自己封装了一个就没用了。</p><blockquote><p><a href="http://www.mescroll.com/uni.html" target="_blank" rel="noopener">www.mescroll.com/uni.html</a></p></blockquote><p>===================================<br>基于flyio接口封装</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=561" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=5…</a></p></blockquote><p>===================================<br>腾讯云小程序音视频通讯Uniapp版</p><blockquote><p><a href="https://ext.dcloud.net.cn/plugin?id=1286" target="_blank" rel="noopener">ext.dcloud.net.cn/plugin?id=1…</a></p></blockquote><h2 id="最后还是一句话"><a href="#最后还是一句话" class="headerlink" title="最后还是一句话"></a>最后还是一句话</h2><p>注意各端的差异性，很多东西，h5对着的，上真机就错了,真机好着的，换小程序就错了，不同小程序之间还有差异，总之就是考虑好不同的情况，重点是仔细阅读文档。</p><p>虽然可能一些原生可以实现的功能uniapp实现不了，不过整体开发下来还是比较愉快，很多的坑还是因为多端不兼容，除了写起来麻烦一点，基本上都还是有可以解决的策略。</p><p>也希望uniapp越做越好，各方面越来越完善，为我这种搬砖码农增加一份生存的筹码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;我认为的坑？&quot;&gt;&lt;a href=&quot;#我认为的坑？&quot; class=&quot;headerlink&quot; title=&quot;我认为的坑？&quot;&gt;&lt;/a&gt;我认为的坑？&lt;/h2&gt;&lt;p&gt;其实我觉
      
    
    </summary>
    
      <category term="wxmini" scheme="https://chongdee.github.io/categories/wxmini/"/>
    
    
      <category term="wxmini" scheme="https://chongdee.github.io/tags/wxmini/"/>
    
  </entry>
  
  <entry>
    <title>react开发34个技巧</title>
    <link href="https://chongdee.github.io/2021/07/21/react/react%E5%BC%80%E5%8F%9134%E4%B8%AA%E6%8A%80%E5%B7%A7/"/>
    <id>https://chongdee.github.io/2021/07/21/react/react开发34个技巧/</id>
    <published>2021-07-20T18:29:28.232Z</published>
    <updated>2021-07-20T17:37:46.303Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="1-组件通讯"><a href="#1-组件通讯" class="headerlink" title="1 组件通讯"></a>1 组件通讯</h2><h3 id="1-1-props"><a href="#1-1-props" class="headerlink" title="1.1 props"></a>1.1 props</h3><p>子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">"antd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">EightteenChildOne</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123; <span class="comment">//propTypes校验传入类型,详情在技巧11</span></span><br><span class="line">    name: PropTypes.string</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过触发方法子传父</span></span><br><span class="line">    <span class="keyword">this</span>.props.eightteenChildOneToFather(<span class="string">"这是 props 改变父元素的值"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;这是通过 props 传入的值&#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button type="primary" onClick=&#123;this.click&#125;&gt;</span></span><br><span class="line"><span class="regexp">          点击改变父元素值</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;EightteenChildOne name=&#123;<span class="string">'props 传入的 name 值'</span>&#125; eightteenChildOneToFather=&#123;(mode)=&gt;<span class="keyword">this</span>.eightteenChildOneToFather(mode)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">EightteenChildOne</span>&gt;</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">&lt;EightteenChildOne name=&#123;<span class="string">'props 传入的 name 值'</span>&#125; eightteenChildOneToFather=&#123;<span class="keyword">this</span>.eightteenChildOneToFather.bind(<span class="keyword">this</span>)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">EightteenChildOne</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>props 传多个值时:<br>传统写法</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123;dataOne,dataTwo,dataThree&#125; = this.<span class="keyword">state</span></span><br><span class="line"><span class="variable">&lt;Com dataOne=&#123;dataOne&#125; dataTwo=&#123;dataTwo&#125; dataThree=&#123;dataThree&#125;&gt;</span></span><br></pre></td></tr></table></figure><p>升级写法</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Com</span> </span></span><span class="template-variable">&#123;...&#123;dataOne,dataTwo,dataThree&#125;</span><span class="xml"><span class="tag">&#125;&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-2-props-升级版"><a href="#1-2-props-升级版" class="headerlink" title="1.2 props 升级版"></a>1.2 props 升级版</h3><p>原理:子组件里面利用 props 获取父组件方法直接调用,从而改变父组件的值</p><p>注意: 此方法和 props 大同小异,都是 props 的应用,所以在源码中没有举例</p><p>调用父组件方法改变该值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">state = &#123;</span><br><span class="line">  count: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">changeParentState = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">onClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.changeParentState(&#123; <span class="attr">count</span>: <span class="number">2</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-Provider-Consumer和Context"><a href="#1-3-Provider-Consumer和Context" class="headerlink" title="1.3 Provider,Consumer和Context"></a>1.3 Provider,Consumer和Context</h3><p>1.Context在 16.x 之前是定义一个全局的对象,类似 vue 的 eventBus,如果组件要使用到该值直接通过this.context获取</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;color: <span class="string">"purple"</span>,text: <span class="string">"item text"</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;messages&#125; = <span class="keyword">this</span>.props || &#123;&#125;</span><br><span class="line">    const children = messages &amp;&amp; messages.map((message) =&gt;</span><br><span class="line">      &lt;<span class="type">Message</span> text=&#123;message.text&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;children&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MessageList</span>.childContextTypes = &#123;</span><br><span class="line">  color: <span class="type">React</span>.<span class="type">PropTypes</span>.string</span><br><span class="line">  text: <span class="type">React</span>.<span class="type">PropTypes</span>.string</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;<span class="type">MessageItem</span> /&gt;</span><br><span class="line">        &lt;<span class="type">Button</span>&gt;<span class="type">Delete</span>&lt;/<span class="type">Button</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//孙组件(接收组件)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.context.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MessageItem</span>.contextTypes = &#123;</span><br><span class="line">  text: <span class="type">React</span>.<span class="type">PropTypes</span>.string <span class="comment">//React.PropTypes在 15.5 版本被废弃,看项目实际的 React 版本</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button style=&#123;&#123;background: <span class="keyword">this</span>.context.color&#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span>.contextTypes = &#123;</span><br><span class="line">  color: <span class="type">React</span>.<span class="type">PropTypes</span>.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.16.x 之后的Context使用了Provider和Customer模式,在顶层的Provider中传入value，在子孙级的Consumer中获取该值，并且能够传递函数，用来修改context<br>声明一个全局的 context 定义,context.js</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">let</span> &#123; Consumer, Provider &#125; = React.createContext();<span class="comment">//创建 context 并暴露Consumer和Provider模式</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    Consumer,</span><br><span class="line">    Provider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件导入</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">// 导入 Provider</span></span><br><span class="line"><span class="xml">import </span><span class="template-variable">&#123;Provider&#125;</span><span class="xml"> from "../../utils/context"</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=</span></span><span class="template-variable">&#123;name&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=</span></span><span class="template-variable">&#123;&#123;border:'1px solid red',width:'30%',margin:'50px auto',textAlign:'center'&#125;</span><span class="xml"><span class="tag">&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件定义的值:</span><span class="template-variable">&#123;name&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">EightteenChildTwo</span>&gt;</span><span class="tag">&lt;/<span class="name">EightteenChildTwo</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入Consumer</span></span><br><span class="line">import &#123; Consumer &#125; from <span class="string">"../../utils/context"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">//Consumer容器,可以拿到上文传递下来的name属性,并可以展示对应的值</span></span><br><span class="line">    &lt;Consumer&gt;</span><br><span class="line">      &#123;name =&gt; (</span><br><span class="line">        &lt;div</span><br><span class="line">          style=&#123;&#123;</span><br><span class="line">            border: <span class="string">"1px solid blue"</span>,</span><br><span class="line">            width: <span class="string">"60%"</span>,</span><br><span class="line">            margin: <span class="string">"20px auto"</span>,</span><br><span class="line">            textAlign: <span class="string">"center"</span></span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">        <span class="comment">// 在 Consumer 中可以直接通过 name 获取父组件的值</span></span><br><span class="line">          &lt;p&gt;子组件。获取父组件的值:&#123;name&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export <span class="keyword">default</span> Son;</span><br></pre></td></tr></table></figure><h3 id="1-4-EventEmitter"><a href="#1-4-EventEmitter" class="headerlink" title="1.4 EventEmitter"></a>1.4 EventEmitter</h3><p><a href="https://segmentfault.com/a/1190000012361461?utm_source=tag-newest#articleHeader6" target="_blank" rel="noopener">EventEmiter </a>传送门<br>使用 events 插件定义一个全局的事件机制</p><h3 id="1-5-路由传参"><a href="#1-5-路由传参" class="headerlink" title="1.5 路由传参"></a>1.5 路由传参</h3><p>1.params</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/path/:name'</span> component=&#123;Path&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;link to=<span class="string">"/path/2"</span>&gt;xxx&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">this.props.history.push(&#123;pathname:"/</span>path/<span class="string">" + name&#125;);</span></span><br><span class="line"><span class="string">读取参数用:this.props.match.params.name</span></span><br></pre></td></tr></table></figure><p>2.query</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/query'</span> component=&#123;Query&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Link to=&#123;&#123; <span class="string">pathname :</span> <span class="string">'/query'</span> , <span class="string">query :</span> &#123; <span class="string">name :</span> <span class="string">'sunny'</span> &#125;&#125;&#125;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.props.history.push(&#123;<span class="string">pathname:</span><span class="string">"/query"</span>,<span class="string">query:</span> &#123; <span class="string">name :</span> <span class="string">'sunny'</span> &#125;&#125;);</span><br><span class="line">读取参数用: <span class="keyword">this</span>.props.location.query.name</span><br></pre></td></tr></table></figure><p>3.state</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/sort '</span> component=&#123;Sort&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;Link to=&#123;&#123; <span class="string">pathname :</span> <span class="string">'/sort '</span> , <span class="string">state :</span> &#123; <span class="string">name :</span> <span class="string">'sunny'</span> &#125;&#125;&#125;&gt; </span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.props.history.push(&#123;<span class="string">pathname:</span><span class="string">"/sort "</span>,<span class="string">state :</span> &#123; <span class="string">name :</span> <span class="string">'sunny'</span> &#125;&#125;);</span><br><span class="line">读取参数用: <span class="keyword">this</span>.props.location.query.state</span><br></pre></td></tr></table></figure><p>4.search</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">'/web/search '</span> component=&#123;Search&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;link to=<span class="string">"web/search?id=12121212"</span>&gt;xxx&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">this.props.history.push(&#123;pathname:`/</span>web/search?id $&#123;row.id&#125;<span class="string">`&#125;);</span></span><br><span class="line"><span class="string">读取参数用: this.props.location.search</span></span><br></pre></td></tr></table></figure><p>这个在 react-router-dom: v4.2.2有 bug,传参跳转页面会空白,刷新才会加载出来</p><p>5.优缺点</p><ul><li>1.params在HashRouter和BrowserRouter路由中刷新页面参数都不会丢失</li><li>2.state在BrowserRouter中刷新页面参数不会丢失，在HashRouter路由中刷新页面会丢失</li><li>3.query：在HashRouter和BrowserRouter路由中刷新页面参数都会丢失</li><li>4.query和 state 可以传对象</li></ul><h3 id="1-6-onRef"><a href="#1-6-onRef" class="headerlink" title="1.6 onRef"></a>1.6 onRef</h3><p>原理:onRef 通讯原理就是通过 props 的事件机制将组件的 this(组件实例)当做参数传到父组件,父组件就可以操作子组件的 state 和方法</p><p>EightteenChildFour.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">EightteenChildFour</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state=&#123;</span><br><span class="line">      name:<span class="string">'这是组件EightteenChildFour的name 值'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    <span class="keyword">this</span>.props.onRef(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// -&gt;将EightteenChildFour传递给父组件this.props.onRef()方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>:<span class="string">'这是组件click 方法改变EightteenChildFour改变的name 值'</span>&#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.state.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button type="primary" onClick=&#123;this.click&#125;&gt;</span></span><br><span class="line"><span class="regexp">          点击改变组件EightteenChildFour的name 值</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>eighteen.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;EightteenChildFour onRef=&#123;<span class="keyword">this</span>.eightteenChildFourRef&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">EightteenChildFour</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">eightteenChildFourRef = <span class="function">(<span class="params">ref</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'eightteenChildFour的Ref值为'</span>)</span><br><span class="line">  <span class="comment">// 获取的 ref 里面包括整个组件实例</span></span><br><span class="line">  <span class="built_in">console</span>.log(ref)</span><br><span class="line">  <span class="comment">// 调用子组件方法</span></span><br><span class="line">  ref.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-ref"><a href="#1-7-ref" class="headerlink" title="1.7 ref"></a>1.7 ref</h3><p>原理:就是通过 React 的 ref 属性获取到整个子组件实例,再进行操作</p><p>EightteenChildFive.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用的组件定义方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">EightteenChildFive</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state=&#123;</span><br><span class="line">      name:<span class="string">'这是组件EightteenChildFive的name 值'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>:<span class="string">'这是组件click 方法改变EightteenChildFive改变的name 值'</span>&#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.state.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button type="primary" onClick=&#123;this.click&#125;&gt;</span></span><br><span class="line"><span class="regexp">          点击改变组件EightteenChildFive的name 值</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>eighteen.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子获取实例</span></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'eightteenChildFive的Ref值为'</span>)</span><br><span class="line">      <span class="comment">// 获取的 ref 里面包括整个组件实例,同样可以拿到子组件的实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs[<span class="string">"eightteenChildFiveRef"</span>])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件定义 ref 属性</span></span><br><span class="line">&lt;EightteenChildFive ref=<span class="string">"eightteenChildFiveRef"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">EightteenChildFive</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="1-8-redux"><a href="#1-8-redux" class="headerlink" title="1.8 redux"></a>1.8 redux</h3><p>redux 是一个独立的事件通讯插件,这里就不做过多的叙述<br><a href="https://www.redux.org.cn/docs/introduction/CoreConcepts.html" target="_blank" rel="noopener">请戳传送门</a></p><h3 id="1-9-MobX"><a href="#1-9-MobX" class="headerlink" title="1.9 MobX"></a>1.9 MobX</h3><p>MobX 也是一个独立的事件通讯插件,这里就不做过多的叙述<br><a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">请戳传送门</a>:</p><h3 id="1-10-flux"><a href="#1-10-flux" class="headerlink" title="1.10 flux"></a>1.10 flux</h3><p>flux 也是一个独立的事件通讯插件,这里就不做过多的叙述<br><a href="https://facebook.github.io/flux/docs/flux-utils/#!" target="_blank" rel="noopener">请戳传送门</a>:</p><h3 id="1-11-hooks"><a href="#1-11-hooks" class="headerlink" title="1.11 hooks"></a>1.11 hooks</h3><p>1.hooks 是利用 userReducer 和 context 实现通讯,下面模拟实现一个简单的 redux</p><p>2.核心文件分为 action,reducer,types<br>action.js</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Types <span class="keyword">from</span> <span class="string">'./types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> onChangeCount = <span class="function"><span class="params">count</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="keyword">type</span>: Types.EXAMPLE_TEST,</span><br><span class="line">    count: count + <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>reducer.js</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import * as Types <span class="keyword">from</span> <span class="string">"./types"</span>;</span><br><span class="line">export const <span class="keyword">default</span>State = &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">export <span class="keyword">default</span> (<span class="keyword">state</span>, action) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case Types.EXAMPLE_TEST:</span><br><span class="line">      return &#123;</span><br><span class="line">        ...<span class="keyword">state</span>,</span><br><span class="line">        count: action.count</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      return <span class="keyword">state</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>types.js</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EXAMPLE_TEST = <span class="string">'EXAMPLE_TEST'</span>;</span><br></pre></td></tr></table></figure><p>eightteen.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ExampleContext = React.createContext(<span class="literal">null</span>);<span class="comment">//创建createContext上下文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReducerCom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [exampleState, exampleDispatch] = useReducer(example, defaultState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ExampleContext.Provider</span><br><span class="line">      value=&#123;&#123; exampleState, <span class="attr">dispatch</span>: exampleDispatch &#125;&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;EightteenChildThree&gt;<span class="xml"><span class="tag">&lt;/<span class="name">EightteenChildThree</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/ExampleContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>EightteenChildThree.jsx // 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;  useEffect, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Button&#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;onChangeCount&#125; <span class="keyword">from</span> <span class="string">'../../pages/TwoTen/store/action'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ExampleContext &#125; <span class="keyword">from</span> <span class="string">'../../pages/TwoTen/eighteen'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> exampleContext = useContext(ExampleContext);</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 监听变化</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'变化执行啦'</span>)</span><br><span class="line">    &#125;, [exampleContext.exampleState.count]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;值为&#123;exampleContext.exampleState.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Button onClick=&#123;() =&gt; exampleContext.dispatch(onChangeCount(exampleContext.exampleState.count))&#125;&gt;点击加 1&lt;/</span>Button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Example;</span></span><br></pre></td></tr></table></figure><p>3.hooks其实就是对原有React 的 API 进行了封装,暴露比较方便使用的钩子;</p><p>4.钩子有:</p><table><thead><tr><th>钩子名</th><th>作用</th></tr></thead><tbody><tr><td>useState</td><td>初始化和设置状态</td></tr><tr><td>useEffect</td><td>componentDidMount，componentDidUpdate和componentWillUnmount和结合体,所以可以监听useState定义值的变化</td></tr><tr><td>useContext</td><td>定义一个全局的对象,类似 context</td></tr><tr><td>useReducer</td><td>可以增强函数提供类似 Redux 的功能</td></tr><tr><td>useCallback</td><td>记忆作用,共有两个参数，第一个参数为一个匿名函数，就是我们想要创建的函数体。第二参数为一个数组，里面的每一项是用来判断是否需要重新创建函数体的变量，如果传入的变量值保持不变，返回记忆结果。如果任何一项改变，则返回新的结果</td></tr><tr><td>useMemo</td><td>作用和传入参数与 useCallback 一致,useCallback返回函数,useMemo 返回值</td></tr><tr><td>useRef</td><td>获取 ref 属性对应的 dom</td></tr><tr><td>useImperativeMethods</td><td>自定义使用ref时公开给父组件的实例值</td></tr><tr><td>useMutationEffect</td><td>作用与useEffect相同，但在更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发</td></tr><tr><td>useLayoutEffect</td><td>作用与useEffect相同，但在所有DOM改变后同步触发</td></tr></tbody></table><p>5.useImperativeMethods</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">  useImperativeMethods(ref, () =&gt; (&#123;</span><br><span class="line">    focus: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">FancyInput = forwardRef(FancyInput);</span></span><br></pre></td></tr></table></figure><h3 id="1-12-slot"><a href="#1-12-slot" class="headerlink" title="1.12 slot"></a>1.12 slot</h3><p>slot 就是将父组件的标签传给子组件,类似vue 的 v-slot</p><p>场景:有些组件只是共用部分dom 逻辑,里面有部分逻辑是独立的</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件文件</span></span><br><span class="line">import SlotChild from <span class="string">'SlotChild'</span></span><br><span class="line"></span><br><span class="line">&lt;SlotChild</span><br><span class="line">slot=&#123;&lt;<span class="keyword">div</span>&gt;这是父组件的 slot&lt;/<span class="keyword">div</span>&gt;&#125;&gt;</span><br><span class="line">&lt;/SlotChild&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">子组件直接获取 <span class="keyword">this</span>.props.slot 就可获取到内容</span><br></pre></td></tr></table></figure><h3 id="1-13-对比"><a href="#1-13-对比" class="headerlink" title="1.13 对比"></a>1.13 对比</h3><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>props</td><td>不需要引入外部插件</td><td>兄弟组件通讯需要建立共同父级组件,麻烦</td></tr><tr><td>props 升级版</td><td>不需要引入外部插件,子传父,不需要在父组件用方法接收</td><td>同 props</td></tr><tr><td>Provider,Consumer和Context</td><td>不需要引入外部插件,跨多级组件或者兄弟组件通讯利器</td><td>状态数据状态追踪麻烦</td></tr><tr><td>EventEmitter</td><td>可支持兄弟,父子组件通讯</td><td>要引入外部插件</td></tr><tr><td>路由传参</td><td>可支持兄弟组件传值,页面简单数据传递非常方便</td><td>父子组件通讯无能为力</td></tr><tr><td>onRef</td><td>可以在获取整个子组件实例,使用简单</td><td>兄弟组件通讯麻烦,官方不建议使用</td></tr><tr><td>ref</td><td>同 onRef</td><td>同 onRef</td></tr><tr><td>redux</td><td>建立了全局的状态管理器,兄弟父子通讯都可解决</td><td>引入了外部插件</td></tr><tr><td>mobx</td><td>建立了全局的状态管理器,兄弟父子通讯都可解决</td><td>引入了外部插件</td></tr><tr><td>flux</td><td>建立了全局的状态管理器,兄弟父子通讯都可解决</td><td>引入了外部插件</td></tr><tr><td>hooks</td><td>16.x 新的属性,可支持兄弟,父子组件通讯</td><td>需要结合 context 一起使用</td></tr><tr><td>slot</td><td>支持父向子传标签</td></tr></tbody></table><p>redux , mobx和flux对比</p><table><thead><tr><th>方法</th><th>介绍</th></tr></thead><tbody><tr><td>redux</td><td>1.核心模块:Action,Reducer,Store;2. Store 和更改逻辑是分开的;3. 只有一个 Store;4. 带有分层 reducer 的单一 Store;5. 没有调度器的概念;6. 容器组件是有联系的;7. 状态是不可改变的;8.更多的是遵循函数式编程思想</td></tr><tr><td>mobx</td><td>1.核心模块:Action,Reducer,Derivation;2.有多个 store;3.设计更多偏向于面向对象编程和响应式编程，通常将状态包装成可观察对象，一旦状态对象变更，就能自动获得更新</td></tr><tr><td>flux</td><td>1.核心模块:Store,ReduceStore,Container;2.有多个 store;</td></tr></tbody></table><h2 id="2-require-context"><a href="#2-require-context" class="headerlink" title="2.require.context()"></a>2.require.context()</h2><p>这个是 webpack 的 api,这个在 vue 技巧中有介绍,因为 Vue 和 React 工程都是基于 webpack打包,所以在 react 也可以使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="keyword">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> files = <span class="keyword">require</span>.context(<span class="string">'@/components/home'</span>, <span class="keyword">false</span>, /\.vue$/)</span><br><span class="line"><span class="keyword">const</span> modules = &#123;&#125;</span><br><span class="line">files.keys().<span class="keyword">forEach</span>(key =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> name = path.basename(key, <span class="string">'.vue'</span>)</span><br><span class="line">  modules[name] = files(key).<span class="keyword">default</span> || files(key)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-Decorator"><a href="#3-Decorator" class="headerlink" title="3.Decorator"></a>3.Decorator</h2><p>定义:decorator是ES7的一个新特性，可以修改class的属性</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="symbol">'reac</span>t'</span><br><span class="line"><span class="keyword">import</span> <span class="type">Test</span> from '../../utils/decorators'</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//只要Decorator后面是Class，默认就已经把Class当成参数隐形传进Decorator了。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwentyNine</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>,<span class="symbol">'decorator</span>.js') <span class="comment">// 这里的this是类的一个实例</span></span><br><span class="line">        console.log(<span class="keyword">this</span>.testable)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;这是技巧<span class="number">23</span>&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="type">TwentyNine</span></span><br></pre></td></tr></table></figure><p>decorators.js</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function testable(target) &#123;</span><br><span class="line">  console.log(target)</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">  target.prototype.getDate = ()=&gt;&#123;</span><br><span class="line">    console.log( new Date() )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>testable</span><br></pre></td></tr></table></figure><p>很多中间件,像 redux 里面就封装了Decorator的使用</p><h2 id="4-使用-if…else"><a href="#4-使用-if…else" class="headerlink" title="4.使用 if…else"></a>4.使用 if…else</h2><p>场景:有些时候需要根据不同状态值页面显示不同内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Four</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> info</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state.count===<span class="number">0</span>)&#123;</span><br><span class="line">      info=(</span><br><span class="line">        &lt;span&gt;这是数量为 <span class="number">0</span> 显示&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125; else if(this.state.count===1)&#123;</span></span><br><span class="line"><span class="regexp">      info=(</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;这是数量为 1 显示&lt;/</span>span&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;info&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5-state-值改变的五种方式"><a href="#5-state-值改变的五种方式" class="headerlink" title="5.state 值改变的五种方式"></a>5.state 值改变的五种方式</h2><p>方式 1</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123;count&#125; = this.<span class="keyword">state</span></span><br><span class="line">this.<span class="built_in">set</span>State(&#123;count:<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><p>方式 2:callBack</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState((&#123;<span class="keyword">count</span>&#125;)=&gt;(&#123;<span class="keyword">count</span>:<span class="keyword">count</span>+<span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure><p>方式 3:接收 state 和 props 参数</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.<span class="built_in">set</span>State((<span class="keyword">state</span>, props) =&gt; &#123;</span><br><span class="line">    return &#123; count: <span class="keyword">state</span>.count + props.step &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>方式 4:hooks</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [<span class="keyword">count</span>, setCount] = useState(0)</span><br><span class="line"><span class="comment">// 设置值</span></span><br><span class="line">setCount(<span class="keyword">count</span>+2)</span><br></pre></td></tr></table></figure><p>方式 5:state 值改变后调用</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">    &#123;count:<span class="number">3</span>&#125;,<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="regexp">//</span>得到结果做某种事</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="6-监听states-变化"><a href="#6-监听states-变化" class="headerlink" title="6.监听states 变化"></a>6.监听states 变化</h2><p>1.16.x 之前使用componentWillReceiveProps</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps (nextProps)&#123;</span><br><span class="line">  <span class="keyword">if</span>(this<span class="selector-class">.props</span><span class="selector-class">.visible</span> !== nextProps.visible)&#123;</span><br><span class="line">      <span class="comment">//props 值改变做的事</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:有些时候componentWillReceiveProps在 props 值未变化也会触发,因为在生命周期的第一次render后不会被调用，但是会在之后的每次render中被调用 = 当父组件再次传送props</p><p>2.16.x 之后使用getDerivedStateFromProps,16.x 以后componentWillReveiveProps也未移除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Six</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    countOne:<span class="number">1</span>,</span><br><span class="line">    changeFlag:<span class="string">''</span></span><br><span class="line">  &#125;;</span><br><span class="line">  clickOne()&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;countOne&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">countOne</span>:countOne+<span class="number">1</span>&#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps (nextProps)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'变化执行'</span>)</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      changeFlag:<span class="string">'state 值变化执行'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;countOne,changeFlag&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">         &lt;Button type=<span class="string">"primary"</span> onClick=&#123;<span class="keyword">this</span>.clickOne.bind(<span class="keyword">this</span>)&#125;&gt;点击加 <span class="number">1</span>&lt;<span class="regexp">/Button&gt;&lt;span&gt;countOne 值为&#123;countOne&#125;&lt;/</span>span&gt;</span><br><span class="line">        &lt;div&gt;&#123;changeFlag&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="7-组件定义"><a href="#7-组件定义" class="headerlink" title="7.组件定义"></a>7.组件定义</h2><p>方式 1:ES5 的Function 定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunCom</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是Function 定义的组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">FunCom</span> <span class="attr">name</span>=<span class="string">"Sebastian"</span> /&gt;</span>, mountNode)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 在 hooks 未出来之前,这个是定义无状态组件的方法,现在有了 hooks 也可以处理状态</span></span><br></pre></td></tr></table></figure><p>方式 2: ES5的 createClass 定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CreateClassCom = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是React.createClass定义的组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>方式 3:ES6 的 extends</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Com</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(&lt;div&gt;这是<span class="type">React</span>.<span class="type">Component</span>定义的组件&lt;/div&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Seven</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;<span class="type">FunCom</span>&gt;&lt;/<span class="type">FunCom</span>&gt;</span><br><span class="line">        &lt;<span class="type">Com</span>&gt;&lt;/<span class="type">Com</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别: ES5的 createClass是利用function模拟class的写法做出来的es6;</p><p>通过es6新增class的属性创建的组件此组件创建简单.</p><h2 id="8-通过-ref-属性获取-component"><a href="#8-通过-ref-属性获取-component" class="headerlink" title="8.通过 ref 属性获取 component"></a>8.通过 ref 属性获取 component</h2><p>方式 1:也是最早的用法,通过 this.refs[属性名获取]<br>也可以作用到组件上,从而拿到组件实例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefOne</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs[<span class="symbol">'bo</span>x'].innerHTML='这是 div 盒子,通过 ref 获取'</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div ref=<span class="string">"box"</span>&gt;&lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式 2:回调函数,在dom节点或组件上挂载函数，函数的入参是dom节点或组件实例，达到的效果与字符串形式是一样的，都是获取其引用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefTwo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.input.value='这是输入框默认值';</span><br><span class="line">    <span class="keyword">this</span>.input.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;input ref=&#123;comp =&gt; &#123; <span class="keyword">this</span>.input = comp; &#125;&#125;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式 3:React.createRef()<br>React 16.3版本后，使用此方法来创建ref。将其赋值给一个变量，通过ref挂载在dom节点或组件上，该ref的current属性,将能拿到dom节点或组件的实例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefThree</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.myRef=<span class="type">React</span>.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.myRef.current);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input ref=&#123;<span class="keyword">this</span>.myRef&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式 4:React.forwardRef<br>React 16.3版本后提供的，可以用来创建子组件，以传递ref</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefFour</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.myFourRef=<span class="type">React</span>.forwardRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.myFourRef.current);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;<span class="type">Child</span> ref=&#123;<span class="keyword">this</span>.myFourRef&#125;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子组件通过React.forwardRef来创建，可以将ref传递到内部的节点或组件，进而实现跨层级的引用。forwardRef在高阶组件中可以获取到原始组件的实例.这个功能在技巧 18 会着重讲</p><h2 id="9-static-使用"><a href="#9-static-使用" class="headerlink" title="9.static 使用"></a>9.static 使用</h2><p>场景:声明静态方法的关键字,静态方法是指即使没有组件实例也可以直接调用</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Nine</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  static update(data) &#123;</span><br><span class="line">    console.log('静态方法调用执行啦')</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是 static 关键字技能</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Nine</span>.update('<span class="number">2</span>')</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>1.ES6的class，我们定义一个组件的时候通常是定义了一个类，而static则是创建了一个属于这个类的属性或者方法</li><li>2.组件则是这个类的一个实例，component的props和state是属于这个实例的，所以实例还未创建</li><li>3.所以static并不是react定义的，而加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用,所以也是无法访问到 this</li><li>4.getDerivedStateFromProps也是通过静态方法监听值,详情请见技巧 6</li></ul><h2 id="10-constructor和super"><a href="#10-constructor和super" class="headerlink" title="10.constructor和super"></a>10.constructor和super</h2><p>回顾:</p><ul><li>1.谈这两个属性之前,先回顾一下ES6 函数定义方法</li><li>2.每一个使用class方式定义的类默认都有一个constructor函数， 这个函数是构造函数的主函数， 该函数体内部的this指向生成的实例</li><li>3.super关键字用于访问和调用一个对象的父对象上的函数</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Ten</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor() &#123; <span class="comment">// class 的主函数</span></span><br><span class="line">    <span class="keyword">super</span>() <span class="comment">// React.Component.prototype.constructor.call(this),其实就是拿到父类的属性和方法</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      arr:[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        这是技巧 <span class="number">10</span></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-PropTypes"><a href="#11-PropTypes" class="headerlink" title="11.PropTypes"></a>11.PropTypes</h2><p>场景:检测传入子组件的数据类型<br>类型检查PropTypes自React v15.5起已弃用，请使用prop-types</p><p>方式 1:旧的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropTypeOne</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.props.email&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.props.name&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">PropTypeOne.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  name: PropTypes.string, /</span><span class="regexp">/值可为array,bool,func,number,object,symbol</span></span><br><span class="line"><span class="regexp">  email: function(props, propName, componentName) &#123; /</span><span class="regexp">/自定义校验</span></span><br><span class="line"><span class="regexp">    if (</span></span><br><span class="line"><span class="regexp">      !/</span>^([a-zA-Z0<span class="number">-9</span>_-])+@([a-zA-Z0<span class="number">-9</span>_-])+(.[a-zA-Z0<span class="number">-9</span>_-])+<span class="regexp">/.test(</span></span><br><span class="line"><span class="regexp">        props[propName]</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    ) &#123;</span></span><br><span class="line"><span class="regexp">      return new Error(</span></span><br><span class="line"><span class="regexp">        "组件" + componentName + "里的属性" + propName + "不符合邮箱的格式"</span></span><br><span class="line"><span class="regexp">      );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>方法 2:利用 ES7 的静态属性关键字 static</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PropTypeTwo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">      name:<span class="type">PropTypes</span>.string</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-使用类字段声明语法"><a href="#12-使用类字段声明语法" class="headerlink" title="12.使用类字段声明语法"></a>12.使用类字段声明语法</h2><p>场景:可以在不使用构造函数的情况下初始化本地状态，并通过使用箭头函数声明类方法，而无需额外对它们进行绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">value</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">  handleIncrement = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      value: prevState.value + <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleDecrement = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      value: prevState.value - <span class="number">1</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line"></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleIncrement&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleDecrement&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="13-异步组件"><a href="#13-异步组件" class="headerlink" title="13.异步组件"></a>13.异步组件</h2><p>1.场景:路由切换,如果同步加载多个页面路由会导致缓慢</p><p>2.核心 API:</p><ul><li>loader:需要加载的组件</li><li>loading:未加载出来的页面展示组件</li><li>delay:延迟加载时间</li><li>timeout:超时时间</li></ul><p>3.使用方法:</p><p>安装 react-loadable ,babel插件安装 syntax-dynamic-import. react-loadable是通过webpack的异步import实现的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Loading = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LoadableComponent = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"../../components/TwoTen/thirteen"</span>),</span><br><span class="line">  loading: Loading</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Thirteen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LoadableComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">LoadableComponent</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.Loadable.Map()</p><p>并行加载多个资源的高阶组件</p><h2 id="14-动态组件"><a href="#14-动态组件" class="headerlink" title="14.动态组件"></a>14.动态组件</h2><p>场景:做一个 tab 切换时就会涉及到组件动态加载</p><p>实质上是利用三元表达式判断组件是否显示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourteenChildOne</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;这是动态组件 <span class="number">1</span>&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourteenChildTwo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;div&gt;这是动态组件 <span class="number">2</span>&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Fourteen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state=&#123;</span><br><span class="line">      oneShowFlag:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  tab=()=&gt;&#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;oneShowFlag:!<span class="keyword">this</span>.state.oneShowFlag&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;oneShowFlag&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">        &lt;<span class="type">Button</span> <span class="class"><span class="keyword">type</span></span>=<span class="string">"primary"</span> onClick=&#123;<span class="keyword">this</span>.tab&#125;&gt;显示组件&#123;oneShowFlag?<span class="number">2</span>:<span class="number">1</span>&#125;&lt;/<span class="type">Button</span>&gt;</span><br><span class="line">        &#123;oneShowFlag?&lt;<span class="type">FourteenChildOne</span>&gt;&lt;/<span class="type">FourteenChildOne</span>&gt;:&lt;<span class="type">FourteenChildTwo</span>&gt;&lt;/<span class="type">FourteenChildTwo</span>&gt;&#125;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是单个组件是否显示可以用短路运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oneShowFlag&amp;&amp;<span class="xml"><span class="tag">&lt;<span class="name">FourteenChildOne</span>&gt;</span><span class="tag">&lt;/<span class="name">FourteenChildOne</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="15-递归组件"><a href="#15-递归组件" class="headerlink" title="15.递归组件"></a>15.递归组件</h2><p>场景:tree组件<br>利用React.Fragment或者 div 包裹循环</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const list = <span class="keyword">this</span>.props.children || [];</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"item"</span>&gt;</span><br><span class="line">        &#123;list.map((item, index) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;<span class="type">React</span>.<span class="type">Fragment</span> key=&#123;index&#125;&gt;</span><br><span class="line">              &lt;h3&gt;&#123;item.name&#125;&lt;/h3&gt;</span><br><span class="line">              &#123;<span class="comment">// 当该节点还有children时，则递归调用本身</span></span><br><span class="line">              item.children &amp;&amp; item.children.length ? (</span><br><span class="line">                &lt;<span class="type">Item</span>&gt;&#123;item.children&#125;&lt;/<span class="type">Item</span>&gt;</span><br><span class="line">              ) : <span class="literal">null</span>&#125;</span><br><span class="line">            &lt;/<span class="type">React</span>.<span class="type">Fragment</span>&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-受控组件和不受控组件"><a href="#16-受控组件和不受控组件" class="headerlink" title="16.受控组件和不受控组件"></a>16.受控组件和不受控组件</h2><p>受控组件:组件的状态通过React 的状态值 state 或者 props 控制</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controll</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; value: <span class="string">"这是受控组件默认值"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.state.value&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不受控组件:组件不被 React的状态值控制,通过 dom 的特性或者React 的ref 来控制</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoControll</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.props.value&#125;&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Sixteen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"ref 获取的不受控组件值为"</span>, <span class="keyword">this</span>.refs[<span class="string">"noControll"</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Controll&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Controll</span>&gt;</span></span></span><br><span class="line">        &lt;NoControll</span><br><span class="line">          value=&#123;<span class="string">"这是不受控组件传入值"</span>&#125;</span><br><span class="line">          ref=<span class="string">"noControll"</span></span><br><span class="line">        &gt;<span class="xml"><span class="tag">&lt;/<span class="name">NoControll</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="17-高阶组件-HOC"><a href="#17-高阶组件-HOC" class="headerlink" title="17.高阶组件(HOC)"></a>17.高阶组件(HOC)</h2><h3 id="17-1-定义"><a href="#17-1-定义" class="headerlink" title="17.1 定义"></a>17.1 定义</h3><p>1.就是类似高阶函数的定义,将组件作为参数或者返回一个组件的组件;</p><p>2.作用:</p><ul><li>抽取重复代码，实现组件复用，常见场景,页面复用;</li><li>条件渲染，控制组件的渲染逻辑（渲染劫持），常见场景,权限控制;</li><li>捕获/劫持被处理组件的生命周期，常见场景,组件渲染性能追踪、日志打点</li></ul><h3 id="17-2-实现方法"><a href="#17-2-实现方法" class="headerlink" title="17.2 实现方法"></a>17.2 实现方法</h3><p>1.属性代理</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>,&#123;<span class="type">Component</span>&#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"></span><br><span class="line">const <span class="type">Seventeen</span> = <span class="type">WrappedComponent</span> =&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      const props = &#123;</span><br><span class="line">        ...<span class="keyword">this</span>.props,</span><br><span class="line">        name: <span class="string">"这是高阶组件"</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> &lt;<span class="type">WrappedComponent</span> &#123;...props&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state=&#123;</span><br><span class="line">     baseName:'这是基础组件' </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;baseName&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    const &#123;name&#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &lt;div&gt;基础组件值为&#123;baseName&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;通过高阶组件属性代理的得到的值为&#123;name&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="type">Seventeen</span>(<span class="type">WrappedComponent</span>)</span><br></pre></td></tr></table></figure><p>2.反向继承<br>原理就是利用 super 改变改组件的 this 方向,继而就可以在该组件处理容器组件的一些值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const <span class="type">Seventeen</span> = (<span class="type">WrappedComponent</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;baseName:'这是通过反向继承修改后的基础组件名称'&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.render();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrappedComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state=&#123;</span><br><span class="line">     baseName:'这是基础组件' </span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;baseName&#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &lt;div&gt;基础组件值为&#123;baseName&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="type">Seventeen</span>(<span class="type">WrappedComponent</span>);</span><br></pre></td></tr></table></figure><h2 id="18-元素是否显示"><a href="#18-元素是否显示" class="headerlink" title="18.元素是否显示"></a>18.元素是否显示</h2><p>一般用三元表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag?<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>显示内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>:<span class="string">''</span></span><br><span class="line"> flag&amp;&amp;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>显示内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="19-Dialog-组件创建"><a href="#19-Dialog-组件创建" class="headerlink" title="19.Dialog 组件创建"></a>19.Dialog 组件创建</h2><p>Dialog 应该是用的比较多的组件,下面有三种不同的创建方法</p><p>方式 1:通过 state 控制组件是否显示</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NineteenChildOne</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const <span class="type">Dialog</span> = () =&gt; &lt;div&gt;这是弹层<span class="number">1</span>&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.dialogOneFlag &amp;&amp; &lt;<span class="type">Dialog</span> /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式 2:通过ReactDom.render创建弹层-挂载根节点外层</p><p>通过原生的createElement,appendChild, removeChild和react 的ReactDOM.render,ReactDOM.unmountComponentAtNode来控制元素的显示和隐藏</p><p>NineteenChild.jsx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="keyword">this</span>.div.style.width = <span class="string">"200px"</span>;</span><br><span class="line">    <span class="keyword">this</span>.div.style.height = <span class="string">"200px"</span>;</span><br><span class="line">    <span class="keyword">this</span>.div.style.backgroundColor = <span class="string">"green"</span>;</span><br><span class="line">    <span class="keyword">this</span>.div.style.position = <span class="string">"absolute"</span>;</span><br><span class="line">    <span class="keyword">this</span>.div.style.top = <span class="string">"200px"</span>;</span><br><span class="line">    <span class="keyword">this</span>.div.style.left = <span class="string">"400px"</span>;</span><br><span class="line">    <span class="keyword">this</span>.div.id = <span class="string">"dialog-box"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  show(children) &#123;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.querySelector(<span class="string">"#dialog-box"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dom)&#123; <span class="comment">//兼容多次点击</span></span><br><span class="line">      <span class="comment">// 显示</span></span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(<span class="keyword">this</span>.div);</span><br><span class="line">      ReactDOM.render(children, <span class="keyword">this</span>.div);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  destroy() &#123;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.querySelector(<span class="string">"#dialog-box"</span>);</span><br><span class="line">    <span class="keyword">if</span>(dom)&#123;<span class="comment">//兼容多次点击</span></span><br><span class="line">      ReactDOM.unmountComponentAtNode(<span class="keyword">this</span>.div);</span><br><span class="line">      dom.parentNode.removeChild(dom);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  show: <span class="function"><span class="keyword">function</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Dialog().show(children);</span><br><span class="line">  &#125;,</span><br><span class="line">  hide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Dialog().destroy();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>nineteen.jsx</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">twoSubmit</span>=<span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    Dialog.show(<span class="string">'这是弹层2'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">  <span class="title">twoCancel</span>=<span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    Dialog.hide()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="20-React-memo"><a href="#20-React-memo" class="headerlink" title="20.React.memo"></a>20.React.memo</h2><p>作用:当类组件的输入属性相同时，可以使用 pureComponent 或 shouldComponentUpdate 来避免组件的渲染。现在，你可以通过把函数组件包装在 React.memo 中来实现相同的功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (prevProps.val === nextProps.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React.memo()两个参数,第一个是纯函数,第二个是比较函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(<span class="function"><span class="keyword">function</span> <span class="title">twentyChild</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"MemoSon rendered : "</span> + <span class="built_in">Date</span>.now());</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;, areEqual);</span><br></pre></td></tr></table></figure><h2 id="21-React-PureComponent"><a href="#21-React-PureComponent" class="headerlink" title="21.React.PureComponent"></a>21.React.PureComponent</h2><p>作用:</p><ul><li>1.React.PureComponent 和 React.Component类似，都是定义一个组件类。</li><li>2.不同是React.Component没有实现shouldComponentUpdate()，而 React.PureComponent通过props和state的浅比较实现了。</li><li>3.React.PureComponent是作用在类中,而React.memo是作用在函数中。</li><li>4.如果组件的props和state相同时，render的内容也一致，那么就可以使用React.PureComponent了,这样可以提高组件的性能</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwentyOneChild</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span></span>&#123;  <span class="comment">//组件直接继承React.PureComponent</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;<span class="keyword">this</span>.props.name&#125;&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TwentyOne</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;<span class="type">TwentyOneChild</span> name=&#123;'这是<span class="type">React</span>.<span class="type">PureComponent</span>的使用方法'&#125;&gt;&lt;/<span class="type">TwentyOneChild</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-React-Component"><a href="#22-React-Component" class="headerlink" title="22.React.Component"></a>22.React.Component</h2><p>作用:是基于ES6 class的React组件,React允许定义一个class或者function作为组件，那么定义一个组件类，就需要继承React.Component</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TwentyTwo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123; <span class="comment">//组件定义方法</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;这是技巧<span class="number">22</span>&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-在-JSX-打印-falsy-值"><a href="#23-在-JSX-打印-falsy-值" class="headerlink" title="23.在 JSX 打印 falsy 值"></a>23.在 JSX 打印 falsy 值</h2><p>定义:</p><p>1.falsy 值 (虚值) 是在 Boolean 上下文中认定为 false 的值;</p><p>2.值有 0,””,’’,``,null,undefined,NaN</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TwentyThree</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    state=&#123;myVariable:<span class="literal">null</span>&#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123;<span class="type">String</span>(<span class="keyword">this</span>.state.myVariable)&#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚值如果直接展示,会发生隐式转换,为 false,所以页面不显示</p><h2 id="24-ReactDOM-createPortal"><a href="#24-ReactDOM-createPortal" class="headerlink" title="24.ReactDOM.createPortal"></a>24.ReactDOM.createPortal</h2><p>作用:组件的render函数返回的元素会被挂载在它的父级组件上,createPortal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Button&#125; <span class="keyword">from</span> <span class="string">"antd"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modalRoot = <span class="built_in">document</span>.body;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    <span class="keyword">this</span>.el.style.width = <span class="string">"200px"</span>;</span><br><span class="line">    <span class="keyword">this</span>.el.style.height = <span class="string">"200px"</span>;</span><br><span class="line">    <span class="keyword">this</span>.el.style.backgroundColor = <span class="string">"green"</span>;</span><br><span class="line">    <span class="keyword">this</span>.el.style.position = <span class="string">"absolute"</span>;</span><br><span class="line">    <span class="keyword">this</span>.el.style.top = <span class="string">"200px"</span>;</span><br><span class="line">    <span class="keyword">this</span>.el.style.left = <span class="string">"400px"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    modalRoot.appendChild(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    modalRoot.removeChild(<span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> ReactDOM.createPortal(<span class="keyword">this</span>.props.children, <span class="keyword">this</span>.el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"modal"</span>&gt;</span><br><span class="line">      这个是通过ReactDOM.createPortal创建的内容</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default class TwentyFour extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123; clicks: 0 &#125;;</span></span><br><span class="line"><span class="regexp">    this.handleClick = this.handleClick.bind(this);</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  handleClick() &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">      clicks: prevState.clicks + 1</span></span><br><span class="line"><span class="regexp">    &#125;));</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Button onClick=&#123;this.handleClick&#125;&gt;点击加1&lt;/</span>Button&gt;</span><br><span class="line">        &lt;p&gt;点击次数: &#123;<span class="keyword">this</span>.state.clicks&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Modal&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Child /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Modal&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样元素就追加到指定的元素下面啦</p><h2 id="25-在-React-使用innerHTML"><a href="#25-在-React-使用innerHTML" class="headerlink" title="25.在 React 使用innerHTML"></a>25.在 React 使用innerHTML</h2><p>场景:有些后台返回是 html 格式字段,就需要用到 innerHTML 属性</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TwentyFive</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: <span class="string">"&lt;span&gt;这是渲染的 HTML 内容&lt;/span&gt;"</span> &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-React-createElement"><a href="#26-React-createElement" class="headerlink" title="26.React.createElement"></a>26.React.createElement</h2><p>语法:<br>React.createElement(type,[props],[…children])<br>源码:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TwentySix</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="type">React</span>.createElement(</span><br><span class="line">          <span class="string">"div"</span>,</span><br><span class="line">          &#123; id: <span class="string">"one"</span>, className: <span class="string">"two"</span> &#125;,</span><br><span class="line">          <span class="type">React</span>.createElement(<span class="string">"span"</span>, &#123; id: <span class="string">"spanOne"</span> &#125;, <span class="string">"这是第一个 span 标签"</span>),</span><br><span class="line">          <span class="type">React</span>.createElement(<span class="string">"br"</span>),</span><br><span class="line">          <span class="type">React</span>.createElement(<span class="string">"span"</span>, &#123; id: <span class="string">"spanTwo"</span> &#125;, <span class="string">"这是第二个 span 标签"</span>)</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理:实质上 JSX 的 dom 最后转化为 js 都是React.createElement<br>// jsx 语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'one'</span> <span class="attr">class</span>=<span class="string">'two'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"spanOne"</span>&gt;</span>this is spanOne<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"spanTwo"</span>&gt;</span>this is spanTwo<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>// 转化为 js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  "div",</span><br><span class="line"> &#123; id: "one", class: "two" &#125;,</span><br><span class="line"> React.createElement( "span", &#123; id: "spanOne" &#125;, "this is spanOne"), </span><br><span class="line"> React.createElement("span", &#123; id: "spanTwo" &#125;, "this is spanTwo")</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="27-React-cloneElement"><a href="#27-React-cloneElement" class="headerlink" title="27.React.cloneElement"></a>27.React.cloneElement</h2><p>语法:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">React</span><span class="selector-class">.cloneElement</span>(</span><br><span class="line">  <span class="selector-tag">element</span>,</span><br><span class="line">  <span class="selector-attr">[props]</span>,</span><br><span class="line">  <span class="selector-attr">[...children]</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>作用:这个方法的作用是复制组件,给组件传值或者添加属性<br>核心代码</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.Children.map(children, child =&gt; &#123;</span><br><span class="line">  return React.cloneElement(child, &#123;</span><br><span class="line">    count: _this.<span class="keyword">state</span>.count</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="28-React-Fragment"><a href="#28-React-Fragment" class="headerlink" title="28.React.Fragment"></a>28.React.Fragment</h2><p>作用:React.Fragment可以让你聚合一个子元素列表，并且不在DOM中增加额外节点<br>核心代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; info &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;info.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;React.Fragment key=&#123;index&#125;&gt;</span><br><span class="line">              &lt;div&gt;&#123;item.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;div&gt;&#123;item.age&#125;&lt;/</span>div&gt;</span><br><span class="line">            &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">          );</span></span><br><span class="line"><span class="regexp">        &#125;)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="29-循环元素"><a href="#29-循环元素" class="headerlink" title="29.循环元素"></a>29.循环元素</h2><p>内部没有封装像 vue 里面 v-for 的指令,而是通过 map 遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;arr.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    &lt;div key=&#123;item.id&#125;&gt;</span><br><span class="line">      &lt;span&gt;&#123;item.name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;&#123;item.age&#125;&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;)&#125;</span></span><br></pre></td></tr></table></figure><h2 id="30-给-DOM-设置和获取自定义属性"><a href="#30-给-DOM-设置和获取自定义属性" class="headerlink" title="30.给 DOM 设置和获取自定义属性"></a>30.给 DOM 设置和获取自定义属性</h2><p>作用:有些要通过自定义属性传值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Thirty</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  click = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.getAttribute(<span class="string">"data-row"</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div data-row=&#123;<span class="string">"属性1"</span>&#125; data-col=&#123;<span class="string">"属性 2"</span>&#125; onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;</span><br><span class="line">          点击获取属性</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-绑定事件"><a href="#31-绑定事件" class="headerlink" title="31.绑定事件"></a>31.绑定事件</h2><p>场景:交互就会涉及到事件点击,然后点击选中值传参也是一个很常见场景</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="type">Button</span> &#125; from <span class="symbol">'ant</span>d'</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Three</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    flag: <span class="literal">true</span>,</span><br><span class="line">    flagOne: <span class="number">1</span></span><br><span class="line">  &#125;;</span><br><span class="line">  click(data1,data2)&#123;</span><br><span class="line">    console.log(<span class="symbol">'data1</span> 值为',data1)</span><br><span class="line">    console.log(<span class="symbol">'data2</span> 值为',data2)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;<span class="type">Button</span> <span class="class"><span class="keyword">type</span></span>=<span class="string">"primary"</span> onClick=&#123;<span class="keyword">this</span>.click.bind(<span class="keyword">this</span>,'参数 <span class="number">1</span>','参数 <span class="number">2</span>')&#125;&gt;点击事件&lt;/<span class="type">Button</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-React-Router"><a href="#32-React-Router" class="headerlink" title="32.React-Router"></a>32.React-Router</h2><h3 id="32-1-V3和-V4的区别"><a href="#32-1-V3和-V4的区别" class="headerlink" title="32.1 V3和 V4的区别"></a>32.1 V3和 V4的区别</h3><ul><li>1.V3或者说V早期版本是把router 和 layout components 分开;</li><li>2.V4是集中式 router,通过 Route 嵌套，实现 Layout 和 page 嵌套,Layout 和 page 组件 是作为 router 的一部分;</li><li>3.在V3 中的 routing 规则是 exclusive，意思就是最终只获取一个 route;</li><li>4.V4 中的 routes 默认是 inclusive 的，这就意味着多个;   可以同时匹配和呈现.如果只想匹配一个路由，可以使用Switch，在  中只有一个  会被渲染，同时可以再在每个路由添加exact，做到精准匹配<br>Redirect，浏览器重定向，当多有都不匹配的时候，进行匹配</li></ul><h3 id="32-2-使用"><a href="#32-2-使用" class="headerlink" title="32.2 使用"></a>32.2 使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; HashRouter <span class="keyword">as</span> Router, Switch  &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> authPath = <span class="string">'/login'</span> <span class="comment">// 默认未登录的时候返回的页面，可以自行设置</span></span><br><span class="line">        <span class="keyword">let</span> authed = <span class="keyword">this</span>.props.state.authed || localStorage.getItem(<span class="string">'authed'</span>) <span class="comment">// 如果登陆之后可以利用redux修改该值</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Router&gt;</span><br><span class="line">                &lt;Switch&gt;</span><br><span class="line">                    &#123;renderRoutes(routes, authed, authPath)&#125;</span><br><span class="line">                &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>Router&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>V4是通过 Route 嵌套，实现 Layout 和 page 嵌套,Switch切换路由的作用</p><h2 id="33-样式引入方法"><a href="#33-样式引入方法" class="headerlink" title="33.样式引入方法"></a>33.样式引入方法</h2><p>方式 1:import 导入</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> './App.css';</span></span><br></pre></td></tr></table></figure><p>方式 2:内联方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> heading = <span class="string">'头部组件'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div style=&#123;&#123;<span class="attr">backgroundColor</span>:<span class="string">'orange'</span>&#125;&#125;&gt;</span><br><span class="line">            &lt;h1&gt;&#123;heading&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> footerStyle = &#123;</span><br><span class="line">    width: <span class="string">'100%'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'green'</span>,</span><br><span class="line">    padding: <span class="string">'50px'</span>,</span><br><span class="line">    font: <span class="string">'30px'</span>,</span><br><span class="line">    color: <span class="string">'white'</span>,</span><br><span class="line">    fontWeight: <span class="string">'bold'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Footer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div style=&#123;footerStyle&#125;&gt;</span><br><span class="line">            底部组件</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="34-动态绑定-className"><a href="#34-动态绑定-className" class="headerlink" title="34.动态绑定 className"></a>34.动态绑定 className</h2><p>原理:通过三元表达式控制 className 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> flag=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=&#123;flag?<span class="string">"active"</span>:<span class="string">"no-active"</span>&#125;&gt;这是技巧 <span class="number">34</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903993278201870" target="_blank" rel="noopener">https://juejin.cn/post/6844903993278201870</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;1-组件通讯&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="react" scheme="https://chongdee.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://chongdee.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 常用场景</title>
    <link href="https://chongdee.github.io/2021/07/21/react/react%20hooks%20%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://chongdee.github.io/2021/07/21/react/react hooks 常用场景/</id>
    <published>2021-07-20T18:29:28.215Z</published>
    <updated>2021-07-20T17:38:52.969Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React 在 v16.8 的版本中推出了 React Hooks 新特性。在我看来，使用 React Hooks 相比于从前的类组件有以下几点好处：</p><p>代码可读性更强，原本同一块功能的代码逻辑被拆分在了不同的生命周期函数中，容易使开发者不利于维护和迭代，通过 React Hooks 可以将功能代码聚合，方便阅读维护；</p><p>组件树层级变浅，在原本的代码中，我们经常使用 HOC/render props 等方式来复用组件的状态，增强功能等，无疑增加了组件树层数及渲染，而在 React Hooks 中，这些功能都可以通过强大的自定义的 Hooks 来实现；</p><p>关于这方面的文章，我们根据使用场景分别进行举例说明，帮助你认识理解并可以熟练运用 React Hooks 大部分特性。辛苦整理良久，还望手动点赞鼓励~</p><h2 id="一、State-Hook"><a href="#一、State-Hook" class="headerlink" title="一、State Hook"></a>一、State Hook</h2><h3 id="1、基础用法"><a href="#1、基础用法" class="headerlink" title="1、基础用法"></a>1、基础用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">State</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">              Click me</span></span><br><span class="line"><span class="regexp">          &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2、更新"><a href="#2、更新" class="headerlink" title="2、更新"></a>2、更新</h3><p>更新分为以下两种方式，即直接更新和函数式更新，其应用场景的区分点在于：</p><p>直接更新不依赖于旧 state 的值；函数式更新依赖于旧 state 的值；</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 直接更新</span><br><span class="line"><span class="keyword">set</span>State<span class="params">(newCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 函数式更新</span><br><span class="line"><span class="keyword">set</span>State<span class="params">(<span class="attr">prevCount</span> =&gt; prevCount - 1)</span>;</span><br></pre></td></tr></table></figure><h3 id="3、实现合并"><a href="#3、实现合并" class="headerlink" title="3、实现合并"></a>3、实现合并</h3><p>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象，而是直接替换它。我们可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setState(prevState =&gt; &#123;</span><br><span class="line">  <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123;.<span class="built_in">..prevState</span>, .<span class="built_in">..updatedValues</span>&#125;<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>4、惰性初始化 state</p><p>initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。其应用场景在于：创建初始 state 很昂贵时，例如需要通过复杂计算获得；那么则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const [<span class="keyword">state</span>, <span class="built_in">set</span>State] = useState(() =&gt; &#123;</span><br><span class="line">  const initialState = someExpensiveComputation(props);</span><br><span class="line">  return initialState;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><ul><li>（1）不像 class 中的 this.setState ，Hook 更新 state 变量总是替换它而不是合并它；</li><li>（2）推荐使用多个 state 变量，而不是单个 state 变量，因为 state 的替换逻辑而不是合并逻辑，并且利于后续的相关 state 逻辑抽离；</li><li>（3）调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过子组件的渲染及 effect 的执行。（React 使用 Object.is 比较算法 来比较 state。）</li></ul><h2 id="二、Effect-Hook"><a href="#二、Effect-Hook" class="headerlink" title="二、Effect Hook"></a>二、Effect Hook</h2><h3 id="1、基础用法-1"><a href="#1、基础用法-1" class="headerlink" title="1、基础用法"></a>1、基础用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Effect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">              Click me</span></span><br><span class="line"><span class="regexp">          &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2、清除操作"><a href="#2、清除操作" class="headerlink" title="2、清除操作"></a>2、清除操作</h3><p>为防止内存泄漏，清除函数会在组件卸载前执行；如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除，即先执行上一个 effect 中 return 的函数，然后再执行本 effect 中非 return 的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 清除订阅</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3、执行时期"><a href="#3、执行时期" class="headerlink" title="3、执行时期"></a>3、执行时期</h3><p>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快；（componentDidMount 或 componentDidUpdate 会阻塞浏览器更新屏幕）</p><h3 id="4、性能优化"><a href="#4、性能优化" class="headerlink" title="4、性能优化"></a>4、性能优化</h3><p>默认情况下，React 会每次等待浏览器完成画面渲染之后延迟调用 effect；但是如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可：如下所示，如果 count 值两次渲染之间没有发生变化，那么第二次渲染后就会跳过 effect 的调用；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</span><br><span class="line">&#125;, [count]); <span class="comment">// 仅在 count 更改时更新</span></span><br></pre></td></tr></table></figure><h3 id="5、模拟-componentDidMount"><a href="#5、模拟-componentDidMount" class="headerlink" title="5、模拟 componentDidMount"></a>5、模拟 componentDidMount</h3><p>如果想只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[ ]）作为第二个参数，如下所示，原理跟第 4 点性能优化讲述的一样；</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h3 id="6、最佳实践"><a href="#6、最佳实践" class="headerlink" title="6、最佳实践"></a>6、最佳实践</h3><p>要记住 effect 外部的函数使用了哪些 props 和 state 很难，这也是为什么 通常你会想要在 effect 内部 去声明它所需要的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad，不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(someProp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;, []); <span class="comment">// 🔴 这样不安全（它调用的 `doSomething` 函数使用了 `someProp`）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good，推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(someProp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    doSomething();</span><br><span class="line">  &#125;, [someProp]); <span class="comment">// ✅ 安全（我们的 effect 仅用到了 `someProp`）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果处于某些原因你无法把一个函数移动到 effect 内部，还有一些其他办法：</p><p>你可以尝试把那个函数移动到你的组件之外。那样一来，这个函数就肯定不会依赖任何 props 或 state，并且也不用出现在依赖列表中了；万不得已的情况下，你可以 把函数加入 effect 的依赖但 把它的定义包裹 进 useCallback Hook。这就确保了它不随渲染而改变，除非它自身的依赖发生了改变；</p><p>推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则，此规则会在添加错误依赖时发出警告并给出修复建议 ；<br> 1、安装插件</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint-plugin-react-hooks --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>2、eslint 配置</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    <span class="string">//</span> <span class="string">...</span></span><br><span class="line">    <span class="string">"react-hooks"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">//</span> <span class="string">...</span></span><br><span class="line">    <span class="string">"react-hooks/rules-of-hooks"</span>: <span class="string">"error"</span>,</span><br><span class="line">    <span class="string">"react-hooks/exhaustive-deps"</span>: <span class="string">"warn"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><ul><li>（1）可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate和 componentWillUnmount这三个函数的组合；</li><li>（2）在 React 的 class 组件中，render 函数是不应该有任何副作用的；一般来说，在这里执行操作太早了，我们基本上都希望在 React 更新 DOM 之后才执行我们的操作。</li></ul><h2 id="三、useContext"><a href="#三、useContext" class="headerlink" title="三、useContext"></a>三、useContext</h2><p>用来处理多层级传递数据的方式，在以前组件树中，跨层级祖先组件想要给孙子组件传递数据的时候，除了一层层 props 往下透传之外，我们还可以使用 React Context API 来帮我们做这件事。使用例子如下所示 </p><p>（1）使用 React Context API，在组件外部建立一个 Context</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeContext;</span><br></pre></td></tr></table></figure><p>（2）使用 Context.Provider提供了一个 Context 对象，这个对象可以被子组件共享</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ThemeContext <span class="keyword">from</span> <span class="string">'./ThemeContext'</span>;</span><br><span class="line"><span class="keyword">import</span> ContextComponent1 <span class="keyword">from</span> <span class="string">'./ContextComponent1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ContextPage</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;count&#125;&gt;</span><br><span class="line">        &lt;ContextComponent1 /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">              Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default ContextPage;</span></span><br></pre></td></tr></table></figure><p>（3）useContext()钩子函数用来引入 Context 对象，并且获取到它的值 // 子组件，在子组件中使用孙组件</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ContextComponent2 from <span class="string">'./ContextComponent2'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ContextComponent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ContextComponent2 /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ContextComponent;</span><br><span class="line"><span class="comment">// 孙组件，在孙组件中使用 Context 对象值</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ThemeContext from <span class="string">'./ThemeContext'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ContextComponent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;<span class="attribute">useContext</span>:&#123;value&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default ContextComponent;</span></span><br></pre></td></tr></table></figure><h2 id="四、useReducer"><a href="#四、useReducer" class="headerlink" title="四、useReducer"></a>四、useReducer</h2><h3 id="1、基础用法-2"><a href="#1、基础用法-2" class="headerlink" title="1、基础用法"></a>1、基础用法</h3><p>比 useState 更适用的场景：例如 state 逻辑处理较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等；例子如下所示</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useReducer &#125; <span class="keyword">from</span> 'react';</span><br><span class="line">interface <span class="keyword">state</span>Type &#123;</span><br><span class="line">  count: number</span><br><span class="line">&#125;</span><br><span class="line">interface actionType &#123;</span><br><span class="line">  type: string</span><br><span class="line">&#125;</span><br><span class="line">const initialState = &#123; count: <span class="number">0</span> &#125;;</span><br><span class="line">const reducer = (<span class="keyword">state</span>:<span class="keyword">state</span>Type, action:actionType) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case 'increment':</span><br><span class="line">      return &#123; count: <span class="keyword">state</span>.count + <span class="number">1</span> &#125;;</span><br><span class="line">    case 'decrement':</span><br><span class="line">      return &#123; count: <span class="keyword">state</span>.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const UseReducer = () =&gt; &#123;</span><br><span class="line">  const [<span class="keyword">state</span>, dispatch] = useReducer(reducer, initialState);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    <span class="variable">&lt;div className="App"&gt;</span></span><br><span class="line">      <span class="variable">&lt;div&gt;</span>useReducer Count:&#123;<span class="keyword">state</span>.count&#125;&lt;/div&gt;</span><br><span class="line">      <span class="variable">&lt;button onClick=&#123;() =&gt;</span> &#123; dispatch(&#123; type: 'decrement' &#125;); &#125;&#125;&gt;useReducer 减少&lt;/button&gt;</span><br><span class="line">      <span class="variable">&lt;button onClick=&#123;() =&gt;</span> &#123; dispatch(&#123; type: 'increment' &#125;); &#125;&#125;&gt;useReducer 增加&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> UseReducer;</span><br></pre></td></tr></table></figure><h3 id="2、惰性初始化-state"><a href="#2、惰性初始化-state" class="headerlink" title="2、惰性初始化 state"></a>2、惰性初始化 state</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">interface stateType &#123;</span><br><span class="line">  count: number</span><br><span class="line">&#125;</span><br><span class="line">interface actionType &#123;</span><br><span class="line">  type: string,</span><br><span class="line">  paylod?: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initCount =<span class="number">0</span> </span><br><span class="line"><span class="keyword">const</span> init = <span class="function">(<span class="params">initCount:number</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>:initCount&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state:stateType, action:actionType</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.paylod || <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UseReducer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer,initCount,init)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;useReducer Count:&#123;state.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;()=&gt;&#123;dispatch(&#123;type:'decrement'&#125;)&#125;&#125;&gt;useReducer 减少&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;()=&gt;&#123;dispatch(&#123;<span class="attr">type</span>:<span class="string">'increment'</span>&#125;)&#125;&#125;&gt;useReducer 增加&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;()=&gt;&#123;dispatch(&#123;type:'reset',paylod:10 &#125;)&#125;&#125;&gt;useReducer 增加&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default UseReducer;</span></span><br></pre></td></tr></table></figure><h2 id="五、Memo"><a href="#五、Memo" class="headerlink" title="五、Memo"></a>五、Memo</h2><p>如下所示，当父组件重新渲染时，子组件也会重新渲染，即使子组件的 props 和 state 都没有改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; memo, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> ChildComp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ChildComp...'</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ChildComp...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;hello world &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div onClick=&#123;() =&gt; &#123; setCount(count =&gt; count + 1); &#125;&#125;&gt;点击增加&lt;/</span>div&gt;</span><br><span class="line">      &lt;ChildComp/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Parent;</span></span><br></pre></td></tr></table></figure><p>改进：我们可以使用 memo 包一层，就能解决上面的问题；但是仅仅解决父组件没有传参给子组件的情况以及父组件传简单类型的参数给子组件的情况（例如 string、number、boolean等）；如果有传复杂属性应该使用 useCallback（回调事件）或者 useMemo（复杂属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> ChildComp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ChildComp...'</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ChildComp...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoChildComp = memo(ChildComp);</span><br></pre></td></tr></table></figure><h2 id="六、useMemo"><a href="#六、useMemo" class="headerlink" title="六、useMemo"></a>六、useMemo</h2><p>假设以下场景，父组件在调用子组件时传递 info 对象属性，点击父组件按钮时，发现控制台会打印出子组件被渲染的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; memo, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> ChildComp = <span class="function">(<span class="params">info:&#123;info:&#123;name: string, age: number&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ChildComp...'</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ChildComp...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoChildComp = memo(ChildComp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name] = useState(<span class="string">'jack'</span>);</span><br><span class="line">  <span class="keyword">const</span> [age] = useState(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">const</span> info = &#123; name, age &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;hello world &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div onClick=&#123;() =&gt; &#123; setCount(count =&gt; count + 1); &#125;&#125;&gt;点击增加&lt;/</span>div&gt;</span><br><span class="line">      &lt;MemoChildComp info=&#123;info&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Parent;</span></span><br></pre></td></tr></table></figure><p><strong>分析原因：</strong></p><p>点击父组件按钮，触发父组件重新渲染；父组件渲染，const info = { name, age } 一行会重新生成一个新对象，导致传递给子组件的 info 属性值变化，进而导致子组件重新渲染。</p><p><strong>解决：</strong></p><p>使用 useMemo 将对象属性包一层，useMemo 有两个参数：</p><ul><li>第一个参数是个函数，返回的对象指向同一个引用，不会创建新对象；</li><li>第二个参数是个数组，只有数组中的变量改变时，第一个参数的函数才会返回一个新的对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; memo, useMemo, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> ChildComp = <span class="function">(<span class="params">info:&#123;info:&#123;name: string, age: number&#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ChildComp...'</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ChildComp...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoChildComp = memo(ChildComp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name] = useState(<span class="string">'jack'</span>);</span><br><span class="line">  <span class="keyword">const</span> [age] = useState(<span class="number">11</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 使用 useMemo 将对象属性包一层</span></span><br><span class="line">  <span class="keyword">const</span> info = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; name, age &#125;), [name, age]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;hello world &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div onClick=&#123;() =&gt; &#123; setCount(count =&gt; count + 1); &#125;&#125;&gt;点击增加&lt;/</span>div&gt;</span><br><span class="line">      &lt;MemoChildComp info=&#123;info&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Parent;</span></span><br></pre></td></tr></table></figure><h2 id="七-、useCallback"><a href="#七-、useCallback" class="headerlink" title="七 、useCallback"></a>七 、useCallback</h2><p>接着第六章节的例子，假设需要将事件传给子组件，如下所示，当点击父组件按钮时，发现控制台会打印出子组件被渲染的信息，说明子组件又被重新渲染了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; memo, useMemo, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> ChildComp = <span class="function">(<span class="params">props:any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ChildComp...'</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ChildComp...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoChildComp = memo(ChildComp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name] = useState(<span class="string">'jack'</span>);</span><br><span class="line">  <span class="keyword">const</span> [age] = useState(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">const</span> info = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; name, age &#125;), [name, age]);</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'输出名称...'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;hello world &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div onClick=&#123;() =&gt; &#123; setCount(count =&gt; count + 1); &#125;&#125;&gt;点击增加&lt;/</span>div&gt;</span><br><span class="line">      &lt;MemoChildComp info=&#123;info&#125; changeName=&#123;changeName&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Parent;</span></span><br></pre></td></tr></table></figure><p><strong>分析下原因：</strong></p><p>点击父组件按钮，改变了父组件中 count 变量值（父组件的 state 值），进而导致父组件重新渲染；父组件重新渲染时，会重新创建 changeName 函数，即传给子组件的 changeName 属性发生了变化，导致子组件渲染；</p><p><strong>解决</strong></p><p>修改父组件的 changeName 方法，用 useCallback 钩子函数包裹一层， useCallback 参数与 useMemo 类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; memo, useCallback, useMemo, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">const</span> ChildComp = <span class="function">(<span class="params">props:any</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ChildComp...'</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>ChildComp...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoChildComp = memo(ChildComp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> Parent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name] = useState(<span class="string">'jack'</span>);</span><br><span class="line">  <span class="keyword">const</span> [age] = useState(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">const</span> info = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123; name, age &#125;), [name, age]);</span><br><span class="line">  <span class="keyword">const</span> changeName = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'输出名称...'</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;div&gt;hello world &#123;count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div onClick=&#123;() =&gt; &#123; setCount(count =&gt; count + 1); &#125;&#125;&gt;点击增加&lt;/</span>div&gt;</span><br><span class="line">      &lt;MemoChildComp info=&#123;info&#125; changeName=&#123;changeName&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Parent;</span></span><br></pre></td></tr></table></figure><h2 id="八、useRef"><a href="#八、useRef" class="headerlink" title="八、useRef"></a>八、useRef</h2><p>以下分别介绍 useRef 的两个使用场景：</p><p><strong>1、指向 dom 元素</strong></p><p>如下所示，使用 useRef 创建的变量指向一个 input 元素，并在页面渲染后使 input 聚焦</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> Page1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> myRef = useRef&lt;HTMLInputElement&gt;(<span class="literal">null</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    myRef?.current?.focus();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;UseRef:<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">      &lt;input ref=&#123;myRef&#125; type=<span class="string">"text"</span>/&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Page1;</span></span><br></pre></td></tr></table></figure><p><strong>2、存放变量</strong></p><p>useRef 在 react hook 中的作用, 正如官网说的, 它像一个变量, 类似于 this , 它就像一个盒子, 你可以存放任何东西. createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用，如下例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, useEffect, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> Page1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> myRef2 = useRef(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      myRef2.current = count;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count); <span class="comment">// 3</span></span><br><span class="line">        <span class="built_in">console</span>.log(myRef2.current); <span class="comment">// 6</span></span><br><span class="line">      &#125;,<span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div onClick=&#123;()=&gt; setCount(count+<span class="number">1</span>)&#125;&gt;点击count&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div onClick=&#123;()=&gt; handleClick()&#125;&gt;查看&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Page1;</span></span><br></pre></td></tr></table></figure><h2 id="九、useImperativeHandle"><a href="#九、useImperativeHandle" class="headerlink" title="九、useImperativeHandle"></a>九、useImperativeHandle</h2><p>使用场景：通过 ref 获取到的是整个 dom 节点，通过 useImperativeHandle 可以控制只暴露一部分方法和属性，而不是整个 dom 节点。</p><h2 id="十、useLayoutEffect"><a href="#十、useLayoutEffect" class="headerlink" title="十、useLayoutEffect"></a>十、useLayoutEffect</h2><p>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect，这里不再举例。</p><p>useLayoutEffect 和平常写的 Class 组件的 componentDidMount 和 componentDidUpdate 同时执行；</p><p>useEffect 会在本次更新完成后，也就是第 1 点的方法执行完成后，再开启一次任务调度，在下次任务调度中执行 useEffect；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于这方面的文章，我们根据使用场景分别进行举例说明，希望有帮助到你认识理解并可以熟练运用 React Hooks 大部分特性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;React 在 v16.8 的版本中推出
      
    
    </summary>
    
      <category term="react" scheme="https://chongdee.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://chongdee.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>reduce_25种高级用法</title>
    <link href="https://chongdee.github.io/2021/07/20/JavaScript/reduce_25%E7%A7%8D%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>https://chongdee.github.io/2021/07/20/JavaScript/reduce_25种高级用法/</id>
    <published>2021-07-20T15:40:35.516Z</published>
    <updated>2021-07-20T15:41:38.251Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>reduce作为ES5新增的常规数组方法之一，对比forEach、filter和map，在实际使用上好像有些被忽略，发现身边的人极少使用它，导致这个如此强大的方法被逐渐埋没。<br>如果经常使用reduce，怎么可能放过如此好用的它呢！我还是得把他从尘土中取出来擦干净，奉上它的高级用法给大家。一个如此好用的方法不应该被大众埋没。</p><p>下面对reduce的语法进行简单说明</p><ul><li>定义：对数组中的每个元素执行一个自定义的累计器，将其结果汇总为单个返回值</li><li>形式：array.reduce((t, v, i, a) =&gt; {}, initValue)</li><li><p>参数</p><ul><li>callback：回调函数(必选)</li><li>initValue：初始值(可选)</li></ul></li><li><p>回调函数的参数</p><ul><li>total(t)：累计器完成计算的返回值(必选)</li><li>value(v)：当前元素(必选)</li><li>index(i)：当前元素的索引(可选)</li><li>array(a)：当前元素所属的数组对象(可选)</li></ul></li><li><p>过程</p><ul><li>以t作为累计结果的初始值，不设置t则以数组第一个元素为初始值</li><li>开始遍历，使用累计器处理v，将v的映射结果累计到t上，结束此次循环，返回t</li><li>进入下一次循环，重复上述操作，直至数组最后一个元素</li><li>结束遍历，返回最终的t</li></ul></li></ul><p>reduce的精华所在是将累计器逐个作用于数组成员上，把上一次输出的值作为下一次输入的值。下面举个简单的栗子，看看reduce的计算结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> b = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>reduce实质上是一个累计器函数，通过用户自定义的累计器对数组成员进行自定义累计，得出一个由累计器生成的值。另外reduce还有一个胞弟reduceRight，两个方法的功能其实是一样的，只不过reduce是升序执行，reduceRight是降序执行。</p><blockquote><p>对空数组调用reduce()和reduceRight()是不会执行其回调函数的，可认为reduce()对空数组无效</p></blockquote><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>单凭以上一个简单栗子不足以说明reduce是个什么。为了展示reduce的魅力，我为大家提供25种场景来应用reduce的高级用法。有部分高级用法可能需要结合其他方法来实现，这样为reduce的多元化提供了更多的可能性。</p><blockquote><p>部分示例代码的写法可能有些骚，看得不习惯可自行整理成自己的习惯写法</p></blockquote><h2 id="累加累乘"><a href="#累加累乘" class="headerlink" title="累加累乘"></a>累加累乘</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Accumulation</span><span class="params">(<span class="rest_arg">...vals</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vals.reduce((t, v) =&gt; t + v, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Multiplication</span><span class="params">(<span class="rest_arg">...vals</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vals.reduce((t, v) =&gt; t * v, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Accumulation(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 15</span></span><br><span class="line">Multiplication(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><h2 id="权重求和"><a href="#权重求和" class="headerlink" title="权重求和"></a>权重求和</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">scores </span>= [</span><br><span class="line">    &#123; <span class="keyword">score: </span><span class="number">90</span>, <span class="keyword">subject: </span><span class="string">"chinese"</span>, weight: <span class="number">0</span>.<span class="number">5</span> &#125;,</span><br><span class="line">    &#123; <span class="keyword">score: </span><span class="number">95</span>, <span class="keyword">subject: </span><span class="string">"math"</span>, weight: <span class="number">0</span>.<span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="keyword">score: </span><span class="number">85</span>, <span class="keyword">subject: </span><span class="string">"english"</span>, weight: <span class="number">0</span>.<span class="number">2</span> &#125;</span><br><span class="line">]<span class="comment">;</span></span><br><span class="line">const result = <span class="keyword">scores.reduce((t, </span>v) =&gt; t + v.<span class="keyword">score </span>* v.weight, <span class="number">0</span>)<span class="comment">; // 90.5</span></span><br></pre></td></tr></table></figure><h2 id="代替reverse"><a href="#代替reverse" class="headerlink" title="代替reverse"></a>代替reverse</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Reverse</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduceRight(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (t.push(v), t), []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><h2 id="代替map和filter"><a href="#代替map和filter" class="headerlink" title="代替map和filter"></a>代替map和filter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替map：[0, 2, 4, 6]</span></span><br><span class="line"><span class="keyword">const</span> a = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> b = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> [...t, v * <span class="number">2</span>], []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替filter：[2, 3]</span></span><br><span class="line"><span class="keyword">const</span> c = arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> d = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> v &gt; <span class="number">1</span> ? [...t, v] : t, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替map和filter：[4, 6]</span></span><br><span class="line"><span class="keyword">const</span> e = arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> f = arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> v * <span class="number">2</span> &gt; <span class="number">2</span> ? [...t, v * <span class="number">2</span>] : t, []);</span><br></pre></td></tr></table></figure><h2 id="代替some和every"><a href="#代替some和every" class="headerlink" title="代替some和every"></a>代替some和every</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scores = [</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">45</span>, <span class="attr">subject</span>: <span class="string">"chinese"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">90</span>, <span class="attr">subject</span>: <span class="string">"math"</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">score</span>: <span class="number">60</span>, <span class="attr">subject</span>: <span class="string">"english"</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替some：至少一门合格</span></span><br><span class="line"><span class="keyword">const</span> isAtLeastOneQualified = scores.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t || v.score &gt;= <span class="number">60</span>, <span class="literal">false</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代替every：全部合格</span></span><br><span class="line"><span class="keyword">const</span> isAllQualified = scores.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &amp;&amp; v.score &gt;= <span class="number">60</span>, <span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="数组分割"><a href="#数组分割" class="headerlink" title="数组分割"></a>数组分割</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// size分割份数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chunk</span><span class="params">(arr = [], size = 1)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.length ? arr.reduce((t, v) =&gt; (t[t.length - <span class="number">1</span>].length === size ? t.push([v]) : t[t.length - <span class="number">1</span>].push(v), t), <span class="string">[[]]</span>) : [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">Chunk(arr, <span class="number">2</span>); // <span class="string">[[1, 2], [3, 4], [5]]</span></span><br></pre></td></tr></table></figure><h2 id="数组过滤"><a href="#数组过滤" class="headerlink" title="数组过滤"></a>数组过滤</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Difference</span>(<span class="params">arr = [], oarr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (!oarr.includes(v) &amp;&amp; t.push(v), t), []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line">Difference(arr1, arr2); <span class="comment">// [1, 4, 5]</span></span><br></pre></td></tr></table></figure><h2 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Fill(arr = [], val = <span class="string">""</span>, start = <span class="number">0</span>, <span class="keyword">end</span> = arr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> <span class="params">||</span> start &gt;= <span class="keyword">end</span> <span class="params">||</span> <span class="keyword">end</span> &gt; arr.length) <span class="keyword">return</span> arr;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        ...arr.slice(<span class="number">0</span>, start),</span><br><span class="line">        ...arr.slice(start, <span class="keyword">end</span>).reduce((t, v) =&gt; (t.push(val <span class="params">||</span> v), t), []),</span><br><span class="line">        ...arr.slice(<span class="keyword">end</span>, arr.length)</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">Fill(arr, <span class="string">"aaa"</span>, <span class="number">2</span>, <span class="number">5</span>); <span class="regexp">//</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="string">"aaa"</span>, <span class="string">"aaa"</span>, <span class="string">"aaa"</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h2 id="数组扁平"><a href="#数组扁平" class="headerlink" title="数组扁平"></a>数组扁平</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Flat(arr = <span class="comment">[]</span>) &#123;</span><br><span class="line">    return arr.reduce((t, v) =&gt; t.concat(Array.isArray(v) ? Flat(v) : v), <span class="comment">[]</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = <span class="comment">[0, 1, <span class="comment">[2, 3]</span>, <span class="comment">[4, 5, <span class="comment">[6, 7]</span>]</span>, <span class="comment">[8, <span class="comment">[9, 10, <span class="comment">[11, 12]</span>]</span>]</span>]</span>;</span><br><span class="line">Flat(arr); // <span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br></pre></td></tr></table></figure><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Unique</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t.includes(v) ? t : [...t, v], []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">Unique(arr); <span class="comment">// [2, 1, 0, 3]</span></span><br></pre></td></tr></table></figure><h2 id="数组最大最小值"><a href="#数组最大最小值" class="headerlink" title="数组最大最小值"></a>数组最大最小值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Max</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &gt; v ? t : v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Min</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t &lt; v ? t : v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">12</span>, <span class="number">45</span>, <span class="number">21</span>, <span class="number">65</span>, <span class="number">38</span>, <span class="number">76</span>, <span class="number">108</span>, <span class="number">43</span>];</span><br><span class="line">Max(arr); <span class="comment">// 108</span></span><br><span class="line">Min(arr); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h2 id="数组成员独立拆解"><a href="#数组成员独立拆解" class="headerlink" title="数组成员独立拆解"></a>数组成员独立拆解</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Unzip</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(</span><br><span class="line">        (t, v) =&gt; <span class="function">(<span class="params">v.forEach((w, i</span>) =&gt;</span> t[i].push(w)), t),</span><br><span class="line">        <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="built_in">Math</span>.max(...arr.map(<span class="function"><span class="params">v</span> =&gt;</span> v.length)) &#125;).map(<span class="function"><span class="params">v</span> =&gt;</span> [])</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="string">"a"</span>, <span class="number">1</span>, <span class="literal">true</span>], [<span class="string">"b"</span>, <span class="number">2</span>, <span class="literal">false</span>]];</span><br><span class="line">Unzip(arr); <span class="comment">// [["a", "b"], [1, 2], [true, false]]</span></span><br></pre></td></tr></table></figure><h2 id="数组成员个数统计"><a href="#数组成员个数统计" class="headerlink" title="数组成员个数统计"></a>数组成员个数统计</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Count(arr = []) &#123;</span><br><span class="line">    return arr.reduce((t, v) =&gt; (t[v] = (t[v] || <span class="number">0</span>) + <span class="number">1</span>, t), &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>];</span><br><span class="line">Count(arr); <span class="comment">// &#123; 0: 1, 1: 2, 2: 3 &#125;</span></span><br><span class="line"></span><br><span class="line">此方法是字符统计和单词统计的原理，入参时把字符串处理成数组即可</span><br></pre></td></tr></table></figure><h2 id="数组成员位置记录"><a href="#数组成员位置记录" class="headerlink" title="数组成员位置记录"></a>数组成员位置记录</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Position(arr = [], val) &#123;</span><br><span class="line">    return arr.reduce((t, v, i) =&gt; (v === val &amp;&amp; t.push(i), t), []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">Position(arr, <span class="number">2</span>); <span class="comment">// [0, 4]</span></span><br></pre></td></tr></table></figure><h2 id="数组成员特性分组"><a href="#数组成员特性分组" class="headerlink" title="数组成员特性分组"></a>数组成员特性分组</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Group(arr = [], key) &#123;</span><br><span class="line">    <span class="keyword">return</span> key ? arr.reduce((t, v) =&gt; (!t[v[key]] &amp;&amp; (t[v[key]] = []), t[v[key]].push(v), t), &#123;&#125;) : &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [</span><br><span class="line">    &#123; <span class="string">area:</span> <span class="string">"GZ"</span>, <span class="string">name:</span> <span class="string">"YZW"</span>, <span class="string">age:</span> <span class="number">27</span> &#125;,</span><br><span class="line">    &#123; <span class="string">area:</span> <span class="string">"GZ"</span>, <span class="string">name:</span> <span class="string">"TYJ"</span>, <span class="string">age:</span> <span class="number">25</span> &#125;,</span><br><span class="line">    &#123; <span class="string">area:</span> <span class="string">"SZ"</span>, <span class="string">name:</span> <span class="string">"AAA"</span>, <span class="string">age:</span> <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="string">area:</span> <span class="string">"FS"</span>, <span class="string">name:</span> <span class="string">"BBB"</span>, <span class="string">age:</span> <span class="number">21</span> &#125;,</span><br><span class="line">    &#123; <span class="string">area:</span> <span class="string">"SZ"</span>, <span class="string">name:</span> <span class="string">"CCC"</span>, <span class="string">age:</span> <span class="number">19</span> &#125;</span><br><span class="line">]; <span class="comment">// 以地区area作为分组依据</span></span><br><span class="line">Group(arr, <span class="string">"area"</span>); <span class="comment">// &#123; GZ: Array(2), SZ: Array(2), FS: Array(1) &#125;</span></span><br></pre></td></tr></table></figure><h2 id="数组成员所含关键字"><a href="#数组成员所含关键字" class="headerlink" title="数组成员所含关键字"></a>数组成员所含关键字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Keyword</span>(<span class="params">arr = [], keys = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> keys.reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (arr.some(<span class="function"><span class="params">w</span> =&gt;</span> w.includes(v)) &amp;&amp; t.push(v), t), []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = [</span><br><span class="line">    <span class="string">"今天天气真好，我想出去钓鱼"</span>,</span><br><span class="line">    <span class="string">"我一边看电视，一边写作业"</span>,</span><br><span class="line">    <span class="string">"小明喜欢同桌的小红，又喜欢后桌的小君，真TM花心"</span>,</span><br><span class="line">    <span class="string">"最近上班喜欢摸鱼的人实在太多了，代码不好好写，在想入非非"</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> keyword = [<span class="string">"偷懒"</span>, <span class="string">"喜欢"</span>, <span class="string">"睡觉"</span>, <span class="string">"摸鱼"</span>, <span class="string">"真好"</span>, <span class="string">"一边"</span>, <span class="string">"明天"</span>];</span><br><span class="line">Keyword(text, keyword); <span class="comment">// ["喜欢", "摸鱼", "真好", "一边"]</span></span><br></pre></td></tr></table></figure><h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReverseStr</span>(<span class="params">str = <span class="string">""</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">""</span>).reduceRight(<span class="function">(<span class="params">t, v</span>) =&gt;</span> t + v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"reduce最牛逼"</span>;</span><br><span class="line">ReverseStr(str); <span class="comment">// "逼牛最ecuder"</span></span><br></pre></td></tr></table></figure><h2 id="数字千分化"><a href="#数字千分化" class="headerlink" title="数字千分化"></a>数字千分化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThousandNum</span>(<span class="params">num = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> str = (+num).toString().split(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">const</span> int = <span class="function"><span class="params">nums</span> =&gt;</span> nums.split(<span class="string">""</span>).reverse().reduceRight(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> t + (i % <span class="number">3</span> ? v : <span class="string">`<span class="subst">$&#123;v&#125;</span>,`</span>), <span class="string">""</span>).replace(<span class="regexp">/^,|,$/g</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">const</span> dec = <span class="function"><span class="params">nums</span> =&gt;</span> nums.split(<span class="string">""</span>).reduce(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> t + ((i + <span class="number">1</span>) % <span class="number">3</span> ? v : <span class="string">`<span class="subst">$&#123;v&#125;</span>,`</span>), <span class="string">""</span>).replace(<span class="regexp">/^,|,$/g</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> str.length &gt; <span class="number">1</span> ? <span class="string">`<span class="subst">$&#123;int(str[<span class="number">0</span>])&#125;</span>.<span class="subst">$&#123;dec(str[<span class="number">1</span>])&#125;</span>`</span> : int(str[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThousandNum(<span class="number">1234</span>); <span class="comment">// "1,234"</span></span><br><span class="line">ThousandNum(<span class="number">1234.00</span>); <span class="comment">// "1,234"</span></span><br><span class="line">ThousandNum(<span class="number">0.1234</span>); <span class="comment">// "0.123,4"</span></span><br><span class="line">ThousandNum(<span class="number">1234.5678</span>); <span class="comment">// "1,234.567,8"</span></span><br></pre></td></tr></table></figure><h2 id="异步累计"><a href="#异步累计" class="headerlink" title="异步累计"></a>异步累计</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">AsyncTotal</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="keyword">async</span>(t, v) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> at = <span class="keyword">await</span> t;</span><br><span class="line">        <span class="keyword">const</span> todo = <span class="keyword">await</span> Todo(v);</span><br><span class="line">        at[v] = todo;</span><br><span class="line">        <span class="keyword">return</span> at;</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve(&#123;&#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> AsyncTotal(); <span class="comment">// 需要在async包围下使用</span></span><br></pre></td></tr></table></figure><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">len = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [...new <span class="built_in">Array</span>(len).keys()];</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">t, v, i</span>) =&gt;</span> (i &gt; <span class="number">1</span> &amp;&amp; t.push(t[i - <span class="number">1</span>] + t[i - <span class="number">2</span>]), t), [<span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci(<span class="number">10</span>); <span class="comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure><h2 id="URL参数反序列化"><a href="#URL参数反序列化" class="headerlink" title="URL参数反序列化"></a>URL参数反序列化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParseUrlSearch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> location.search.replace(<span class="regexp">/(^\?)|(&amp;$)/g</span>, <span class="string">""</span>).split(<span class="string">"&amp;"</span>).reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [key, val] = v.split(<span class="string">"="</span>);</span><br><span class="line">        t[key] = <span class="built_in">decodeURIComponent</span>(val);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设URL为：https://www.baidu.com?age=25&amp;name=TYJ</span></span><br><span class="line">ParseUrlSearch(); <span class="comment">// &#123; age: "25", name: "TYJ" &#125;</span></span><br></pre></td></tr></table></figure><h2 id="URL参数序列化"><a href="#URL参数序列化" class="headerlink" title="URL参数序列化"></a>URL参数序列化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringifyUrlSearch</span>(<span class="params">search = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.entries(search).reduce(</span><br><span class="line">        (t, v) =&gt; <span class="string">`<span class="subst">$&#123;t&#125;</span><span class="subst">$&#123;v[<span class="number">0</span>]&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(v[<span class="number">1</span>])&#125;</span>&amp;`</span>,</span><br><span class="line">        <span class="built_in">Object</span>.keys(search).length ? <span class="string">"?"</span> : <span class="string">""</span></span><br><span class="line">    ).replace(<span class="regexp">/&amp;$/</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringifyUrlSearch(&#123; <span class="attr">age</span>: <span class="number">27</span>, <span class="attr">name</span>: <span class="string">"YZW"</span> &#125;); <span class="comment">// "?age=27&amp;name=YZW"</span></span><br></pre></td></tr></table></figure><h2 id="返回对象指定键值"><a href="#返回对象指定键值" class="headerlink" title="返回对象指定键值"></a>返回对象指定键值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetKeys</span>(<span class="params">obj = &#123;&#125;, keys = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).reduce(<span class="function">(<span class="params">t, v</span>) =&gt;</span> (keys.includes(v) &amp;&amp; (t[v] = obj[v]), t), &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> keyword = [<span class="string">"a"</span>, <span class="string">"d"</span>];</span><br><span class="line">GetKeys(target, keyword); <span class="comment">// &#123; a: 1, d: 4 &#125;</span></span><br></pre></td></tr></table></figure><h2 id="数组转对象"><a href="#数组转对象" class="headerlink" title="数组转对象"></a>数组转对象</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const people = [</span><br><span class="line">    &#123; area: <span class="string">"GZ"</span>, name: <span class="string">"YZW"</span>, age: <span class="number">27</span> &#125;,</span><br><span class="line">    &#123; area: <span class="string">"SZ"</span>, name: <span class="string">"TYJ"</span>, age: <span class="number">25</span> &#125;</span><br><span class="line">];</span><br><span class="line">const <span class="keyword">map</span> = people.reduce((t, v) =&gt; &#123;</span><br><span class="line">    const &#123; name, ...rest &#125; = v;</span><br><span class="line">    t[name] = rest;</span><br><span class="line">    return t;</span><br><span class="line">&#125;, &#123;&#125;); // &#123; YZW: &#123;…&#125;, TYJ: &#123;…&#125; &#125;</span><br></pre></td></tr></table></figure><h2 id="Redux-Compose函数原理"><a href="#Redux-Compose函数原理" class="headerlink" title="Redux Compose函数原理"></a>Redux Compose函数原理</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compose</span><span class="params">(<span class="rest_arg">...funs</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arg =&gt; arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (funs.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funs.reduce((t, v) =&gt; (...arg) =&gt; t(v(...arg)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="兼容和性能"><a href="#兼容和性能" class="headerlink" title="兼容和性能"></a>兼容和性能</h2><p>好用是挺好用的，但是兼容性如何呢？在Caniuse上搜索一番，兼容性绝对的好，可大胆在任何项目上使用。不要吝啬你的想象力，尽情发挥reduce的compose技能啦。对于时常做一些累计的功能，reduce绝对是首选方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;reduce作为ES5新增的常规数组方法
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://chongdee.github.io/categories/JavaScript/"/>
    
      <category term="es6" scheme="https://chongdee.github.io/categories/JavaScript/es6/"/>
    
    
      <category term="JavaScript" scheme="https://chongdee.github.io/tags/JavaScript/"/>
    
      <category term="es6" scheme="https://chongdee.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>路由权限,大文件下载等问题</title>
    <link href="https://chongdee.github.io/2021/07/20/vue/%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90,%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%AD%89%E9%97%AE%E9%A2%98/"/>
    <id>https://chongdee.github.io/2021/07/20/vue/路由权限,大文件下载等问题/</id>
    <published>2021-07-20T10:56:22.185Z</published>
    <updated>2021-05-08T19:16:25.784Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>有一些问题不限于 Vue，还适应于其他类型的 SPA 项目。</p><h2 id="1-页面权限控制和登陆验证"><a href="#1-页面权限控制和登陆验证" class="headerlink" title="1. 页面权限控制和登陆验证"></a>1. 页面权限控制和登陆验证</h2><h3 id="页面权限控制"><a href="#页面权限控制" class="headerlink" title="页面权限控制"></a>页面权限控制</h3><p>页面权限控制是什么意思呢？</p><p>就是一个网站有不同的角色，比如管理员和普通用户，要求不同的角色能访问的页面是不一样的。如果一个页面，有角色越权访问，这时就得做出限制了。<br><a id="more"></a><br>一种方法是通过动态添加路由和菜单来做控制，不能访问的页面不添加到路由表里，这是其中一种办法。具体细节请看下一节的《动态菜单》。</p><p>另一种办法就是所有的页面都在路由表里，只是在访问的时候要判断一下角色权限。如果有权限就允许访问，没有权限就拒绝，跳转到 404 页面。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在每一个路由的 meta 属性里，将能访问该路由的角色添加到 roles 里。用户每次登陆后，将用户的角色返回。然后在访问页面时，把路由的 meta 属性和用户的角色进行对比，如果用户的角色在路由的 roles 里，那就是能访问，如果不在就拒绝访问。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>路由信息</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        name: <span class="string">'login'</span>,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            roles: [<span class="string">'admin'</span>, <span class="string">'user'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Login.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'home'</span>,</span><br><span class="line">        name: <span class="string">'home'</span>,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            roles: [<span class="string">'admin'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>页面控制</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设角色有两种：admin 和 user</span></span><br><span class="line"><span class="comment">// 这里是从后台获取的用户角色</span></span><br><span class="line">const role = <span class="string">'user'</span></span><br><span class="line"><span class="comment">// 在进入一个页面前会触发 router.beforeEach 事件</span></span><br><span class="line">router.beforeEach((to, <span class="keyword">from</span>, <span class="keyword">next</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.meta.roles.<span class="keyword">includes</span>(role)) &#123;</span><br><span class="line">        <span class="keyword">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>(&#123;path: <span class="string">'/404'</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>登陆验证<br>网站一般只要登陆过一次后，接下来该网站的其他页面都是可以直接访问的，不用再次登陆。我们可以通过 token 或 cookie 来实现，下面用代码来展示一下如何用 token 控制登陆验证。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, <span class="built_in">next</span>) =&gt; &#123;</span><br><span class="line">    // 如果有token 说明该用户已登陆</span><br><span class="line">    <span class="keyword">if</span> (localStorage.getItem(<span class="string">'token'</span>)) &#123;</span><br><span class="line">        // 在已登陆的情况下访问登陆页会重定向到首页</span><br><span class="line">        <span class="keyword">if</span> (to.<span class="built_in">path</span> === <span class="string">'/login'</span>) &#123;</span><br><span class="line">            <span class="built_in">next</span>(&#123;<span class="built_in">path</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">next</span>(&#123;<span class="built_in">path</span>: to.<span class="built_in">path</span> || <span class="string">'/'</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 没有登陆则访问任何页面都重定向到登陆页</span><br><span class="line">        <span class="keyword">if</span> (to.<span class="built_in">path</span> === <span class="string">'/login'</span>) &#123;</span><br><span class="line">            <span class="built_in">next</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">next</span>(`/login?redirect=$&#123;to.<span class="built_in">path</span>&#125;`)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-动态菜单"><a href="#2-动态菜单" class="headerlink" title="2. 动态菜单"></a>2. 动态菜单</h2><p>写后台管理系统，估计有不少人遇过这样的需求：根据后台数据动态添加路由和菜单。为什么这么做呢？因为不同的用户有不同的权限，能访问的页面是不一样的。</p><h3 id="动态添加路由"><a href="#动态添加路由" class="headerlink" title="动态添加路由"></a>动态添加路由</h3><p>利用 vue-router 的 addRoutes 方法可以动态添加路由。</p><p>先看一下官方介绍：</p><p><strong>router.addRoutes</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">router</span><span class="selector-class">.addRoutes</span>(<span class="attribute">routes</span>: Array&lt;RouteConfig&gt;)</span><br></pre></td></tr></table></figure><p>动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。</p><p>举个例子：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/login'</span>,</span><br><span class="line">            name: <span class="string">'login'</span>,</span><br><span class="line">            component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Login.vue'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;path: <span class="string">'/'</span>, redirect: <span class="string">'/home'</span>&#125;,</span><br><span class="line">    ]   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码和下面的代码效果是一样的</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;path: <span class="string">'/'</span>, redirect: <span class="string">'/home'</span>&#125;,</span><br><span class="line">    ]   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.addRoutes([</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        name: <span class="string">'login'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Login.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>在动态添加路由的过程中，如果有 404 页面，一定要放在最后添加，否则在登陆的时候添加完页面会重定向到 404 页面。</p><p>类似于这样，这种规则一定要最后添加。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attribute">path</span>: <span class="string">'*'</span>, redirect: <span class="string">'/404'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="动态生成菜单"><a href="#动态生成菜单" class="headerlink" title="动态生成菜单"></a>动态生成菜单</h3><p>假设后台返回来的数据长这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左侧菜单栏数据</span></span><br><span class="line"><span class="attribute">menuItems</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">name</span>: <span class="string">'home'</span>, <span class="comment">// 要跳转的路由名称 不是路径</span></span><br><span class="line">        <span class="attribute">size</span>: <span class="number">18</span>, <span class="comment">// icon大小</span></span><br><span class="line">        <span class="attribute">type</span>: <span class="string">'md-home'</span>, <span class="comment">// icon类型</span></span><br><span class="line">        <span class="attribute">text</span>: <span class="string">'主页'</span> <span class="comment">// 文本内容</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">text</span>: <span class="string">'二级菜单'</span>,</span><br><span class="line">        <span class="attribute">type</span>: <span class="string">'ios-paper'</span>,</span><br><span class="line">        <span class="attribute">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attribute">type</span>: <span class="string">'ios-grid'</span>,</span><br><span class="line">                <span class="attribute">name</span>: <span class="string">'t1'</span>,</span><br><span class="line">                <span class="attribute">text</span>: <span class="string">'表格'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attribute">text</span>: <span class="string">'三级菜单'</span>,</span><br><span class="line">                <span class="attribute">type</span>: <span class="string">'ios-paper'</span>,</span><br><span class="line">                <span class="attribute">children</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attribute">type</span>: <span class="string">'ios-notifications-outline'</span>,</span><br><span class="line">                        <span class="attribute">name</span>: <span class="string">'msg'</span>,</span><br><span class="line">                        <span class="attribute">text</span>: <span class="string">'查看消息'</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>来看看怎么将它转化为菜单栏，我在这里使用了 iview 的组件，不用重复造轮子。</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 菜单栏 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Menu</span> <span class="attr">ref</span>=<span class="string">"asideMenu"</span> <span class="attr">theme</span>=<span class="string">"dark"</span> <span class="attr">width</span>=<span class="string">"100%"</span> @<span class="attr">on-select</span>=<span class="string">"gotoPage"</span> </span></span></span><br><span class="line"><span class="xml">accordion :open-names="openMenus" :active-name="currentPage" @on-open-change="menuChange"&gt;</span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 动态菜单 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in menuItems"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Submenu</span> <span class="attr">v-if</span>=<span class="string">"item.children"</span> <span class="attr">:name</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"item.size"</span> <span class="attr">:type</span>=<span class="string">"item.type"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(subItem, i) in item.children"</span> <span class="attr">:key</span>=<span class="string">"index + i"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Submenu</span> <span class="attr">v-if</span>=<span class="string">"subItem.children"</span> <span class="attr">:name</span>=<span class="string">"index + '-' + i"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"subItem.size"</span> <span class="attr">:type</span>=<span class="string">"subItem.type"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;subItem.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">class</span>=<span class="string">"menu-level-3"</span> <span class="attr">v-for</span>=<span class="string">"(threeItem, k) in subItem.children"</span> <span class="attr">:name</span>=<span class="string">"threeItem.name"</span> <span class="attr">:key</span>=<span class="string">"index + i + k"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"threeItem.size"</span> <span class="attr">:type</span>=<span class="string">"threeItem.type"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;threeItem.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Submenu</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">v-else</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span> <span class="attr">:name</span>=<span class="string">"subItem.name"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"subItem.size"</span> <span class="attr">:type</span>=<span class="string">"subItem.type"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;subItem.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Submenu</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">v-else</span> <span class="attr">:name</span>=<span class="string">"item.name"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"item.size"</span> <span class="attr">:type</span>=<span class="string">"item.type"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码不用看得太仔细，理解原理即可，其实就是通过三次 v-for 不停的对子数组进行循环，生成三级菜单。</p><p>不过这个动态菜单有缺陷，就是只支持三级菜单。一个更好的做法是把生成菜单的过程封装成组件，然后递归调用，这样就能支持无限级的菜单。在生菜菜单时，需要判断一下是否还有子菜单，如果有就递归调用组件。</p><p><strong>动态路由</strong>因为上面已经说过了用 addRoutes 来实现，现在看看具体怎么做。</p><p>首先，要把项目所有的页面路由都列出来，再用后台返回来的数据动态匹配，能匹配上的就把路由加上，不能匹配上的就不加。最后把这个新生成的路由数据用 addRoutes 添加到路由表里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncRoutes = &#123;</span><br><span class="line">    <span class="string">'home'</span>: &#123;</span><br><span class="line">        path: <span class="string">'home'</span>,</span><br><span class="line">        name: <span class="string">'home'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'t1'</span>: &#123;</span><br><span class="line">        path: <span class="string">'t1'</span>,</span><br><span class="line">        name: <span class="string">'t1'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/T1.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'password'</span>: &#123;</span><br><span class="line">        path: <span class="string">'password'</span>,</span><br><span class="line">        name: <span class="string">'password'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Password.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'msg'</span>: &#123;</span><br><span class="line">        path: <span class="string">'msg'</span>,</span><br><span class="line">        name: <span class="string">'msg'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Msg.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'userinfo'</span>: &#123;</span><br><span class="line">        path: <span class="string">'userinfo'</span>,</span><br><span class="line">        name: <span class="string">'userinfo'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/UserInfo.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入后台数据 生成路由表</span></span><br><span class="line">menusToRoutes(menusData)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将菜单信息转成对应的路由信息 动态添加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">menusToRoutes</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> children = []</span><br><span class="line"></span><br><span class="line">    result.push(&#123;</span><br><span class="line">        path: <span class="string">'/'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Index.vue'</span>),</span><br><span class="line">        children,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        generateRoutes(children, item)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    children.push(&#123;</span><br><span class="line">        path: <span class="string">'error'</span>,</span><br><span class="line">        name: <span class="string">'error'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Error.vue'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后添加404页面 否则会在登陆成功后跳到404页面</span></span><br><span class="line">    result.push(</span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">redirect</span>: <span class="string">'/error'</span>&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRoutes</span>(<span class="params">children, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.name) &#123;</span><br><span class="line">        children.push(asyncRoutes[item.name])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.children) &#123;</span><br><span class="line">        item.children.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            generateRoutes(children, e)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态菜单的代码实现放在 github 上，分别放在这个项目的 src/components/Index.vue、src/permission.js 和 src/utils/index.js 文件里。</p><h2 id="3-前进刷新后退不刷新"><a href="#3-前进刷新后退不刷新" class="headerlink" title="3. 前进刷新后退不刷新"></a>3. 前进刷新后退不刷新</h2><h3 id="需求一："><a href="#需求一：" class="headerlink" title="需求一："></a>需求一：</h3><p>在一个列表页中，第一次进入的时候，请求获取数据。</p><p>点击某个列表项，跳到详情页，再从详情页后退回到列表页时，不刷新。</p><p>也就是说从其他页面进到列表页，需要刷新获取数据，从详情页返回到列表页时不要刷新。</p><p><strong>解决方案</strong></p><p>在 App.vue设置：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">keep</span>-alive <span class="keyword">include</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">    &lt;router-<span class="keyword">view</span>/&gt;</span><br><span class="line">&lt;/<span class="keyword">keep</span>-alive&gt;</span><br></pre></td></tr></table></figure><p>假设列表页为 <strong>list.vue</strong>，详情页为<strong>detail.vue</strong>，这两个都是子组件。</p><p>我们在 keep-alive 添加列表页的名字，缓存列表页。</p><p>然后在列表页的 created 函数里添加 ajax 请求，这样只有第一次进入到列表页的时候才会请求数据，当从列表页跳到详情页，再从详情页回来的时候，列表页就不会刷新。这样就可以解决问题了。</p><h3 id="需求二："><a href="#需求二：" class="headerlink" title="需求二："></a>需求二：</h3><p>在需求一的基础上，再加一个要求：可以在详情页中删除对应的列表项，这时返回到列表页时需要刷新重新获取数据。</p><p>我们可以在路由配置文件上对 detail.vue 增加一个 meta 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attribute">path</span>: <span class="string">'/detail'</span>,</span><br><span class="line">   name: <span class="string">'detail'</span>,</span><br><span class="line">   component: () =&gt; <span class="built_in">import</span>(<span class="string">'../view/detail.vue'</span>),</span><br><span class="line">   meta: &#123;isRefresh: true&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个 meta 属性，可以在详情页中通过 this.$route.meta.isRefresh 来读取和设置。</p><p>设置完这个属性，还要在 App.vue 文件里设置 watch 一下 $route 属性。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">       $route(<span class="keyword">to</span>, <span class="keyword">from</span>) &#123;</span><br><span class="line">           const fname = <span class="keyword">from</span>.<span class="built_in">name</span></span><br><span class="line">           const tname = <span class="keyword">to</span>.<span class="built_in">name</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">from</span>.meta.isRefresh || (fname != <span class="string">'detail'</span> &amp;&amp; tname == <span class="string">'list'</span>)) &#123;</span><br><span class="line">               <span class="keyword">from</span>.meta.isRefresh = <span class="literal">false</span></span><br><span class="line">       <span class="comment">// 在这里重新请求数据</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>这样就不需要在列表页的 created 函数里用 ajax 来请求数据了，统一放在 App.vue 里来处理。</p><p>触发请求数据有两个条件：</p><ol><li>从其他页面（除了详情页）进来列表时，需要请求数据。</li><li>从详情页返回到列表页时，如果详情页 meta 属性中的 isRefresh 为 true，也需要重新请求数据。</li></ol><p>当我们在详情页中删除了对应的列表项时，就可以将详情页 meta 属性中的 isRefresh 设为 true。这时再返回到列表页，页面会重新刷新。</p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>对于需求二其实还有一个更简洁的方案，那就是使用 router-view 的 key 属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:key</span>=<span class="string">"$route.fullPath"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先 keep-alive 让所有页面都缓存，当你不想缓存某个路由页面，要重新加载它时，可以在跳转时传一个随机字符串，这样它就能重新加载了。例如从列表页进入了详情页，然后在详情页中删除了列表页中的某个选项，此时从详情页退回列表页时就要刷新，我们可以这样跳转：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">    path: <span class="string">'/list'</span>,</span><br><span class="line">    query: &#123; <span class="string">'randomID'</span>: <span class="string">'id'</span> + Math.random() &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的方案相对来说还是更简洁的。</p><h2 id="4-多个请求下-loading-的展示与关闭"><a href="#4-多个请求下-loading-的展示与关闭" class="headerlink" title="4. 多个请求下 loading 的展示与关闭"></a>4. 多个请求下 loading 的展示与关闭</h2><p>一般情况下，在 vue 中结合 axios 的拦截器控制 loading 展示和关闭，是这样的：</p><p>在 App.vue 配置一个全局 loading。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;keep-alive :include=<span class="string">"keepAliveData"</span>&gt;</span><br><span class="line">        &lt;router-view/&gt;</span><br><span class="line">    &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="loading" v-show="isShowLoading"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Spin size="large"&gt;&lt;/</span>Spin&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>同时设置 axios 拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line"> <span class="keyword">this</span>.$axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">     <span class="keyword">this</span>.isShowLoading = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">return</span> config</span><br><span class="line"> &#125;, error =&gt; &#123;</span><br><span class="line">     <span class="keyword">this</span>.isShowLoading = <span class="literal">false</span></span><br><span class="line">     <span class="keyword">return</span> Promise.reject(error)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 添加响应拦截器</span></span><br><span class="line"> <span class="keyword">this</span>.$axios.interceptors.response.use(response =&gt; &#123;</span><br><span class="line">     <span class="keyword">this</span>.isShowLoading = <span class="literal">false</span></span><br><span class="line">     <span class="keyword">return</span> response</span><br><span class="line"> &#125;, error =&gt; &#123;</span><br><span class="line">     <span class="keyword">this</span>.isShowLoading = <span class="literal">false</span></span><br><span class="line">     <span class="keyword">return</span> Promise.reject(error)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>这个拦截器的功能是在请求前打开 loading，请求结束或出错时关闭 loading。</p><p>如果每次只有一个请求，这样运行是没问题的。但同时有多个请求并发，就会有问题了。</p><p><strong>举例：</strong></p><p>假如现在同时发起两个请求，在请求前，拦截器 this.isShowLoading = true 将 loading 打开。</p><p>现在有一个请求结束了。this.isShowLoading = false 拦截器关闭 loading，但是另一个请求由于某些原因并没有结束。</p><p>造成的后果就是页面请求还没完成，loading 却关闭了，用户会以为页面加载完成了，结果页面不能正常运行，导致用户体验不好。</p><p><strong>解决方案</strong></p><p>增加一个 loadingCount 变量，用来计算请求的次数。</p><p>loadingCount: 0<br>再增加两个方法，来对 loadingCount  进行增减操作。</p><pre><code>methods: {    addLoading() {        this.isShowLoading = true        this.loadingCount++    },    isCloseLoading() {        this.loadingCount--        if (this.loadingCount == 0) {            this.isShowLoading = false        }    }}</code></pre><p>现在拦截器变成这样：</p><pre><code>// 添加请求拦截器this.$axios.interceptors.request.use(config =&gt; {    this.addLoading()    return config}, error =&gt; {    this.isShowLoading = false    this.loadingCount = 0    this.$Message.error(&apos;网络异常，请稍后再试&apos;)    return Promise.reject(error)})// 添加响应拦截器this.$axios.interceptors.response.use(response =&gt; {    this.isCloseLoading()    return response}, error =&gt; {    this.isShowLoading = false    this.loadingCount = 0    this.$Message.error(&apos;网络异常，请稍后再试&apos;)    return Promise.reject(error)})</code></pre><p>这个拦截器的功能是：</p><p>每当发起一个请求，打开 loading，同时 loadingCount 加1。</p><p>每当一个请求结束， loadingCount 减1，并判断  loadingCount 是否为 0，如果为 0，则关闭 loading。</p><p>这样即可解决，多个请求下有某个请求提前结束，导致 loading 关闭的问题。</p><h2 id="5-表格打印"><a href="#5-表格打印" class="headerlink" title="5. 表格打印"></a>5. 表格打印</h2><p>打印需要用到的组件为 print-js</p><p>普通表格打印<br>一般的表格打印直接仿照组件提供的例子就可以了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">printJS</span>(&#123;</span><br><span class="line">    <span class="attribute">printable</span>: id, // DOM id</span><br><span class="line">    type: <span class="string">'html'</span>,</span><br><span class="line">    scanStyles: false,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>element-ui 表格打印（其他组件库的表格同理）<br>element-ui 的表格，表面上看起来是一个表格，实际上是由两个表格组成的。</p><p>表头为一个表格，表体又是个表格，这就导致了一个问题：打印的时候表体和表头错位。</p><p>图片</p><p>另外，在表格出现滚动条的时候，也会造成错位。</p><p>图片</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我的思路是将两个表格合成一个表格，print-js 组件打印的时候，实际上是把 id 对应的 DOM 里的内容提取出来打印。所以，在传入 id 之前，可以先把表头所在的表格内容提取出来，插入到第二个表格里，从而将两个表格合并，这时候打印就不会有错位的问题了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function printHTML(id) &#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'#'</span> + id).innerHTML</span><br><span class="line">    <span class="comment">// 新建一个 DOM</span></span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="keyword">const</span> printDOMID = <span class="string">'printDOMElement'</span></span><br><span class="line">    div.id = printDOMID</span><br><span class="line">    div.innerHTML = html</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取第一个表格的内容 即表头</span></span><br><span class="line">    <span class="keyword">const</span> ths = div.<span class="built_in">querySelectorAll</span>(<span class="string">'.el-table__header-wrapper th'</span>)</span><br><span class="line">    <span class="keyword">const</span> ThsTextArry = []</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>, len = ths.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ths[i].innerText !== <span class="string">''</span>) ThsTextArry.push(ths[i].innerText)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除多余的表头</span></span><br><span class="line">    div.<span class="built_in">querySelector</span>(<span class="string">'.hidden-columns'</span>).remove()</span><br><span class="line">    <span class="comment">// 第一个表格的内容提取出来后已经没用了 删掉</span></span><br><span class="line">    div.<span class="built_in">querySelector</span>(<span class="string">'.el-table__header-wrapper'</span>).remove()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第一个表格的内容插入到第二个表格</span></span><br><span class="line">    let newHTML = <span class="string">'&lt;tr&gt;'</span></span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>, len = ThsTextArry.length; i &lt; len; i++) &#123;</span><br><span class="line">        newHTML += <span class="string">'&lt;td style="text-align: center; font-weight: bold"&gt;'</span> + ThsTextArry[i] + <span class="string">'&lt;/td&gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newHTML += <span class="string">'&lt;/tr&gt;'</span></span><br><span class="line">    div.<span class="built_in">querySelector</span>(<span class="string">'.el-table__body-wrapper table'</span>).insertAdjacentHTML(<span class="string">'afterbegin'</span>, newHTML)</span><br><span class="line">    <span class="comment">// 将新的 DIV 添加到页面 打印后再删掉</span></span><br><span class="line">    <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'body'</span>).appendChild(div)</span><br><span class="line">    </span><br><span class="line">    printJS(&#123;</span><br><span class="line">        printable: printDOMID,</span><br><span class="line">        type: <span class="string">'html'</span>,</span><br><span class="line">        scanStyles: <span class="keyword">false</span>,</span><br><span class="line">        style: <span class="string">'table &#123; border-collapse: collapse &#125;'</span> <span class="comment">// 表格样式</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    div.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-下载二进制文件"><a href="#6-下载二进制文件" class="headerlink" title="6. 下载二进制文件"></a>6. 下载二进制文件</h2><p>平时在前端下载文件有两种方式，</p><ol><li>一种是后台提供一个 URL，然后用 window.open(URL) 下载，另一种就是后台直接返回文件的二进制内容，然后前端转化一下再下载。</li></ol><p>由于第一种方式比较简单，在此不做探讨。本文主要讲解一下第二种方式怎么实现。</p><ol><li>第二种方式需要用到 Blob 对象， mdn 文档上是这样介绍的：</li></ol><blockquote><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据<br>具体使用方法</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/export'</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设 data 是返回来的二进制数据</span></span><br><span class="line">  const data = res.data</span><br><span class="line">  const url = window<span class="selector-class">.URL</span><span class="selector-class">.createObjectURL</span>(new Blob([data], &#123;type: <span class="string">"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"</span>&#125;))</span><br><span class="line">  const link = document.createElement(<span class="string">'a'</span>)</span><br><span class="line">  link<span class="selector-class">.style</span><span class="selector-class">.display</span> = <span class="string">'none'</span></span><br><span class="line">  link<span class="selector-class">.href</span> = url</span><br><span class="line">  link.setAttribute(<span class="string">'download'</span>, <span class="string">'excel.xlsx'</span>)</span><br><span class="line">  document<span class="selector-class">.body</span><span class="selector-class">.appendChild</span>(link)</span><br><span class="line">  link.click()</span><br><span class="line">  document<span class="selector-class">.body</span><span class="selector-class">.removeChild</span>(link)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打开下载的文件，看看结果是否正确。</p><p>图片</p><p>在这里插入图片描述<br>一堆乱码…</p><p>一定有哪里不对。</p><p>最后发现是参数 responseType 的问题，responseType 它表示服务器响应的数据类型。由于后台返回来的是二进制数据，所以我们要把它设为 arraybuffer， 接下来再看看结果是否正确。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/export'</span>,</span><br><span class="line">  responseType: <span class="string">'arraybuffer'</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设 data 是返回来的二进制数据</span></span><br><span class="line">  const data = res.data</span><br><span class="line">  const url = window<span class="selector-class">.URL</span><span class="selector-class">.createObjectURL</span>(new Blob([data], &#123;type: <span class="string">"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"</span>&#125;))</span><br><span class="line">  const link = document.createElement(<span class="string">'a'</span>)</span><br><span class="line">  link<span class="selector-class">.style</span><span class="selector-class">.display</span> = <span class="string">'none'</span></span><br><span class="line">  link<span class="selector-class">.href</span> = url</span><br><span class="line">  link.setAttribute(<span class="string">'download'</span>, <span class="string">'excel.xlsx'</span>)</span><br><span class="line">  document<span class="selector-class">.body</span><span class="selector-class">.appendChild</span>(link)</span><br><span class="line">  link.click()</span><br><span class="line">  document<span class="selector-class">.body</span><span class="selector-class">.removeChild</span>(link)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>图片<br>这次没有问题，文件能正常打开，内容也是正常的，不再是乱码。</p><h3 id="根据后台接口内容决定是否下载文件"><a href="#根据后台接口内容决定是否下载文件" class="headerlink" title="根据后台接口内容决定是否下载文件"></a>根据后台接口内容决定是否下载文件</h3><p>作者的项目有大量的页面都有下载文件的需求，而且这个需求还有点变态。</p><p>具体需求如下</p><ol><li>如果下载文件的数据量条数符合要求，正常下载（每个页面限制下载数据量是不一样的，所以不能在前端写死）。</li><li>如果文件过大，后台返回 { code: 199999, msg: ‘文件过大，请重新设置查询项’, data: null }，然后前端再进行报错提示。<br>先来分析一下，首先根据上文，我们都知道下载文件的接口响应数据类型为 arraybuffer。返回的数据无论是二进制文件，还是 JSON 字符串，前端接收到的其实都是 arraybuffer。所以我们要对 arraybuffer 的内容作个判断，在接收到数据时将它转换为字符串，判断是否有 code: 199999。如果有，则报错提示，如果没有，则是正常文件，下载即可。具体实现如下：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = response.data</span><br><span class="line">    <span class="comment">// 判断响应数据类型是否 ArrayBuffer，true 则是下载文件接口，false 则是正常接口</span></span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> utf8decoder = <span class="keyword">new</span> TextDecoder()</span><br><span class="line">        <span class="keyword">const</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(res)</span><br><span class="line">        <span class="comment">// 将二进制数据转为字符串</span></span><br><span class="line">        <span class="keyword">const</span> temp = utf8decoder.decode(u8arr)</span><br><span class="line">        <span class="keyword">if</span> (temp.includes(<span class="string">'&#123;code:199999'</span>)) &#123;</span><br><span class="line">            Message(&#123;</span><br><span class="line">             <span class="comment">// 字符串转为 JSON 对象</span></span><br><span class="line">                message: <span class="built_in">JSON</span>.parse(temp).msg,</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">'error'</span>,</span><br><span class="line">                duration: <span class="number">5000</span>,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常类型接口，省略代码...</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="7-自动忽略-console-log-语句"><a href="#7-自动忽略-console-log-语句" class="headerlink" title="7. 自动忽略 console.log 语句"></a>7. 自动忽略 console.log 语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">rewirteLog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log = (<span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process.env.NODE_ENV == <span class="string">'development'</span>? log : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;(<span class="built_in">console</span>.log))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main.js 引入这个函数并执行一次，就可以实现忽略 console.log 语句的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些问题不限于 Vue，还适应于其他类型的 SPA 项目。&lt;/p&gt;
&lt;h2 id=&quot;1-页面权限控制和登陆验证&quot;&gt;&lt;a href=&quot;#1-页面权限控制和登陆验证&quot; class=&quot;headerlink&quot; title=&quot;1. 页面权限控制和登陆验证&quot;&gt;&lt;/a&gt;1. 页面权限控制和登陆验证&lt;/h2&gt;&lt;h3 id=&quot;页面权限控制&quot;&gt;&lt;a href=&quot;#页面权限控制&quot; class=&quot;headerlink&quot; title=&quot;页面权限控制&quot;&gt;&lt;/a&gt;页面权限控制&lt;/h3&gt;&lt;p&gt;页面权限控制是什么意思呢？&lt;/p&gt;
&lt;p&gt;就是一个网站有不同的角色，比如管理员和普通用户，要求不同的角色能访问的页面是不一样的。如果一个页面，有角色越权访问，这时就得做出限制了。&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="https://chongdee.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://chongdee.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue3新特性</title>
    <link href="https://chongdee.github.io/2021/07/20/vue/vue3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://chongdee.github.io/2021/07/20/vue/vue3新特性/</id>
    <published>2021-07-20T10:56:22.175Z</published>
    <updated>2021-07-20T10:18:13.584Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue3.0 在去年 9 月正式发布了，看大家都有在热情的拥抱 Vue3.0。今年初新项目也开始使用 Vue3.0 来开发，这篇文章就是在使用后的一个总结， 包含 Vue3 新特性的使用以及一些使用经验分享。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5fbebfad2b4863a8cf664843b2106e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="为什么要升级-Vue3"><a href="#为什么要升级-Vue3" class="headerlink" title="为什么要升级 Vue3"></a>为什么要升级 Vue3</h2><p>使用 Vue2.x 的小伙伴都熟悉，Vue2.x 中所有数据都是定义在<code>data</code>中，方法定义在<code>methods</code>中的，并且使用<code>this</code>来调用对应的数据和方法。那 Vue3.x 中就可以不这么玩了， 具体怎么玩我们后续再说， 先说一下 Vue2.x 版本这么写有什么缺陷，所有才会进行升级变更的。</p><h3 id="回顾-Vue2-x-实现加减"><a href="#回顾-Vue2-x-实现加减" class="headerlink" title="回顾 Vue2.x 实现加减"></a>回顾 Vue2.x 实现加减</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"homePage"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>count: </span><span class="template-variable">&#123;&#123; count &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>倍数： </span><span class="template-variable">&#123;&#123; multiple &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>        </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">"margin-right: 10px"</span> @<span class="attr">click</span>=<span class="string">"increase"</span>&gt;</span>加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"decrease"</span>&gt;</span>减一<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>      </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">export default &#123;</span></span><br><span class="line"><span class="xml">  data() &#123;</span></span><br><span class="line"><span class="xml">    return &#123; count: 0 &#125;;</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  computed: &#123;</span></span><br><span class="line"><span class="xml">    multiple() &#123;</span></span><br><span class="line"><span class="xml">      return 2 * this.count;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">  methods: &#123;</span></span><br><span class="line"><span class="xml">    increase() &#123;</span></span><br><span class="line"><span class="xml">      this.count++;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">    decrease() &#123;</span></span><br><span class="line"><span class="xml">      this.count--;</span></span><br><span class="line"><span class="xml">    &#125;,</span></span><br><span class="line"><span class="xml">  &#125;,</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>上面代码只是实现了对<code>count</code>的加减以及显示倍数， 就需要分别在 data、methods、computed 中进行操作，当我们增加一个需求，就会出现下图的情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69e4ed25e71843928c8eb480a22b5129~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>当我们业务复杂了就会大量出现上面的情况， 随着复杂度上升，就会出现这样一张图， 每个颜色的方块表示一个功能：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fed537233174d438913ba1aee9acb91~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>甚至一个功能还有会依赖其他功能，全搅合在一起。</p><p>当这个组件的代码超过几百行时，这时增加或者修改某个需求， 就要在 data、methods、computed 以及 mounted 中反复的跳转，这其中的的痛苦写过的都知道。</p><p>那我们就想啊， 如果可以按照逻辑进行分割，将上面这张图变成下边这张图，是不是就清晰很多了呢, 这样的代码可读性和可维护性都更高：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df3e8c5207c4655b296d2e9b55dd09e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>那么 vue2.x 版本给出的解决方案就是 Mixin, 但是使用 Mixin 也会遇到让人苦恼的问题：</p><ol><li>命名冲突问题</li><li>不清楚暴露出来的变量的作用</li><li>逻辑重用到其他 component 经常遇到问题</li></ol><p>关于上面经常出现的问题我就不一一举例了，使用过的小伙伴多多少少都会遇到。文章的重点不是 Mixin, 如果确实想知道的就留言啦~</p><p>所以，我们 Vue3.x 就推出了<code>Composition API</code>主要就是为了解决上面的问题，将零散分布的逻辑组合在一起来维护，并且还可以将单独的功能逻辑拆分成单独的文件。接下来我们就重点认识<code>Composition API</code>。</p><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/673d8a48ec9d4256b2c86b2918e60bbe~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup 是 Vue3.x 新增的一个选项， 他是组件内使用 <code>Composition API</code>的入口。</p><p><strong>setup 执行时机</strong></p><p>我在学习过程中看到很多文章都说 setup 是在 <code>beforeCreate</code>和<code>created</code>之间， 这个结论是错误的。实践是检验真理的唯一标准， 于是自己去检验了一下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>defineComponent(&#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    console.log(<span class="string">"----beforeCreate----"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(<span class="string">"----created----"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    console.log(<span class="string">"----setup----"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfa122fc38624892a1cfdd3efa14fdd6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>setup 执行时机是在 beforeCreate 之前执行，详细的可以看后面生命周期讲解。</p><h4 id="setup-参数"><a href="#setup-参数" class="headerlink" title="setup 参数"></a>setup 参数</h4><p>使用<code>setup</code>时，它接受两个参数：</p><ol><li>props: 组件传入的属性</li><li>context</li></ol><p>setup 中接受的<code>props</code>是响应式的， 当传入新的 props 时，会及时被更新。由于是响应式的， 所以<strong>不可以使用 ES6 解构</strong>，解构会消除它的响应式。<br><strong>错误代码示例</strong>， 这段代码会让 props 不再支持响应式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.vue</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title">defineComponent</span> <span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    setup(props, context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; name &#125; = props</span><br><span class="line">        console.<span class="built_in">log</span>(name)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那在开发中我们<strong>想要使用解构，还能保持<code>props</code>的响应式</strong>，有没有办法解决呢？大家可以思考一下，在后面<code>toRefs</code>学习的地方为大家解答。<br>接下来我们来说一下<code>setup</code>接受的第二个参数<code>context</code>，我们前面说了<code>setup</code>中不能访问 Vue2 中最常用的<code>this</code>对象，所以<code>context</code>中就提供了<code>this</code>中最常用的三个属性：<code>attrs</code>、<code>slot</code> 和<code>emit</code>，分别对应 Vue2.x 中的 <code>$attr</code>属性、<code>slot</code>插槽 和<code>$emit</code>发射事件。并且这几个属性都是自动同步最新的值，所以我们每次使用拿到的都是最新值。</p><h3 id="reactive、ref-与-toRefs"><a href="#reactive、ref-与-toRefs" class="headerlink" title="reactive、ref 与 toRefs"></a>reactive、ref 与 toRefs</h3><p>在 vue2.x 中， 定义数据都是在<code>data</code>中， 但是 Vue3.x 可以使用<code>reactive</code>和<code>ref</code>来进行数据定义。<br>那么<code>ref</code>和<code>reactive</code>他们有什么区别呢？分别什么时候使用呢？说到这里，我又不得不提一下，看到很多网上不少文章说 (<code>reactive</code>用于处理对象的双向绑定，<code>ref</code>则处理 js 基础类型的双向绑定)。我其实不太赞同这样的说法，这样很容易初学者认为<code>ref</code>就能处理 js 基本类型， 比如<code>ref</code>也是可以定义对象的双向绑定的啊， 上段代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">   const obj = ref(&#123;count:<span class="number">1</span>, name:<span class="string">"张三"</span>&#125;)</span><br><span class="line">   setTimeout(() =&gt;&#123;</span><br><span class="line">       obj<span class="selector-class">.value</span><span class="selector-class">.count</span> = obj<span class="selector-class">.value</span><span class="selector-class">.count</span> + <span class="number">1</span></span><br><span class="line">       obj<span class="selector-class">.value</span><span class="selector-class">.name</span> = <span class="string">"李四"</span></span><br><span class="line">   &#125;, <span class="number">1000</span>)</span><br><span class="line">   return&#123;</span><br><span class="line">       obj</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们将<code>obj.count</code>和<code>obj.name</code>绑定到页面上也是可以的；但是<code>reactive</code>函数确实可以代理一个对象， 但是不能代理基本类型，例如字符串、数字、boolean 等。<br>接下来使用代码展示一下<code>ref</code>、<code>reactive</code>的使用：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a824567ade0246098c7f37526585b171~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>运行效果:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64de795c3eab4878893d61025904fb4b~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>上面的代码中，我们绑定到页面是通过<code>user.name</code>,<code>user.age</code>；这样写感觉很繁琐，我们能不能直接将<code>user</code>中的属性解构出来使用呢? 答案是不能直接对<code>user</code>进行结构， 这样会消除它的响应式， 这里就和上面我们说<code>props</code>不能使用 ES6 直接解构就呼应上了。那我们就想使用解构后的数据怎么办，解决办法就是<strong>使用<code>toRefs</code></strong>。<br>toRefs 用于将一个 reactive 对象转化为属性全部为 ref 对象的普通对象。具体使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;homePage&quot;&gt;</span><br><span class="line">    &lt;p&gt;第 &#123;&#123; year &#125;&#125; 年&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;姓名： &#123;&#123; nickname &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;年龄： &#123;&#123; age &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; defineComponent, reactive, ref, toRefs &#125; from &quot;vue&quot;;</span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const year = ref(0);</span><br><span class="line">    const user = reactive(&#123; nickname: &quot;xiaofan&quot;, age: 26, gender: &quot;女&quot; &#125;);</span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      year.value++;</span><br><span class="line">      user.age++;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    return &#123;</span><br><span class="line">      year,</span><br><span class="line">      // 使用reRefs</span><br><span class="line">      ...toRefs(user),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>我们可以直接看生命周期图来认识都有哪些生命周期钩子 (图片是根据官网翻译后绘制的)：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de01e730e563406cbf3399861fa23aa4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>从图中我们可以看到 Vue3.0 新增了<code>setup</code>，这个在前面我们也详细说了， 然后是将 Vue2.x 中的<code>beforeDestroy</code>名称变更成<code>beforeUnmount</code>;<br><code>destroyed</code> 表更为 <code>unmounted</code>，</p><p>作者说这么变更纯粹是为了更加语义化，因为一个组件是一个<code>mount</code>和<code>unmount</code>的过程。</p><p>其他 Vue2 中的生命周期仍然保留。<br>上边<code>生命周期图</code>中并没包含全部的生命周期钩子， 还有其他的几个， 全部生命周期钩子如图所示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eadd1ec0ac94343951ae2453cf41fce~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>我们可以看到<code>beforeCreate</code>和<code>created</code>被<code>setup</code>替换了（但是 Vue3 中你仍然可以使用， 因为 Vue3 是向下兼容的， 也就是你实际使用的是 vue2 的）。其次，钩子命名都增加了<code>on</code>;</p><p>Vue3.x 还新增用于调试的钩子函数<code>onRenderTriggered</code>和<code>onRenderTricked</code></p><p>下面我们简单使用几个钩子， 方便大家学习如何使用，Vue3.x 中的钩子是需要从 vue 中导入的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineComponent, onBeforeMount, onMounted, onBeforeUpdate,onUpdated,</span><br><span class="line">onBeforeUnmount, onUnmounted, onErrorCaptured, onRenderTracked,</span><br><span class="line">onRenderTriggered &#125; from &quot;vue&quot;; </span><br><span class="line"></span><br><span class="line">export default defineComponent(&#123;</span><br><span class="line">//beforeCreate和created是vue2的 </span><br><span class="line">beforeCreate() &#123;</span><br><span class="line">console.log(&quot;------beforeCreate-----&quot;); &#125;,</span><br><span class="line"></span><br><span class="line">created() &#123;</span><br><span class="line">console.log(&quot;------created-----&quot;); &#125;, </span><br><span class="line"></span><br><span class="line">setup() &#123; console.log(&quot;------setup-----&quot;);</span><br><span class="line">// vue3.x生命周期写在setup中 </span><br><span class="line">onBeforeMount(() =&gt; &#123;</span><br><span class="line">console.log(&quot;------onBeforeMount-----&quot;); &#125;);</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">console.log(&quot;------onMounted-----&quot;); &#125;); // 调试哪些数据发生了变化</span><br><span class="line">onRenderTriggered((event) =&gt;&#123; console.log(&quot;------onRenderTriggered-----&quot;,event);</span><br><span class="line">&#125;) &#125;, &#125;);</span><br></pre></td></tr></table></figure><p>关于生命周期相关的内容就介绍到这里，下面我们介绍一下 Vue3.x 中<code>watch</code>有什么不同。</p><h3 id="watch-与-watchEffect-的用法"><a href="#watch-与-watchEffect-的用法" class="headerlink" title="watch 与 watchEffect 的用法"></a>watch 与 watchEffect 的用法</h3><blockquote><p>watch 函数用来侦听特定的数据源，并在回调函数中执行副作用。默认情况是惰性的，也就是说仅在侦听的源数据变更时才执行回调。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch(source, callback, [options])</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>source: 可以支持 string,Object,Function,Array; 用于指定要侦听的响应式变量</li><li>callback: 执行的回调函数</li><li>options：支持 deep、immediate 和 flush 选项。</li></ul><p>接下来我会分别介绍这个三个参数都是如何使用的， 如果你对 watch 的使用不明白的请往下看：</p><h4 id="侦听-reactive-定义的数据"><a href="#侦听-reactive-定义的数据" class="headerlink" title="侦听 reactive 定义的数据"></a>侦听 reactive 定义的数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref, reactive, toRefs, watch &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123; <span class="attr">nickname</span>: <span class="string">"xiaofan"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      state.age++;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改age值时会触发 watch的回调</span></span><br><span class="line">    watch(</span><br><span class="line">      () =&gt; state.age,</span><br><span class="line">      (curAge, preAge) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"新值:"</span>, curAge, <span class="string">"老值:"</span>, preAge);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...toRefs(state),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="侦听-ref-定义的数据"><a href="#侦听-ref-定义的数据" class="headerlink" title="侦听 ref 定义的数据"></a>侦听 ref 定义的数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> year = ref(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  year.value++;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">watch(year, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"新值:"</span>, newVal, <span class="string">"老值:"</span>, oldVal);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="侦听多个数据"><a href="#侦听多个数据" class="headerlink" title="侦听多个数据"></a>侦听多个数据</h4><p>上面两个例子中，我们分别使用了两个 watch, 当我们需要侦听多个数据源时， 可以进行合并， 同时侦听多个数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([() =&gt; state.age, year], ([curAge, newVal], [preAge, oldVal]) =&gt; &#123;</span><br><span class="line">console.log(&quot;新值:&quot;, curAge, &quot;老值:&quot;, preAge); console.log(&quot;新值:&quot;, newVal,</span><br><span class="line">&quot;老值:&quot;, oldVal); &#125;);</span><br></pre></td></tr></table></figure><h4 id="侦听复杂的嵌套对象"><a href="#侦听复杂的嵌套对象" class="headerlink" title="侦听复杂的嵌套对象"></a>侦听复杂的嵌套对象</h4><p>我们实际开发中，复杂数据随处可见， 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  room: &#123;</span><br><span class="line">    id: <span class="number">100</span>,</span><br><span class="line">    attrs: &#123;</span><br><span class="line">      size: <span class="string">"140平方米"</span>,</span><br><span class="line">      type: <span class="string">"三室两厅"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.room,</span><br><span class="line">  (newType, oldType) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新值:"</span>, newType, <span class="string">"老值:"</span>, oldType);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果不使用第三个参数<code>deep:true</code>， 是无法监听到数据变化的。<br>前面我们提到，<strong>默认情况下，watch 是惰性的</strong>, 那什么情况下不是惰性的， 可以立即执行回调函数呢？其实使用也很简单， 给第三个参数中设置<code>immediate: true</code>即可。关于<code>flush</code>配置，还在学习，后期会补充</p><h4 id="stop-停止监听"><a href="#stop-停止监听" class="headerlink" title="stop 停止监听"></a>stop 停止监听</h4><p>我们在组件中创建的<code>watch</code>监听，会在组件被销毁时自动停止。如果在组件销毁之前我们想要停止掉某个监听， 可以调用<code>watch()</code>函数的返回值，操作如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const stopWatchRoom = watch(<span class="function"><span class="params">()</span> =&gt;</span> state.room, <span class="function"><span class="params">(newType, oldType)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"新值:"</span>, newType, <span class="string">"老值:"</span>, oldType);</span><br><span class="line">&#125;, &#123;deep:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="regexp">//</span> 停止监听</span><br><span class="line">    stopWatchRoom()</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>还有一个监听函数<code>watchEffect</code>, 在我看来<code>watch</code>已经能满足监听的需求，为什么还要有<code>watchEffect</code>呢？虽然我没有 get 到它的必要性，但是还是要介绍一下<code>watchEffect</code>，首先看看它的使用和<code>watch</code>究竟有何不同。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; defineComponent, ref, reactive, <span class="keyword">to</span>Refs, watchEffect &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line">export <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const <span class="keyword">state</span> = reactive(&#123; nickname: <span class="string">"xiaofan"</span>, age: <span class="number">20</span> &#125;);</span><br><span class="line">    let year = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>Interval(() =&gt;&#123;</span><br><span class="line">        <span class="keyword">state</span>.age++</span><br><span class="line">        year.value++</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    watchEffect(() =&gt; &#123;</span><br><span class="line">        console.<span class="keyword">log</span>(<span class="keyword">state</span>);</span><br><span class="line">        console.<span class="keyword">log</span>(year);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        ...<span class="keyword">to</span>Refs(<span class="keyword">state</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果首先打印一次<code>state</code>和<code>year</code>值；然后每隔一秒，打印<code>state</code>和<code>year</code>值。<br>从上面的代码可以看出， 并没有像<code>watch</code>一样需要先传入依赖，<code>watchEffect</code>会自动收集依赖, 只要指定一个回调函数。在组件初始化时， 会先执行一次来收集依赖， 然后当收集到的依赖中数据发生变化时， 就会再次执行回调函数。所以总结对比如下：</p><ol><li>watchEffect 不需要手动传入依赖</li><li>watchEffect 会先执行一次用来自动收集依赖</li><li>watchEffect 无法获取到变化前的值， 只能获取变化后的值</li></ol><p>上面介绍了 Vue3 <code>Composition API</code>的部分内容, 还有很多非常好用的 API, 建议直接查看官网 composition-api。<br>其实我们也能进行自定义封装。</p><h2 id="自定义-Hooks"><a href="#自定义-Hooks" class="headerlink" title="自定义 Hooks"></a>自定义 Hooks</h2><p>开篇的时候我们使用 Vue2.x 写了一个实现加减的例子， 这里可以将其封装成一个 hook, 我们约定这些「自定义 Hook」以 use 作为前缀，和普通的函数加以区分。<br><code>useCount.ts</code> 实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, Ref, computed &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CountResultProps = &#123;</span><br><span class="line">  count: Ref&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">  multiple: Ref&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">  increase: <span class="function">(<span class="params">delta?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  decrease: <span class="function">(<span class="params">delta?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useCount</span>(<span class="params">initValue = 1</span>): <span class="title">CountResultProps</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(initValue);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> increase = (delta?: <span class="built_in">number</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delta !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      count.value += delta;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count.value += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> multiple = computed(<span class="function"><span class="params">()</span> =&gt;</span> count.value * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> decrease = (delta?: <span class="built_in">number</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> delta !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">      count.value -= delta;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      count.value -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    multiple,</span><br><span class="line">    increase,</span><br><span class="line">    decrease,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看一下在组件中使用<code>useCount</code>这个 <code>hook</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;count: &#123;&#123; count &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p&gt;倍数： &#123;&#123; multiple &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button <span class="meta">@click</span>=<span class="string">"increase()"</span>&gt;加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="decrease()"&gt;减一&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> useCount <span class="keyword">from</span> <span class="string">"../hooks/useCount"</span>;</span><br><span class="line"> setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count, multiple, increase, decrease &#125; = useCount(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            multiple,</span><br><span class="line">            increase,</span><br><span class="line">            decrease,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>开篇 Vue2.x 实现，分散在<code>data</code>,<code>method</code>,<code>computed</code>等， 如果刚接手项目，实在无法快速将<code>data</code>字段和<code>method</code>关联起来，而 Vue3 的方式可以很明确的看出，将 count 相关的逻辑聚合在一起， 看起来舒服多了， 而且<code>useCount</code>还可以扩展更多的功能。<br>项目开发完之后，后续还会写一篇总结项目中使用到的「自定义 Hooks 的文章」，帮助大家更高效的开发， 关于<code>Composition API</code>和自定义 Hooks 就介绍到这里， 接下来简单介绍一下 vue2.x 与 vue3 响应式对比。</p><h2 id="简单对比-vue2-x-与-vue3-x-响应式"><a href="#简单对比-vue2-x-与-vue3-x-响应式" class="headerlink" title="简单对比 vue2.x 与 vue3.x 响应式"></a>简单对比 vue2.x 与 vue3.x 响应式</h2><p>其实在 Vue3.x 还没有发布 bate 的时候， 很火的一个话题就是<code>Vue3.x 将使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty</code>。<br>没有无缘无故的爱，也没有无缘无故的恨。为何要将<code>Object.defineProperty</code>换掉呢，咋们可以简单聊一下。<br>我刚上手 Vue2.x 的时候就经常遇到一个问题，数据更新了啊，为何页面不更新呢？什么时候用<code>$set</code>更新，什么时候用<code>$forceUpdate</code>强制更新，你是否也一度陷入困境。后来的学习过程中开始接触源码，才知道一切的根源都是 <code>Object.defineProperty</code>。<br>对这块想要深入了解的小伙伴可以看这篇文章 为什么 Vue3.0 不再使用 defineProperty 实现数据监听？要详细解释又是一篇文章，这里就简单对比一下<code>Object.defineProperty</code> 与 Proxy</p><ol><li><code>Object.defineProperty</code>只能劫持对象的属性， 而 Proxy 是直接代理对象</li></ol><p>由于<code>Object.defineProperty</code>只能劫持对象属性，需要遍历对象的每一个属性，如果属性值也是对象，就需要递归进行深度遍历。但是 Proxy 直接代理对象， 不需要遍历操作</p><ol><li><code>Object.defineProperty</code>对新增属性需要手动进行<code>Observe</code></li></ol><p>因为<code>Object.defineProperty</code>劫持的是对象的属性，所以新增属性时，需要重新遍历对象， 对其新增属性再次使用<code>Object.defineProperty</code>进行劫持。也就是 Vue2.x 中给数组和对象新增属性时，需要使用<code>$set</code>才能保证新增的属性也是响应式的, <code>$set</code>内部也是通过调用<code>Object.defineProperty</code>去处理的。</p><h2 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h2><p>Teleport 是 Vue3.x 新推出的功能， 没听过这个词的小伙伴可能会感到陌生；翻译过来是<code>传送</code>的意思，可能还是觉得不知所以，没事下边我就给大家形象的描述一下。</p><h3 id="Teleport-是什么呢？"><a href="#Teleport-是什么呢？" class="headerlink" title="Teleport 是什么呢？"></a>Teleport 是什么呢？</h3><p>Teleport 就像是哆啦 A 梦中的「任意门」，任意门的作用就是可以将人瞬间传送到另一个地方。有了这个认识，我们再来看一下为什么需要用到 Teleport 的特性呢，看一个小例子：<br>在子组件<code>Header</code>中使用到<code>Dialog</code>组件，我们实际开发中经常会在类似的情形下使用到 <code>Dialog</code> ，此时<code>Dialog</code>就被渲染到一层层子组件内部，处理嵌套组件的定位、<code>z-index</code>和样式都变得困难。<br><code>Dialog</code>从用户感知的层面，应该是一个独立的组件，从 dom 结构应该完全剥离 Vue 顶层组件挂载的 DOM；同时还可以使用到 Vue 组件内的状态（<code>data</code>或者<code>props</code>）的值。简单来说就是,<strong>即希望继续在组件内部使用<code>Dialog</code>, 又希望渲染的 DOM 结构不嵌套在组件的 DOM 中</strong>。<br>此时就需要 Teleport 上场，我们可以用<code>&lt;Teleport&gt;</code>包裹<code>Dialog</code>, 此时就建立了一个传送门，可以将<code>Dialog</code>渲染的内容传送到任何指定的地方。<br>接下来就举个小例子，看看 Teleport 的使用方式</p><h3 id="Teleport-的使用"><a href="#Teleport-的使用" class="headerlink" title="Teleport 的使用"></a>Teleport 的使用</h3><p>我们希望 Dialog 渲染的 dom 和顶层组件是兄弟节点关系, 在<code>index.html</code>文件中定义一个供挂载的元素:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dialog"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义一个<code>Dialog</code>组件<code>Dialog.vue</code>, 留意 <code>to</code> 属性， 与上面的<code>id</code>选择器一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;teleport to=&quot;#dialog&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;dialog_wrapper&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;dialog_header&quot; v-if=&quot;title&quot;&gt;</span><br><span class="line">          &lt;slot name=&quot;header&quot;&gt;</span><br><span class="line">            &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt;</span><br><span class="line">          &lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;dialog_content&quot;&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;dialog_footer&quot;&gt;</span><br><span class="line">        &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/teleport&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>最后在一个子组件<code>Header.vue</code>中使用<code>Dialog</code>组件, 这里主要演示 Teleport 的使用，不相关的代码就省略了。<code>header</code>组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">navbar</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Dialog</span> <span class="attr">v-if</span>=<span class="string">"dialogVisible"</span>&gt;</span><span class="tag">&lt;/<span class="name">Dialog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Dom 渲染效果如下：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/712e61d275cb4b7da5252bb9cd6d2afa~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>图片. png<br>可以看到，我们使用 <code>teleport</code> 组件，通过 <code>to</code> 属性，指定该组件渲染的位置与 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 同级，也就是在 <code>body</code> 下，但是 <code>Dialog</code> 的状态 <code>dialogVisible</code> 又是完全由内部 Vue 组件控制.</p><h2 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h2><p><code>Suspense</code>是 Vue3.x 中新增的特性， 那它有什么用呢？别急，我们通过 Vue2.x 中的一些场景来认识它的作用。<br>Vue2.x 中应该经常遇到这样的场景：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">template</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> v-<span class="keyword">if</span>=<span class="string">"!loading"</span>&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> v-<span class="keyword">if</span>=<span class="string">"loading"</span>&gt;</span><br><span class="line">        加载中...</span><br><span class="line">    &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">template</span>&gt;</span><br></pre></td></tr></table></figure><p>在前后端交互获取数据时， 是一个异步过程，一般我们都会提供一个加载中的动画，当数据返回时配合<code>v-if</code>来控制数据显示。<br>如果你使用过<code>vue-async-manager</code>这个插件来完成上面的需求， 你对<code>Suspense</code>可能不会陌生，Vue3.x 感觉就是参考了<code>vue-async-manager</code>.<br>Vue3.x 新出的内置组件<code>Suspense</code>, 它提供两个<code>template</code> slot, 刚开始会渲染一个 fallback 状态下的内容， 直到到达某个条件后才会渲染 default 状态的正式内容， 通过使用<code>Suspense</code>组件进行展示异步渲染就更加的简单。:::warning 如果使用 <code>Suspense</code>, 要返回一个 promise :::<code>Suspense</code> 组件的使用：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Suspense&gt;</span></span><br><span class="line">      <span class="section">&lt;template #default&gt;</span></span><br><span class="line">          <span class="section">&lt;async-component&gt;</span><span class="section">&lt;/async-component&gt;</span></span><br><span class="line">      <span class="section">&lt;/template&gt;</span></span><br><span class="line">      <span class="section">&lt;template #fallback&gt;</span></span><br><span class="line">          <span class="section">&lt;div&gt;</span></span><br><span class="line">              <span class="attribute">Loading</span>...</span><br><span class="line">          <span class="section">&lt;/div&gt;</span></span><br><span class="line">      <span class="section">&lt;/template&gt;</span></span><br><span class="line"><span class="section">&lt;/Suspense&gt;</span></span><br></pre></td></tr></table></figure><p><code>asyncComponent.vue</code>:</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;&lt;<span class="attr">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>这个是一个异步加载数据<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名：</span><span class="template-variable">&#123;&#123;user.nickname&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>年龄：</span><span class="template-variable">&#123;&#123;user.age&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">import &#123; defineComponent &#125; from "vue"</span></span><br><span class="line"><span class="xml">import axios from "axios"</span></span><br><span class="line"><span class="xml">export default defineComponent(&#123;</span></span><br><span class="line"><span class="xml">    setup()&#123;</span></span><br><span class="line"><span class="xml">        const rawData = await axios.get("http://xxx.xinp.cn/user")</span></span><br><span class="line"><span class="xml">        return &#123;</span></span><br><span class="line"><span class="xml">            user: rawData.data</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>从上面代码来看，<code>Suspense</code> 只是一个带插槽的组件，只是它的插槽指定了<code>default</code> 和 <code>fallback</code> 两种状态。</p><h2 id="片段（Fragment）"><a href="#片段（Fragment）" class="headerlink" title="片段（Fragment）"></a>片段（Fragment）</h2><p>在 Vue2.x 中， <code>template</code>中只允许有一个根节点：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;template&gt;</span></span><br><span class="line">    <span class="section">&lt;div&gt;</span></span><br><span class="line">        <span class="section">&lt;span&gt;</span><span class="section">&lt;/span&gt;</span></span><br><span class="line">        <span class="section">&lt;span&gt;</span><span class="section">&lt;/span&gt;</span></span><br><span class="line">    <span class="section">&lt;/div&gt;</span></span><br><span class="line"><span class="section">&lt;/template&gt;</span></span><br></pre></td></tr></table></figure><p>但是在 Vue3.x 中，你可以直接写多个根节点， 是不是很爽：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;template&gt;</span></span><br><span class="line">    <span class="section">&lt;span&gt;</span><span class="section">&lt;/span&gt;</span></span><br><span class="line">    <span class="section">&lt;span&gt;</span><span class="section">&lt;/span&gt;</span></span><br><span class="line"><span class="section">&lt;/template&gt;</span></span><br></pre></td></tr></table></figure><h2 id="更好的-Tree-Shaking"><a href="#更好的-Tree-Shaking" class="headerlink" title="更好的 Tree-Shaking"></a>更好的 Tree-Shaking</h2><p>Vue3.x 在考虑到 <code>tree-shaking</code>的基础上重构了全局和内部 API, 表现结果就是现在的全局 API 需要通过 <code>ES Module</code>的引用方式进行具名引用， 比如在 Vue2.x 中，我们要使用 <code>nextTick</code>:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> vue2.x</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"></span><br><span class="line">Vue.nextTick(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Vue.nextTick()</code> 是一个从 Vue 对象直接暴露出来的全局 API，其实 <code>$nextTick()</code> 只是 <code>Vue.nextTick()</code> 的一个简易包装，只是为了方便而把后者的回调函数的 <code>this</code> 绑定到了当前的实例。虽然我们借助<code>webpack</code>的<code>tree-shaking</code>, 但是不管我们实际上是否使用<code>Vue.nextTick()</code>, 最终都会进入我们的生产代码， 因为 Vue 实例是作为单个对象导出的， 打包器无法坚持出代码总使用了对象的哪些属性。<br>在 Vue3.x 中改写成这样：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"></span><br><span class="line">nextTick(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="受影响的-API"><a href="#受影响的-API" class="headerlink" title="受影响的 API"></a>受影响的 API</h3><p>这是一个比较大的变化， 因为以前的全局 API 现在只能通过具名导入，这一更改会对以下 API 有影响：</p><ul><li><code>Vue.nextTick</code></li><li><code>Vue.observable</code>（用 <code>Vue.reactive</code> 替换）</li><li><code>Vue.version</code></li><li><code>Vue.compile</code>（仅限完整版本时可用）</li><li><code>Vue.set</code>（仅在 2.x 兼容版本中可用）</li><li><code>Vue.delete</code>（与上同）</li></ul><h3 id="内置工具"><a href="#内置工具" class="headerlink" title="内置工具"></a>内置工具</h3><p>出来上面的 API 外， 还有许多内置的组件<br>以上仅适用于 <code>ES Modules</code> builds，用于支持 tree-shaking 的绑定器——UMD 构建仍然包括所有特性，并暴露 Vue 全局变量上的所有内容 (编译器将生成适当的输出，以使用全局外的 api 而不是导入)。:::<br>前面都是 Vue3.0 的一些新特性，后面着重介绍一下相对于 Vue2.x 来说， 有什么变更呢？</p><h2 id="变更"><a href="#变更" class="headerlink" title="变更"></a>变更</h2><h3 id="slot-具名插槽语法"><a href="#slot-具名插槽语法" class="headerlink" title="slot 具名插槽语法"></a>slot 具名插槽语法</h3><p>在 Vue2.x 中， 具名插槽的写法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  子组件中：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父组件中使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>歌曲：成都<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们要<strong>在 slot 上面绑定数据，可以使用作用域插槽</strong>，实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">&lt;slot name=<span class="string">"content"</span> :<span class="keyword">data</span>=<span class="string">"data"</span>&gt;&lt;/slot&gt;</span><br><span class="line">export <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="keyword">data</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            <span class="keyword">data</span>:[<span class="string">"走过来人来人往"</span>,<span class="string">"不喜欢也得欣赏"</span>,<span class="string">"陪伴是最长情的告白"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 父组件中使用 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"content"</span> <span class="attr">slot-scope</span>=<span class="string">"scoped"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in scoped.data"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>在 Vue2.x 中具名插槽和作用域插槽分别使用<code>slot</code>和<code>slot-scope</code>来实现， 在 Vue3.0 中将<code>slot</code>和<code>slot-scope</code>进行了合并同意使用。<br>Vue3.0 中<code>v-slot</code>：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 父组件中使用 --&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:content</span>=<span class="string">"scoped"</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in scoped.data"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 也可以简写成： --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;data&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in data"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>首先回顾一下 Vue 2 中实现一个自定义指令：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 Vue 2 中， 自定义指令通过以下几个可选钩子创建：</p><ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li><li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li>unbind：只调用一次，指令与元素解绑时调用。</li></ul><p>在 Vue 3 中对自定义指令的 API 进行了更加语义化的修改， 就如组件生命周期变更一样， 都是为了更好的语义化， 变更如下：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a85dca78e2f4efcab61b03c98ec80de~tplv-k3u1fbpfcp-zoom-1.image" alt=""><br>所以在 Vue3 中， 可以这样来自定义指令：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; createApp &#125; from <span class="string">"vue"</span></span><br><span class="line"></span><br><span class="line">const app = createApp(&#123;&#125;)</span><br><span class="line">app.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">    mounted(el) &#123;</span><br><span class="line">        el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后可以在模板中任何元素上使用新的 <code>v-focus</code>指令， 如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">input</span> v-focus /&gt;</span><br></pre></td></tr></table></figure><h3 id="v-model-升级"><a href="#v-model-升级" class="headerlink" title="v-model 升级"></a>v-model 升级</h3><p>在使用 Vue 3 之前就了解到 <code>v-model</code> 发生了很大的变化， 使用过了之后才真正的 get 到这些变化， 我们先纵观一下发生了哪些变化， 然后再针对的说一下如何使用：</p><ul><li>变更：在自定义组件上使用<code>v-model</code>时， 属性以及事件的默认名称变了</li><li>变更：<code>v-bind</code>的<code>.sync</code>修饰符在 Vue 3 中又被去掉了, 合并到了<code>v-model</code>里</li><li>新增：同一组件可以同时设置多个 <code>v-model</code></li><li>新增：开发者可以自定义 <code>v-model</code>修饰符</li></ul><p>有点懵？别着急，往下看 在 Vue2 中， 在组件上使用 <code>v-model</code>其实就相当于传递了<code>value</code>属性， 并触发了<code>input</code>事件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue 2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">search-input</span> <span class="attr">v-model</span>=<span class="string">"searchValue"</span>&gt;</span><span class="tag">&lt;<span class="name">search-input</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">search-input</span> <span class="attr">:value</span>=<span class="string">"searchValue"</span> @<span class="attr">input</span>=<span class="string">"searchValue=$event"</span>&gt;</span><span class="tag">&lt;<span class="name">search-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这时<code>v-model</code>只能绑定在组件的<code>value</code>属性上，那我们就不开心了， 我们就像给自己的组件用一个别的属性，并且我们不想通过触发<code>input</code>来更新值，在<code>.async</code>出来之前，Vue 2 中这样实现：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件：searchInput.vue</span></span><br><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> &#123;</span><br><span class="line">    <span class="attribute">model</span>:&#123;</span><br><span class="line">        <span class="attribute">prop</span>: <span class="string">'search'</span>,</span><br><span class="line">        <span class="attribute">event</span>:<span class="string">'change'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后， searchInput 组件使用<code>v-model</code>就相当于这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">search-input</span> <span class="attr">v-model</span>=<span class="string">"searchValue"</span>&gt;</span><span class="tag">&lt;<span class="name">search-input</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">search-input</span> <span class="attr">:search</span>=<span class="string">"searchValue"</span> @<span class="attr">change</span>=<span class="string">"searchValue=$event"</span>&gt;</span><span class="tag">&lt;<span class="name">search-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是在实际开发中，有些场景我们可能需要对一个 prop 进行 “双向绑定”， 这里以最常见的 modal 为例子：modal 挺合适属性双向绑定的，外部可以控制组件的<code>visible</code>显示或者隐藏，组件内部关闭可以控制 <code>visible</code>属性隐藏，同时 visible 属性同步传输到外部。组件内部， 当我们关闭<code>modal</code>时, 在子组件中以 update:PropName 模式触发事件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:visible'</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>然后在父组件中可以监听这个事件进行数据更新：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;modal <span class="symbol">:visible=<span class="string">"isVisible"</span></span> <span class="variable">@update</span><span class="symbol">:visible=<span class="string">"isVisible = $event"</span>&gt;&lt;/modal&gt;</span></span><br></pre></td></tr></table></figure><p>此时我们也可以使用<code>v-bind.async</code>来简化实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modal</span> <span class="attr">:visible.async</span>=<span class="string">"isVisible"</span>&gt;</span><span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面回顾了 Vue2 中<code>v-model</code>实现以及组件属性的双向绑定，那么<strong>在 Vue 3 中应该怎样实现的呢？</strong><br>在 Vue3 中, 在自定义组件上使用<code>v-model</code>, 相当于传递一个<code>modelValue</code> 属性， 同时触发一个<code>update:modelValue</code>事件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modal</span> <span class="attr">v-model</span>=<span class="string">"isVisible"</span>&gt;</span><span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modal</span> <span class="attr">:modelValue</span>=<span class="string">"isVisible"</span> @<span class="attr">update:modelValue</span>=<span class="string">"isVisible = $event"</span>&gt;</span><span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要绑定属性名， 只需要给<code>v-model</code>传递一个参数就行, 同时可以绑定多个<code>v-model</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modal</span> <span class="attr">v-model:visible</span>=<span class="string">"isVisible"</span> <span class="attr">v-model:content</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">modal</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modal</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:visible</span>=<span class="string">"isVisible"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:content</span>=<span class="string">"content"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">update:visible</span>=<span class="string">"isVisible"</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">update:content</span>=<span class="string">"content"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>不知道你有没有发现，这个写法完全没有<code>.async</code>什么事儿了， 所以啊，Vue 3 中又抛弃了<code>.async</code>写法， 统一使用<code>v-model</code></p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>Vue3 中 使用 <code>defineAsyncComponent</code> 定义异步组件，配置选项 <code>component</code> 替换为 <code>loader</code> ,Loader 函数本身不再接收 resolve 和 reject 参数，且必须返回一个 Promise，用法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 异步组件的使用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">AsyncPage</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tempate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="undefined">  components: &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 无配置项异步组件</span></span></span><br><span class="line"><span class="javascript">    AsyncPage: defineAsyncComponent(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./NextPage.vue"</span>)),</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 有配置项异步组件</span></span></span><br><span class="line"><span class="undefined">    AsyncPageWithOptions: defineAsyncComponent(&#123;</span></span><br><span class="line"><span class="javascript">   loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">".NextPage.vue"</span>),</span></span><br><span class="line"><span class="undefined">   delay: 200,</span></span><br><span class="line"><span class="undefined">   timeout: 3000,</span></span><br><span class="line"><span class="javascript">   errorComponent: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./ErrorComponent.vue"</span>),</span></span><br><span class="line"><span class="javascript">   loadingComponent: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./LoadingComponent.vue"</span>),</span></span><br><span class="line"><span class="undefined"> &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ul><li>vue3 全家桶入门指南</li><li>学习一波 Vue3 新特性</li><li>Vue3.0 新特性以及使用变更总结(实际工作用到的)</li><li>了不起的 Vue3</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Vue3.0 在去年 9 月正式发布了，
      
    
    </summary>
    
      <category term="vue3" scheme="https://chongdee.github.io/categories/vue3/"/>
    
    
      <category term="vue3" scheme="https://chongdee.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.x脱坑-解决方法总结</title>
    <link href="https://chongdee.github.io/2021/07/20/vue/Vue2.x%E8%84%B1%E5%9D%91-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://chongdee.github.io/2021/07/20/vue/Vue2.x脱坑-解决方法总结/</id>
    <published>2021-07-20T10:56:22.170Z</published>
    <updated>2021-05-08T19:11:37.518Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章内容覆盖范围,芝麻绿豆的破问题都有,不止于vue;<br>给出的是方案,而非手把手一字一句的给你说十万个为什么!</p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="Q-安装超时-install-timeout"><a href="#Q-安装超时-install-timeout" class="headerlink" title="Q:安装超时(install timeout)"></a>Q:安装超时(install timeout)</h3><p>方案有这么些:</p><ul><li><p>cnpm : 国内对npm的镜像版本</p><a id="more"></a><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cnpm website: https://npm.taobao.org/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry=<span class="string">https:</span><span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cnpm 的大多命令跟 npm 的是一致的,比如安装,卸载这些</span></span><br></pre></td></tr></table></figure></li><li><p>yarn 和 npm 改源大法</p></li></ul><ul><li>使用 nrm 模块 : www.npmjs.com/package/nrm</li></ul><ul><li>npm config : npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li></ul><ul><li>yarn config : yarn config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li></ul><h3 id="Q-想学习Vue-要先学习脚手架的搭建么"><a href="#Q-想学习Vue-要先学习脚手架的搭建么" class="headerlink" title="Q: 想学习Vue,要先学习脚手架的搭建么"></a>Q: 想学习Vue,要先学习脚手架的搭建么</h3><p>若是你想快速上手，用官方的脚手架即可(Vue-Cli 3)<br>因为不管是webpack还是parcel，gulp，都是一些构建工作流的东东；<br>学习脚手架的搭建，更多的是要针对项目业务进行定制，调优；<br>一般入门级的无需太早考虑这方面的，只要专心学好Vue的使用姿势便可。</p><h3 id="Q-安装一些需要编译的包-提示没有安装python、build失败等"><a href="#Q-安装一些需要编译的包-提示没有安装python、build失败等" class="headerlink" title="Q:安装一些需要编译的包:提示没有安装python、build失败等"></a>Q:安装一些需要编译的包:提示没有安装python、build失败等</h3><p>因为一些 npm 的包安装需要编译的环境,mac 和 linux 都还好,</p><p>而window 用户依赖 visual studio 的一些库和python 2+,<br>windows的小伙伴都装上:</p><ul><li><a href="https://github.com/felixrieseberg/windows-build-tools" target="_blank" rel="noopener">windows-build-tools</a></li><li><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python 2.x</a></li></ul><h3 id="Q-can’t-not-find-‘xxModule’-找不到某些依赖或者模块"><a href="#Q-can’t-not-find-‘xxModule’-找不到某些依赖或者模块" class="headerlink" title="Q:can’t not find ‘xxModule’ - 找不到某些依赖或者模块"></a>Q:can’t not find ‘xxModule’ - 找不到某些依赖或者模块</h3><p>这种情况一般报错信息可以看到是哪个包抛出的信息，一般卸载这个模块,安装重新安装下即可。</p><h3 id="Q-data-functions-should-return-an-object"><a href="#Q-data-functions-should-return-an-object" class="headerlink" title="Q:data functions should return an object"></a>Q:data functions should return an object</h3><p>这个问题是 Vue 实例内,单组件的data必须返回一个对象;如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> &#123;</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">'page-router-view'</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        tabs: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: <span class="string">'财务信息'</span>,</span><br><span class="line">            url: <span class="string">'/userinfo'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attribute">title</span>: <span class="string">'帐号信息'</span>,</span><br><span class="line">            url: <span class="string">'/userinfo/base'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要 return 一个数据对象呢?</strong><br>官方解释如下:  data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。</p><p>如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！</p><p>简言之,组件复用下,不会造成数据同时指向一处,造出牵一发而动全身的破问题,</p><h3 id="Q-我给组件内的原生控件添加事件-怎么不生效了"><a href="#Q-我给组件内的原生控件添加事件-怎么不生效了" class="headerlink" title="Q:我给组件内的原生控件添加事件,怎么不生效了!"></a>Q:我给组件内的原生控件添加事件,怎么不生效了!</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--比如用了第三方框架,或者一些封装的内置组件; 然后想绑定事件--&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--// 错误例子1--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入特定消费金额 "</span> @<span class="attr">mouseover</span>=<span class="string">"test()"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--// 错误例子2--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"item.menuUrl"</span> @<span class="attr">click</span>=<span class="string">"toggleName=''"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">:class</span>=<span class="string">"['fzicon',item.menuIcon]"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.menuName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--上面的两个例子都没法触发事件!--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--究其原因,少了一个修饰符 .native--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"item.menuUrl"</span> @<span class="attr">click.native</span>=<span class="string">"toggleName=''"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">:class</span>=<span class="string">"['fzicon',item.menuIcon]"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.menuName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--明明官方文档有的,一堆人不愿意去看,,Fuck--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--https://cn.vuejs.org/v2/guide/components.html#给组件绑定原生事件--&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="Q-provide和inject是什么"><a href="#Q-provide和inject是什么" class="headerlink" title="Q: provide和inject是什么"></a>Q: provide和inject是什么</h3><p>Vue 在2.2的时候,也提供了该概念。类比ng provider和react context;</p><h3 id="Q-我用了-axios-为什么-IE-浏览器不识别-IE9"><a href="#Q-我用了-axios-为什么-IE-浏览器不识别-IE9" class="headerlink" title="Q:我用了 axios , 为什么 IE 浏览器不识别(IE9+)"></a>Q:我用了 axios , 为什么 IE 浏览器不识别(IE9+)</h3><p>那是因为 IE 整个家族都不支持 promise, 解决方案:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">es6-promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js 引入即可</span></span><br><span class="line"><span class="comment">// ES6的polyfill</span></span><br><span class="line"><span class="selector-tag">require</span>(<span class="string">"es6-promise"</span>)<span class="selector-class">.polyfill</span>();</span><br></pre></td></tr></table></figure><h3 id="Q-我在函数内用了this-xxx-为什么抛出Cannot-set-property-‘xxx’-of-undefined"><a href="#Q-我在函数内用了this-xxx-为什么抛出Cannot-set-property-‘xxx’-of-undefined" class="headerlink" title="Q:我在函数内用了this.xxx=,为什么抛出Cannot set property ‘xxx’ of undefined;"></a>Q:我在函数内用了this.xxx=,为什么抛出Cannot set property ‘xxx’ of undefined;</h3><p>这又是this的套路了,this是和当前运行的上下文绑定的,</p><p>一般你在axios或者其他 promise , 或者setInterval<br>这些默认都是指向最外层的全局钩子.</p><p>简单点说:”最外层的上下文就是 window,vue内则是 Vue 对象而不是实例!”;<br>解决方案:</p><ul><li>暂存法: 函数内先缓存 this , let that = this;(let是 es6, es5用 var)</li><li>箭头函数: 会强行关联当前运行区域为 this 的上下文;</li></ul><p>this的知识, 读”&lt;&lt;你不知道的 JS 系列&gt;&gt;”最为合适了,里面讲的很清楚</p><h3 id="Q-我看一些Vue教程有这么些写法-是什么意思-click-prevent-v-demo-a-b"><a href="#Q-我看一些Vue教程有这么些写法-是什么意思-click-prevent-v-demo-a-b" class="headerlink" title="Q:我看一些Vue教程有这么些写法,是什么意思@click.prevent,v-demo.a.b;"></a>Q:我看一些Vue教程有这么些写法,是什么意思@click.prevent,v-demo.a.b;</h3><p>@click.prevent : 事件+修饰符 , 作用就是点击但又阻止默认行为</p><p>v-demo.a.b: 自定义指令+修饰符.<br>具体看你什么指令了,修饰符的作用大多是给事件增加一些确切的拓展功能</p><p>比如阻止事件冒泡,阻止默认行为,访问到原生控件,结合键盘快捷键等等</p><p>传送门:<a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">事件修饰符</a>;</p><p>可以自定义修饰符么?也是可以的,</p><p>可以通过全局 config.keyCodes 对象自定义键值修饰符别名：</p><h3 id="Q-为什么我的引入的小图片渲染出来却是-data-image-png-base64xxxxxxxx"><a href="#Q-为什么我的引入的小图片渲染出来却是-data-image-png-base64xxxxxxxx" class="headerlink" title="Q:为什么我的引入的小图片渲染出来却是 data:image/png;base64xxxxxxxx"></a>Q:为什么我的引入的小图片渲染出来却是 data:image/png;base64xxxxxxxx</h3><p>这个是 webpack 里面的对应插件处理的.</p><p>对于小于多少 K 以下的图片(规定的格式)直接转为 base64格式渲染;</p><p>具体配置在webpack.base.conf.js里面的 rules里面的 url-loader</p><p>这样做的好处:在网速不好的时候先于内容加载和减少http的请求次数来减少网站服务器的负担。</p><h3 id="Q-Component-template-shold-contain-exactly-one-root-element-If-you-are-useing-v-if-on-multiple-elements-xxxxx"><a href="#Q-Component-template-shold-contain-exactly-one-root-element-If-you-are-useing-v-if-on-multiple-elements-xxxxx" class="headerlink" title="Q:Component template shold contain exactly one root element.If you are useing v-if on multiple elements , xxxxx"></a>Q:Component template shold contain exactly one root element.If you are useing v-if on multiple elements , xxxxx</h3><p>大体就是说,单组件渲染 DOM 区域必须要有一个根元素,最外层添加<div></div></p><p>可以用v-if和v-else-if指令来控制其他元素达到并存的状态</p><h3 id="Q-跨域问题怎么破"><a href="#Q-跨域问题怎么破" class="headerlink" title="Q:跨域问题怎么破!"></a>Q:跨域问题怎么破!</h3><p>比如No ‘Access-Control-Allow-Origin’ header is present on the requested resource.<br>这种问题老生常谈了,我就不细说了,大体说一下;</p><ul><li><p>1: CORS , 前后端都要对应去配置,IE10+</p></li><li><p>2: nginx 反向代理,一劳永逸，线上环境可以用这个</p></li></ul><p>线下开发模式,比如你用了vue-cli, 里面的 webpack 有引入了proxyTable这么个玩意,<br>也可以做接口反向代理</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 config 目录下的index.js</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">proxyTable:</span> &#123;</span><br><span class="line">  <span class="string">"/bp-api"</span>: &#123;</span><br><span class="line"><span class="symbol">    target:</span> <span class="string">"http://new.d.st.cn"</span>,</span><br><span class="line"><span class="symbol">    changeOrigin:</span> true,</span><br><span class="line">    <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">    <span class="comment">//   "^/bp-api": "/"</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// target : 就是 api 的代理的实际路径</span></span><br><span class="line"><span class="comment">// changeOrigin: 就是是变源,必须是,</span></span><br><span class="line"><span class="comment">// pathRewrite : 就是路径重定向,一看就知道</span></span><br></pre></td></tr></table></figure><p>当然还有依旧坚挺的jsonp大法!不过局限性比较多,比较适合一些特殊的信息获取!</p><h3 id="Q-我需要遍历的数组值更新了-值也赋值了-为什么视图不更新"><a href="#Q-我需要遍历的数组值更新了-值也赋值了-为什么视图不更新" class="headerlink" title="Q:我需要遍历的数组值更新了,值也赋值了,为什么视图不更新!"></a>Q:我需要遍历的数组值更新了,值也赋值了,为什么视图不更新!</h3><p>那是因为有局限性啊,官方文档也说的很清楚,</p><p>只有一些魔改的之后的方法提供跟原生一样的使用姿势(可以触发视图更新);</p><p>一般我们更常用(除了魔改方法)的手段是使用:this.$set(obj,item,value);</p><p>传送门:<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">数组更新检测(触发视图更新)</a></p><h3 id="Q-为什么我的组件间的样式不能继承或者覆写啊"><a href="#Q-为什么我的组件间的样式不能继承或者覆写啊" class="headerlink" title="Q:为什么我的组件间的样式不能继承或者覆写啊!"></a>Q:为什么我的组件间的样式不能继承或者覆写啊!</h3><p>单组件开发模式下,请确认是否开启了 CSS模块化功能!!</p><p>也就是scoped(vue-cli 里面配置了,只要加入这个属性就自动启用)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么不能简单的继承或者覆写呢,是因为每个类或者 id 乃至标签都会给自动在css后面添加自定义属性hash!<br>比如</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 写的时候是这个</span><br><span class="line"><span class="string">.trangle</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 编译过后,加上了 hash</span><br><span class="line"><span class="string">.trangle</span>[data-v-1ec35ffc]&#123;&#125;</span><br></pre></td></tr></table></figure><p>这些都是在 css-loader 里面配置!</p><h3 id="Q-路由模式改为history后-除了首次启动首页没报错-刷新访问路由都报错"><a href="#Q-路由模式改为history后-除了首次启动首页没报错-刷新访问路由都报错" class="headerlink" title="Q:路由模式改为history后,除了首次启动首页没报错,刷新访问路由都报错!"></a>Q:路由模式改为history后,除了首次启动首页没报错,刷新访问路由都报错!</h3><p>必须给对应的服务端配置查询的主页面,也可以认为是主路由入口的引导</p><p>官方文档也有,为毛总有人不喜欢去看文档,总喜欢做伸手党,FUCK<br>传送门 : <a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">Vue-Router history Mode</a></p><h3 id="Q-我想拦截页面-或者在页面进来之前做一些事情-可以么"><a href="#Q-我想拦截页面-或者在页面进来之前做一些事情-可以么" class="headerlink" title="Q:我想拦截页面,或者在页面进来之前做一些事情,可以么?"></a>Q:我想拦截页面,或者在页面进来之前做一些事情,可以么?</h3><p>Of course !!<br>各种路由器的钩子!! 传送门: <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">导航守卫</a>;</p><p>当然,记忆滚动的位置也可以做到,详情翻翻里面的文档</p><h3 id="Q-TypeError-xxx-is-not-a-function"><a href="#Q-TypeError-xxx-is-not-a-function" class="headerlink" title="Q:TypeError: xxx is not a function"></a>Q:TypeError: xxx is not a function</h3><p>这种问题明显就是写法有问题,能不能动点脑子!!</p><h3 id="Q-能不能跨级拿到props"><a href="#Q-能不能跨级拿到props" class="headerlink" title="Q: 能不能跨级拿到props"></a>Q: 能不能跨级拿到props</h3><p>这种情况是面向嵌套层次很深的组件，又要拿到上层的父传递的东东，</p><p>可以用$attrs 或者inject + provide来实现</p><h3 id="Q-Uncaught-ReferenceError-xxx-is-not-define"><a href="#Q-Uncaught-ReferenceError-xxx-is-not-define" class="headerlink" title="Q:Uncaught ReferenceError: xxx is not define"></a>Q:Uncaught ReferenceError: xxx is not define</h3><ul><li>实例内的 data 对应的变量没有声明</li><li>你导入模块报这个错误,那绝逼是导出没写好</li></ul><h3 id="Q-Error-in-render-function-”Type-Error-Cannot-read-property-‘xxx’-of-undefined”"><a href="#Q-Error-in-render-function-”Type-Error-Cannot-read-property-‘xxx’-of-undefined”" class="headerlink" title="Q:Error in render function:”Type Error: Cannot read property ‘xxx’ of undefined”"></a>Q:Error in render function:”Type Error: Cannot read property ‘xxx’ of undefined”</h3><p>这种问题大多都是初始化的姿势不对;</p><p>比如引入echart这些,仔细去了解下生命周期,再来具体初始化;</p><p>vue 组件有时候也会(嵌套组件或者 props传递初始化),也是基本这个问题</p><h3 id="Q-Unexpected-token-operator-xxxxx"><a href="#Q-Unexpected-token-operator-xxxxx" class="headerlink" title="Q:Unexpected token: operator xxxxx"></a>Q:Unexpected token: operator xxxxx</h3><p>大佬,这个一看就是语法错误啊.<br>基本都是符号问题.<br>一般报错会给出哪一行或者哪个组件</p><h3 id="Q-npm-run-build之后不能直接访问"><a href="#Q-npm-run-build之后不能直接访问" class="headerlink" title="Q:npm run build之后不能直接访问"></a>Q:npm run build之后不能直接访问</h3><p>大佬!你最起码得在本地搭个服务器才能访问好么!!</p><h3 id="Q-操作Vue的原型链好么"><a href="#Q-操作Vue的原型链好么" class="headerlink" title="Q: 操作Vue的原型链好么"></a>Q: 操作Vue的原型链好么</h3><p>这个问题需要具体情况具体分析；</p><p>我看很多人喜欢把axios挂载到Vue.prototype上；</p><p>这样做有一定的弊端，相当耦合，若是多人维护或者替换其他库的时候有一定困难；</p><p>比较好的做法是不挂载，而是单独有服务请求的文件，用函数来封装你所需要的接口聚合；</p><p>这样统一暴露函数名，而内部实现可以随便改动</p><h3 id="Q-CSSbackground引入图片打包后-访问路径错误"><a href="#Q-CSSbackground引入图片打包后-访问路径错误" class="headerlink" title="Q:CSSbackground引入图片打包后,访问路径错误"></a>Q:CSSbackground引入图片打包后,访问路径错误</h3><p>因为打包后图片是在根目录下,你用相对路径肯定报错啊,</p><p>你可以魔改 webpack 的配置文件里面的static为./static,但是不建议</p><p>你若是把图片什么丢到assets目录下,然后相对路径,打包后是正常的</p><h3 id="Q-安装模块时命令窗口输出unsupported-platform-xxx"><a href="#Q-安装模块时命令窗口输出unsupported-platform-xxx" class="headerlink" title="Q:安装模块时命令窗口输出unsupported platform xxx"></a>Q:安装模块时命令窗口输出unsupported platform xxx</h3><p>一般两种情况,node版本不兼容,系统不兼容;</p><p>解决方案: 要么不装,要么满足安装要求;</p><h3 id="Q-Unexpected-tab-charater这些"><a href="#Q-Unexpected-tab-charater这些" class="headerlink" title="Q:Unexpected tab charater这些"></a>Q:Unexpected tab charater这些</h3><p>一般是你用脚手架初始化的时候开了 eslint ;</p><p>要么遵循规则,要么改变规则;</p><p>要么直接把 webpack 里面的 eslint 检测给关闭了</p><h3 id="Q-Failed-to-mount-component-template-or-render-function-not-defined"><a href="#Q-Failed-to-mount-component-template-or-render-function-not-defined" class="headerlink" title="Q:Failed to mount component: template or render function not defined"></a>Q:Failed to mount component: template or render function not defined</h3><p>组件挂载失败,问题只有这么几个，组件没有正确引入或挂载点顺序错了。</p><h3 id="Q-Unknown-custom-element-did-you-register-the-component-correctly"><a href="#Q-Unknown-custom-element-did-you-register-the-component-correctly" class="headerlink" title="Q:Unknown custom element:  - did you register the component correctly?"></a>Q:Unknown custom element: <xxx> - did you register the component correctly?</xxx></h3><p>组件没有正确引入或者正确使用,依次确认</p><ol><li>导入对应的组件</li><li>在 components 内声明</li><li>在 dom 区域声明标签</li></ol><p>Q: 如何让自定义组件支持Vue.use使用呢<br>只要暴露一个install函数即可，大体可以看下以下代码；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BtnPopconfirm <span class="keyword">from</span> <span class="string">'./BtnPopconfirm.vue'</span>;</span><br><span class="line">BtnPopconfirm.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.component(BtnPopconfirm.name, BtnPopconfirm);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BtnPopconfirm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后就支持Vue.use了</span></span><br></pre></td></tr></table></figure><h3 id="Q-axios的-post-请求后台接受不到"><a href="#Q-axios的-post-请求后台接受不到" class="headerlink" title="Q: axios的 post 请求后台接受不到!"></a>Q: axios的 post 请求后台接受不到!</h3><p>axios默认是 json 格式提交,确认后台是否做了对应的支持;<br>若是只能接受传统的表单序列化,就需要自己写一个转义的方法,<br>当然还有一个更加省事的方案,装一个小模块qs</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install qs -S</span></span><br><span class="line"><span class="comment">// 然后在对应的地方转就行了,单一请求也行,拦截器也行,我是写在拦截器的.</span></span><br><span class="line"><span class="comment">// 具体可以看看我 axios 封装那篇文章</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//POST传参序列化(添加请求拦截器)</span></span><br><span class="line">Axios.interceptors.request.<span class="keyword">use</span>(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做某件事</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      config.method === <span class="string">"post"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 序列化</span></span><br><span class="line">      config.data = qs.stringify(config.data); <span class="comment">// ***** 这里转义</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若是有做鉴权token , 就给头部带上token</span></span><br><span class="line">    <span class="keyword">if</span> (localStorage.<span class="built_in">token</span>) &#123;</span><br><span class="line">      config.headers.Authorization = localStorage.<span class="built_in">token</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">error</span> =&gt; &#123;</span><br><span class="line">    Message(&#123;</span><br><span class="line">      <span class="comment">//  饿了么的消息弹窗组件,类似toast</span></span><br><span class="line">      showClose: true,</span><br><span class="line">      message: <span class="built_in">error</span>,</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">"error.data.error.message"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> Promise.reject(<span class="built_in">error</span>.data.<span class="built_in">error</span>.message);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Q-Vue支持jsx的写法么"><a href="#Q-Vue支持jsx的写法么" class="headerlink" title="Q: Vue支持jsx的写法么"></a>Q: Vue支持jsx的写法么</h3><p>可以很确定的告诉你，是支持的；</p><p>但是和React是有所差异的，而非完全等同的，具体可以看官方的支持库(<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">github.com/vuejs/jsx</a>)</p><h3 id="Q-Invalid-prop-type-check-failed-for-prop-“xxx”-Expected-Boolean-got-String"><a href="#Q-Invalid-prop-type-check-failed-for-prop-“xxx”-Expected-Boolean-got-String" class="headerlink" title="Q: Invalid prop: type check failed for prop “xxx”. Expected Boolean, got String."></a>Q: Invalid prop: type check failed for prop “xxx”. Expected Boolean, got String.</h3><p>这种问题一般就是组件内的 props 类型已经设置了接受的范围类型,</p><p>而你传递的值却又不是它需要的类型,写代码严谨些 OK?</p><h3 id="Q-过滤器可以用于DOM区域结合指令么"><a href="#Q-过滤器可以用于DOM区域结合指令么" class="headerlink" title="Q: 过滤器可以用于DOM区域结合指令么?"></a>Q: 过滤器可以用于DOM区域结合指令么?</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">// 不行,看下面的错误例子</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in range | sortByDesc | spliceText"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// `vue2+`的指令只能用语 mustache`</span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="xml">` , 正确姿势如下:</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; message | capitalize &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="Q-Array-mapState-SOME-MUTATION-state-increment-commit-这种写法是什么鬼"><a href="#Q-Array-mapState-SOME-MUTATION-state-increment-commit-这种写法是什么鬼" class="headerlink" title="Q: [,Array],,mapState,[SOME_MUTATION] (state) {},increment ({ commit }) {}这种写法是什么鬼!"></a>Q: [,Array],,mapState,[SOME_MUTATION] (state) {},increment ({ commit }) {}这种写法是什么鬼!</h3><p>出门左拐,ES6+(ES2015+)的基础去过一遍,</p><p>上面依次:数组解构,对象解构,对象风格函数,对象解构赋值传递</p><h3 id="Q-我的-Vue-网站为什么-UC-访问一片空白亦或者flex布局错乱"><a href="#Q-我的-Vue-网站为什么-UC-访问一片空白亦或者flex布局错乱" class="headerlink" title="Q: 我的 Vue 网站为什么 UC 访问一片空白亦或者flex布局错乱!!"></a>Q: 我的 Vue 网站为什么 UC 访问一片空白亦或者flex布局错乱!!</h3><p>来来来,墙角走起,. UC 号称移动界的 IE 这称号不是白叫的</p><ul><li>flexbox 布局错乱,一般是你没有把兼容方案写上,就是带各种前缀,复合属性拆分，引入 autoprefixer, 写上兼容范围就好了.</li><li>UC访问空白, 有一种情况绝对会造成,那就是 ES6的代码降级不够彻底. 其他情况可能就是路由配置问题(自己去排除)</li><li>现在的开发都推荐按需引入,靠babel-preset-env 来控制,以达到打包体积减小.</li><li>但是这样做的后果,有些内核比较老的,嘿嘿,拜拜,</li><li>所以最好把代码完全 ES5话!!记住有些特性不能乱使用,没有对应的 polyfill,比如 ES6 的proxy</li></ul><h3 id="Q-this-set-this-xxx-这个-是个什么意思-是-jQuery的么-会冲突么"><a href="#Q-this-set-this-xxx-这个-是个什么意思-是-jQuery的么-会冲突么" class="headerlink" title="Q:this.$set | this.$xxx 这个 $ 是个什么意思?是 jQuery的么,会冲突么?"></a>Q:this.$set | this.$xxx 这个 $ 是个什么意思?是 jQuery的么,会冲突么?</h3><p>且看我细细道来.</p><p>Vue 的$和 jQuery 的$并没有半毛钱的关系,就跟javascript和java一样.</p><p>Vue 的$是封装了一些 vue 的内建函数,然后导出以$开头,这显然并不是 jQuery的专利;</p><p>jQuery 的$是选择器!!取得 DOM区域,两者的作用完全不一致!</p><h3 id="Q-Module-not-found-Error-Can’t-resolve-‘xxx-loader’-in-xxxx"><a href="#Q-Module-not-found-Error-Can’t-resolve-‘xxx-loader’-in-xxxx" class="headerlink" title="Q:Module not found: Error : Can’t resolve ‘xxx-loader’ in xxxx"></a>Q:Module not found: Error : Can’t resolve ‘xxx-loader’ in xxxx</h3><p>这里问题一般就是webpack的配置文件你改动了或对应的loader 没有装上</p><h3 id="Q-父组件可以直接调用子组件的方法么"><a href="#Q-父组件可以直接调用子组件的方法么" class="headerlink" title="Q: 父组件可以直接调用子组件的方法么!"></a>Q: 父组件可以直接调用子组件的方法么!</h3><p>可以,通过$refs或者$chilren来拿到对应的实例,从而操作</p><h3 id="Q-Error-in-event-handler-for-“click”-”xxx”"><a href="#Q-Error-in-event-handler-for-“click”-”xxx”" class="headerlink" title="Q:Error in event handler for “click”:”xxx”"></a>Q:Error in event handler for “click”:”xxx”</h3><p>这个问题大多都是你写的代码有问题.你的事件触发了.</p><p>但是组件内部缺少对应的实现或者变量,所以抛出事件错误.</p><p>解决方案:看着报错慢慢排查</p><h3 id="Q-组件的通讯有哪几种啊"><a href="#Q-组件的通讯有哪几种啊" class="headerlink" title="Q: 组件的通讯有哪几种啊!"></a>Q: 组件的通讯有哪几种啊!</h3><p>基本最常用的是这三种;</p><ol><li>父传子: props</li><li>子传父: emit</li><li>兄弟通讯:<ul><li>event bus: 就是找一个中间组件来作为信息传递中介</li><li>vuex: 信息树</li></ul></li></ol><p>传送门:</p><p>基本通讯<br><a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">Vuex</a></p><h3 id="Q-既然localStorage和sessionStorage能做到数据维护-为什么还要引入vuex"><a href="#Q-既然localStorage和sessionStorage能做到数据维护-为什么还要引入vuex" class="headerlink" title="Q:既然localStorage和sessionStorage能做到数据维护,为什么还要引入vuex!"></a>Q:既然localStorage和sessionStorage能做到数据维护,为什么还要引入vuex!</h3><p>这个问题问得好,Vuex的目的用来维护同级组件间的数据通讯,拥有一个共同的状态树;</p><p>仅仅活在SPA的里面的<strong>伪多页(路由)</strong>内,<br>这种东东明明然localStorage和sessionStorage</p><p>也可以做到,还能做到跨页面数据维护,还不会被浏览器刷新干掉,</p><p>为什么还要引入 vuex, 我个人觉得原因只有这么一个,”可维护性”和”易用性”及</p><p>怎么理解呢?</p><ul><li>可维护性: 因为是单向数据流,所有状态是有迹可循的,数据的传递也可以及时分发响应</li><li>易用性: 它使得我们组件间的通讯变得更强大,而不用借助中间件这类来实现不同组件间的通讯</li></ul><p>而且代码量不多,若是你要用 ls或者ss,你必须手动去跟踪维护你的状态表,<br>虽说可行,但是代码量会多很多,而且可读性很差,</p><p>是不是每个项目都需要用到vuex?</p><p>答案是否定的,小型项目上这个反而是累赘,这东西一般是用在中型项目+的,</p><p>因为里面涉及需要维护的数据比较多,同级组件间的通讯比较频繁</p><p>若是用到vuex的项目记得结合ss或者ls来达到某些状态持久化!为什么看下面!</p><h3 id="Q-vuex的用户信息为什么还要存一遍在浏览器里-sessionStorage或localStorage"><a href="#Q-vuex的用户信息为什么还要存一遍在浏览器里-sessionStorage或localStorage" class="headerlink" title="Q:vuex的用户信息为什么还要存一遍在浏览器里(sessionStorage或localStorage)"></a>Q:vuex的用户信息为什么还要存一遍在浏览器里(sessionStorage或localStorage)</h3><p><strong>因为 vuex的 store 刷新就没有.</strong><br>保存在浏览器的缓存内,若用户刷新的话,值再取一遍呗;</p><h3 id="Q-”有-Vue-Vue-Router-Vuex”或什么”express-vue-mongodb”的项目学习么"><a href="#Q-”有-Vue-Vue-Router-Vuex”或什么”express-vue-mongodb”的项目学习么" class="headerlink" title="Q:”有 Vue + Vue Router + Vuex”或什么”express + vue + mongodb”的项目学习么"></a>Q:”有 Vue + Vue Router + Vuex”或什么”express + vue + mongodb”的项目学习么</h3><p>Github 一搜一大堆,提这些问题的人动动脑子!.传送门:<a href="http://github.com/" target="_blank" rel="noopener">Github</a></p><h3 id="Q-我会-Vue-我还需要学习-jQuery-或者原生-JS-么"><a href="#Q-我会-Vue-我还需要学习-jQuery-或者原生-JS-么" class="headerlink" title="Q:我会 Vue 我还需要学习 jQuery 或者原生 JS 么"></a>Q:我会 Vue 我还需要学习 jQuery 或者原生 JS 么</h3><p>jQuery还有很多公司在用,源码可以学习的地方很多，框架只是加快开发,提高效率,但不是你在这一行长期立足的根本;</p><p>大佬们都是各种设计模式和算法玩的好，才能写出这么优秀的框架。</p><p>前端的人不仅需要宽度,也要深度,这样才能走的更远</p><h3 id="Q-npm-run-dev-报端口错误-Error-listen-EADDRINUSE-8080"><a href="#Q-npm-run-dev-报端口错误-Error-listen-EADDRINUSE-8080" class="headerlink" title="Q: npm run dev 报端口错误!Error: listen EADDRINUSE :::8080"></a>Q: npm run dev 报端口错误!Error: listen EADDRINUSE :::8080</h3><p>自己用 webpack搭脚手架的都不用我说了;<br>Vue-cli 里面的 webpack 配置: config/index.js</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dev:</span> &#123;</span><br><span class="line"><span class="symbol">    env:</span> require(<span class="string">"./dev.env"</span>),</span><br><span class="line"><span class="symbol">    port:</span> <span class="number">8080</span>, <span class="comment">//  这里这里,若是这个端口已经给系统的其他程序占用了.改我改我!!</span></span><br><span class="line"><span class="symbol">    autoOpenBrowser:</span> true,</span><br><span class="line"><span class="symbol">    assetsSubDirectory:</span> <span class="string">"static"</span>,</span><br><span class="line"><span class="symbol">    assetsPublicPath:</span> <span class="string">"/"</span>,</span><br><span class="line"><span class="symbol">    proxyTable:</span> &#123;</span><br><span class="line">      <span class="string">"/bp-api"</span>: &#123;</span><br><span class="line"><span class="symbol">        target:</span> <span class="string">"http://new.d.st.cn"</span>,</span><br><span class="line"><span class="symbol">        changeOrigin:</span> true,</span><br><span class="line">        <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">        <span class="comment">//   "^/bp-api": "/"</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Q-什么时候用v-if-什么用-v-show"><a href="#Q-什么时候用v-if-什么用-v-show" class="headerlink" title="Q: 什么时候用v-if,什么用 v-show!"></a>Q: 什么时候用v-if,什么用 v-show!</h3><p>我们先来说说两者的核心差异;</p><ul><li><p>v-if :  DOM 区域没有生成,没有插入文档,等条件成立的时候才动态插入到页面!</p><ul><li>有些需要遍历的数组对象或者值,最好用这货控制,等到拿到值才处理遍历,不然一些操作过快的情况会报错,比如数据还没请求到!</li></ul></li></ul><ul><li><p>v-show: DOM 区域在组件渲染的时候同时渲染了,只是单纯用 css 隐藏了</p><ul><li>对于下拉菜单,折叠菜单这些数据基本不怎么变动.用这个最合适了,而且可以改善用户体验,因为它不会导致页面的重绘,DOM 操作会!</li></ul></li></ul><p>简言之: DOM结构不怎么变化的用v-show, 数据需要改动很大或者布局改动的用v-if</p><h3 id="Q-是什么-html5的标签么"><a href="#Q-是什么-html5的标签么" class="headerlink" title="Q: 是什么,html5的标签么?"></a>Q: <template>是什么,html5的标签么?</template></h3><p>你猜对了,html5的标签还真有这么一个.传送门Can I Use:template</p><p>不过 Vue 的 template 有点不一样,不是去给浏览器解析的,</p><p>你可以理解为一个临时标签,用来方便你写循环,判断的,</p><p>因为最终 template 不会解析到浏览器的页面,他只是在 Vue 解析的过程充当一个包裹层!</p><p>最终我们看到的是内部处理后的组合的 DOM 结构!</p><h3 id="Q-Vue支持类似React的-props-吗"><a href="#Q-Vue支持类似React的-props-吗" class="headerlink" title="Q: Vue支持类似React的{,props}吗"></a>Q: Vue支持类似React的{,props}吗</h3><p>jsx的写法肯定是支持的，常规的写法也支持，用v-bind=”propsObject”会自动展开</p><h3 id="Q-Uncaught-ReferenceError-Vue-is-not-defined"><a href="#Q-Uncaught-ReferenceError-Vue-is-not-defined" class="headerlink" title="Q: Uncaught ReferenceError : Vue is not defined!"></a>Q: Uncaught ReferenceError : Vue is not defined!</h3><p>依次排除:</p><ul><li>Vue是否正确引入!</li><li>Vue是否正确实例化!</li><li>Vue 用的姿势是否正确(比如你直接一个 Vue 的变量!刚好又没定义,,具体问题具体分析吧)</li></ul><h3 id="Q-ERROR-in-static-js-xxxxxxx-js-from-UglifyJs"><a href="#Q-ERROR-in-static-js-xxxxxxx-js-from-UglifyJs" class="headerlink" title="Q: ERROR in static/js/xxxxxxx.js from UglifyJs"></a>Q: ERROR in static/js/xxxxxxx.js from UglifyJs</h3><p>我知道其中一种情况会报这种情况,就是你引入的 js,是直接引入压缩版本后的 js(xxx.min.js);</p><p>然后 webpack 内又启用了 UglifyJs(压缩 JS的), 二重压缩大多都会报错!!</p><p><strong>解决方案:引入标准未压缩的 JS</strong></p><h3 id="Q-props不使用-v-bind-可以传递值么"><a href="#Q-props不使用-v-bind-可以传递值么" class="headerlink" title="Q:props不使用:(v-bind)可以传递值么!"></a>Q:props不使用:(v-bind)可以传递值么!</h3><p>可以,只是默认传递的类型会被解析成字符串!</p><p>若是要传递其他类型,该绑定还是绑定!!</p><h3 id="Q-Uncaught-TypeError-Cannot-set-property-xxx-which-has-only-a-getter"><a href="#Q-Uncaught-TypeError-Cannot-set-property-xxx-which-has-only-a-getter" class="headerlink" title="Q: Uncaught TypeError : Cannot set property xxx which has only a getter"></a>Q: Uncaught TypeError : Cannot set property xxx which has only a getter</h3><p>这个问题就是你要操作的属性只允许 getter,不允许 setter;</p><p>解决方案? 用了别人的东西就要遵循别人的套路来,不然就只能自己动手丰衣足食了!!</p><h3 id="Q-单组件中里面的-import-xxx-from-‘-components-layout-xxx’中的-是什么鬼"><a href="#Q-单组件中里面的-import-xxx-from-‘-components-layout-xxx’中的-是什么鬼" class="headerlink" title="Q: 单组件中里面的 import xxx from ‘@/components/layout/xxx’中的@是什么鬼!"></a>Q: 单组件中里面的 import xxx from ‘@/components/layout/xxx’中的@是什么鬼!</h3><p>这是 webpack 方面的知识,看到了也说下吧,</p><p>webpack可以配置alias(也就是路径别名),玩过 linux 或者 mac 都知道</p><p>依旧如上,会自己搭脚手架的不用我说了,看看 vue-cli 里面的;</p><p>文件名: build -&gt; webpack.base.conf.js</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">resolve</span>: &#123;</span><br><span class="line">    <span class="attribute">extensions</span>: [<span class="string">".js"</span>, <span class="string">".vue"</span>, <span class="string">".json"</span>], // 可以导入的时候忽略的拓展名范围</span><br><span class="line">    alias: &#123;</span><br><span class="line">      vue$: <span class="string">"vue/dist/vue.esm.js"</span>,  </span><br><span class="line">      <span class="string">"@"</span>: <span class="built_in">resolve</span>(<span class="string">"src"</span>),  // 这里就是别名了,比如@就代表直接从/src 下开始找起!</span><br><span class="line">      <span class="string">"~"</span>: <span class="built_in">resolve</span>(<span class="string">"src/components"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Q-SCSS-SASS-还是-less-stylus-好"><a href="#Q-SCSS-SASS-还是-less-stylus-好" class="headerlink" title="Q: SCSS(SASS) 还是 less,stylus 好!!"></a>Q: SCSS(SASS) 还是 less,stylus 好!!</h3><p>三者都是预处理器;<br>scss 出现最久,能做的功能比较多,但是若是普通的嵌套写法,继承,mixin 啊</p><p>这三个都差不多,会其中一个其他两个的粗浅用法基本也会了.不过!!</p><p>写法有些差异:</p><ul><li>scss: 写法上是向 css 靠齐</li><li>sass : 其实也就是 scss , 只是写法不一样,靠的是缩进</li><li>less : 跟 css 基本靠齐</li><li>stylus : 一样,靠缩进,跟pug(Jade)一样</li></ul><p>使用环境的差异:</p><ul><li>scss 可以借助 ruby 或者 node-sass或者dart-sass 编译</li><li>less 可以用 less.js 或者对应的 loader 解析</li><li>stylus 只能借助 loader 解析,它的出现就是基于 node 的</li></ul><p>也有一个后起之秀,主打解耦,插件化的! 那就是PostCSS,这个是后处理器!<br>有兴趣的可以自行去了解,上面的写法都能借助插件实现!</p><h3 id="Q-Failed-to-compile-with-x-errors-This-dependency-was-not-found"><a href="#Q-Failed-to-compile-with-x-errors-This-dependency-was-not-found" class="headerlink" title="Q:Failed to compile with x errors : This dependency was not found !"></a>Q:Failed to compile with x errors : This dependency was not found !</h3><p>编译错误,对应的依赖没找到!</p><p>解决如下:</p><ul><li>知道缺少对应的模块,直接装进去</li><li>若是一个你已经安装的大模块(比如 axios)里面的子模块(依赖包)出了问题,卸载重装整个大模块.因为你补全不一定有用!</li></ul><h3 id="Q-SyntaxError-Unexpected-identifier"><a href="#Q-SyntaxError-Unexpected-identifier" class="headerlink" title="Q:SyntaxError: Unexpected identifier"></a>Q:SyntaxError: Unexpected identifier</h3><p>语法错误,看错误信息去找到对应的页面排查!</p><h3 id="Q-为什么我的-npm-或者-yarn-安装依赖会生成-lock文件-有什么用"><a href="#Q-为什么我的-npm-或者-yarn-安装依赖会生成-lock文件-有什么用" class="headerlink" title="Q: 为什么我的 npm 或者 yarn 安装依赖会生成 lock文件,有什么用!"></a>Q: 为什么我的 npm 或者 yarn 安装依赖会生成 lock文件,有什么用!</h3><p>lock 文件的作用是统一版本号,这对团队协作有很大的作用;</p><p>若是没有 lock 锁定,根据package.json里面的^,~这些,</p><p>不同人,不同时间安装出来的版本号不一定一致;</p><p>有些包甚至有一些breaking change(破坏性的更新),造成开发很难顺利进行!</p><h3 id="Q-组件可以缓存么"><a href="#Q-组件可以缓存么" class="headerlink" title="Q: 组件可以缓存么?"></a>Q: 组件可以缓存么?</h3><p><strong>可以,用keep-alive;</strong></p><p>不过是有代价的,占有内存会多了,所以无脑的缓存所有组件!别说性能好了,切换几次,<br>有些硬件 hold不住的,浏览器直接崩溃或者卡死,</p><p>所以keep-alive一般缓存都是一些列表页,不会有太多的操作,更多的只是结果集的更换,</p><p>给路由的组件meta增加一个标志位,结合v-if就可以按需加上缓存了!</p><h3 id="Q-package-json里面的dependencies-和devDependencies的差异"><a href="#Q-package-json里面的dependencies-和devDependencies的差异" class="headerlink" title="Q:package.json里面的dependencies 和devDependencies的差异!"></a>Q:package.json里面的dependencies 和devDependencies的差异!</h3><p>其实不严格的话,没有特别的差异;<br>若是严格,遵循官方的理解;</p><ul><li>dependencies : 存放线上或者业务能访问的核心代码模块,比如 vue,vue-router;</li><li>devDependencies: 处于开发模式下所依赖的开发模块,也许只是用来解析代码,转义代码,但是不产生额外的代码到生产环境, 比如什么babel-core这些</li></ul><p>如何把包安装到对应的依赖下呢?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save xxxx // dependencies</span></span><br><span class="line">npm <span class="keyword">install</span> <span class="comment">--save-dev xxxx // devDependencies</span></span><br><span class="line"></span><br><span class="line">//也能用简易的写法(i:<span class="keyword">install</span>,-S:<span class="keyword">save</span>,-D:<span class="keyword">save</span>-dev)</span><br><span class="line"></span><br><span class="line">npm i -S xxxx // npm <span class="keyword">install</span> <span class="comment">--save xxxx</span></span><br><span class="line">npm i -D xxxx // npm <span class="keyword">install</span> <span class="comment">--save-dev xxxx</span></span><br></pre></td></tr></table></figure><h3 id="Q-安装chromedriver报错-姿势没错啊npm-i-D-chromedriver"><a href="#Q-安装chromedriver报错-姿势没错啊npm-i-D-chromedriver" class="headerlink" title="Q: 安装chromedriver报错!!姿势没错啊npm i -D chromedriver"></a>Q: 安装chromedriver报错!!姿势没错啊npm i -D chromedriver</h3><p>恩,伟大的 GFW,,解决方案:指定国内的源安装就可以了</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="params">--save-dev</span> chromedriver <span class="params">--chromedriver_cdnurl=http</span>:<span class="string">//cdn.npm.taobao.org/dist/chromedriver</span></span><br></pre></td></tr></table></figure><h3 id="Q-Vue-React-Angular学习哪个好-哪个工作比较好找"><a href="#Q-Vue-React-Angular学习哪个好-哪个工作比较好找" class="headerlink" title="Q:Vue ,React, Angular学习哪个好?哪个工作比较好找!"></a>Q:Vue ,React, Angular学习哪个好?哪个工作比较好找!</h3><p>Vue属于渐进式开发,传统开发过渡 MVVM 模式的小伙伴,Vue 比较好上手,学习成本比较低<br>基础比较好的,有折腾精神的,可以选择NG5或者React 16;</p><p>NG5需要学习typescript和rxjs,还用到比较多的新东西,比如装饰器,后端的注入概念.ng有自己的一整套 MVVM 流程;</p><p>而Vue和React核心只是view,可以搭配自己喜欢的</p><p>React的写法偏向函数式写法,还有 jsx,官方自己有 flow,当然也能搭配ts,我也没怎么接触,所以也有一定的学习成本;</p><p>至于哪个比较好找工作!告诉你,若是只会一个框架,那不是一个合格的前端;</p><p>人家要的是动手能力,解决能力!!技术和待遇是成正比的!!</p><p>颜值和背景,学历,口才可以加分,但是这些条件你必须要有的基础下才能考虑这些!</p><h3 id="Q-我有个复杂组件需要有新增和编辑的功能同时存在-但是字段要保持不变性怎么破"><a href="#Q-我有个复杂组件需要有新增和编辑的功能同时存在-但是字段要保持不变性怎么破" class="headerlink" title="Q: 我有个复杂组件需要有新增和编辑的功能同时存在,但是字段要保持不变性怎么破"></a>Q: 我有个复杂组件需要有新增和编辑的功能同时存在,但是字段要保持不变性怎么破</h3><p>字段保持不变性怎么理解呢? 就是说比如新增和编辑同时共享一份 data;</p><p>有一种就是路由变了,组件渲染同一个(不引起组件的重新渲染和销毁!),但是功能却不同(新增和编译),</p><p>比如从编辑切到新增,data必须为空白没有赋值的,等待我们去赋值;</p><p>这时候有个东西就特别适合了,那就是<a href="https://immutable-js.github.io/immutable-js/" target="_blank" rel="noopener">immutable-js</a>;</p><p>这个东西可以模拟数据的唯一性!或者叫做不变性!</p><h3 id="Q-”首屏加载比较慢-怎么破-打包文件文件比较大”"><a href="#Q-”首屏加载比较慢-怎么破-打包文件文件比较大”" class="headerlink" title="Q:”首屏加载比较慢!!怎么破!打包文件文件比较大”"></a>Q:”首屏加载比较慢!!怎么破!打包文件文件比较大”</h3><p>依次排除和确认:</p><ul><li>减少第三方库的使用,比如jquey这些都可以不要了,很少操作 dom,而且原生基本满足开发</li><li>若是引入moment这些,webpack 排除国际化语言包</li><li>webpack 常规压缩js,css, 愿意折腾的还可以引入 dll 这些</li><li>路由组件采用懒加载</li><li>加入路由过渡和加载等待效果,虽然不能解决根本,但起码让人等的舒心一点不是么!</li></ul><p>整体下来,打包之后一般不会太大;</p><p>但是倘若想要更快?那就只能采用服务端渲染(SSR)了,可以避免浏览器去解析模板和指令这些; 直接返回一个 html ,.还能 SEO,</p><p><strong>Vue你们如何做spa的模块懒加载呢</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐这种写法</span></span><br><span class="line"><span class="comment">// 一来可以聚合webpackChunkName名字一样的为一个模块，也是当前版本推荐的加载姿势</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span><span class="keyword">import</span>(<span class="string">"HomePage"</span>);</span><br></pre></td></tr></table></figure><h3 id="Q-Vue-SPA-没法做优化-SEO-有解决方案么"><a href="#Q-Vue-SPA-没法做优化-SEO-有解决方案么" class="headerlink" title="Q: Vue SPA 没法做优化(SEO)!有解决方案么"></a>Q: Vue SPA 没法做优化(SEO)!有解决方案么</h3><p>可以的,ssr(服务端渲染就能满足你的需求),因为请求回来就是一个处理完毕的 html</p><p>现在 vue 的服务端开发框架有这么个比较流行,如下</p><p>传送门:<a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">Nuxt.js</a></p><p>也有官方的方案,<a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">ssr 完全指南</a></p><h3 id="Q-Vue可以写-hybird-App-么"><a href="#Q-Vue可以写-hybird-App-么" class="headerlink" title="Q: Vue可以写 hybird App 么!"></a>Q: Vue可以写 hybird App 么!</h3><p>当然可以,两个方向.</p><ul><li><a href="https://github.com/nativescript-vue/nativescript-vue" target="_blank" rel="noopener">codorva + nativescript</a></li><li><a href="https://weex.apache.org/" target="_blank" rel="noopener">Weex</a></li></ul><h3 id="Q-Vue-可以写桌面端么"><a href="#Q-Vue-可以写桌面端么" class="headerlink" title="Q: Vue 可以写桌面端么?"></a>Q: Vue 可以写桌面端么?</h3><p>当然可以,有electron和node-webkit(nw);</p><p>我只了解过electron;</p><ul><li><a href="https://www.electronjs.org/" target="_blank" rel="noopener">electron</a></li><li><a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>: Vue-cli 针对 electron 的脚手架模板</li></ul><h3 id="Q-Vue开发-项目中还需要-jQuery么"><a href="#Q-Vue开发-项目中还需要-jQuery么" class="headerlink" title="Q: Vue开发,项目中还需要 jQuery么"></a>Q: Vue开发,项目中还需要 jQuery么</h3><p>分情况探讨:</p><ol><li>若是老项目,只是单纯引入 Vue 简化开发的,依旧用吧,</li><li>重构项目?或者发起新项目的,真心没必要了.开发思路不一样,很多以前用 DOM 操作的现在基本可以数据驱动实现,而少量迫不得已的DOM 操作原生就能搞定,而且能减小打包体积,速度又快,何乐而不为!</li></ol><h3 id="Q-Vue-PC-桌面-端-M-mobile-移动-端-用什么-UI-框架好啊"><a href="#Q-Vue-PC-桌面-端-M-mobile-移动-端-用什么-UI-框架好啊" class="headerlink" title="Q:Vue PC(桌面)端,M(mobile:移动)端,用什么 UI 框架好啊!"></a>Q:Vue PC(桌面)端,M(mobile:移动)端,用什么 UI 框架好啊!</h3><p>PC: 推荐的只有两个 element UI和iview</p><p>mobile : Vux、Vant</p><h3 id="Q-Vue可以写微信小程序么-怎么搞起"><a href="#Q-Vue可以写微信小程序么-怎么搞起" class="headerlink" title="Q: Vue可以写微信小程序么,怎么搞起"></a>Q: Vue可以写微信小程序么,怎么搞起</h3><p>可以的,社区也有人出了对应的解决方案,uniapp;</p><ul><li><a href="https://uniapp.dcloud.io/" target="_blank" rel="noopener">uniapp</a></li></ul><h3 id="Q-the-“scope”-attribute-for-scoped-slots-replaced-by-“slot-scope”-since-2-5"><a href="#Q-the-“scope”-attribute-for-scoped-slots-replaced-by-“slot-scope”-since-2-5" class="headerlink" title="Q:the “scope” attribute for scoped slots replaced by “slot-scope” since 2.5"></a>Q:the “scope” attribute for scoped slots replaced by “slot-scope” since 2.5</h3><p>这个问题只出现老项目升级到 vue2.5+的时候, 提示就是 scope 现在要用 slot-scope 来代替,<br>但是 scope 暂时可以用,以后会移除</p><h3 id="Q-Vue-2-6废除的特性清单"><a href="#Q-Vue-2-6废除的特性清单" class="headerlink" title="Q:Vue 2.6废除的特性清单"></a>Q:Vue 2.6废除的特性清单</h3><p>自 2.6.0 起有所更新。已废弃的使用 slot 特性的语法在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">这里</a><br>官方推荐用v-slot来调用插槽</p><h3 id="Q-想要-mock-数据-直接请求-json文件-为什么不行"><a href="#Q-想要-mock-数据-直接请求-json文件-为什么不行" class="headerlink" title="Q:想要 mock 数据,直接请求 json文件 为什么不行!"></a>Q:想要 mock 数据,直接请求 json文件 为什么不行!</h3><p>当然不行,浏览器安全机制不允许,JS天生不能越权(NodeJS不能单纯说是JS)</p><p>你要 mock 数据,一般都有比较成熟的方案传送门:</p><ul><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">Mock</a></li><li><a href="https://github.com/easy-mock/easy-mock" target="_blank" rel="noopener">Easy Mock</a></li></ul><h2 id="Vue-周边库汇总"><a href="#Vue-周边库汇总" class="headerlink" title="Vue 周边库汇总"></a>Vue 周边库汇总</h2><p><a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener">Awesome Vue </a>: 里面收集了 Vue 方方面面的热门库!!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;文章内容覆盖范围,芝麻绿豆的破问题都有,不止于vue;&lt;br&gt;给出的是方案,而非手把手一字一句的给你说十万个为什么!&lt;/p&gt;
&lt;h2 id=&quot;问题汇总&quot;&gt;&lt;a href=&quot;#问题汇总&quot; class=&quot;headerlink&quot; title=&quot;问题汇总&quot;&gt;&lt;/a&gt;问题汇总&lt;/h2&gt;&lt;h3 id=&quot;Q-安装超时-install-timeout&quot;&gt;&lt;a href=&quot;#Q-安装超时-install-timeout&quot; class=&quot;headerlink&quot; title=&quot;Q:安装超时(install timeout)&quot;&gt;&lt;/a&gt;Q:安装超时(install timeout)&lt;/h3&gt;&lt;p&gt;方案有这么些:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;cnpm : 国内对npm的镜像版本&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="https://chongdee.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://chongdee.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>分支使用规范</title>
    <link href="https://chongdee.github.io/2021/07/20/Git/%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>https://chongdee.github.io/2021/07/20/Git/分支使用规范/</id>
    <published>2021-07-20T08:41:46.747Z</published>
    <updated>2021-07-20T08:42:53.871Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇介绍具体的规范，包括分支的划分和命名规范，不同类型的分支应对不同的场景，然后会介绍下工作流工具git-flow，如何简化我们的操作。</p><h2 id="分支构成"><a href="#分支构成" class="headerlink" title="分支构成"></a>分支构成</h2><p>master和develop分支一直存在，且名称不会变化，一般不直接修改这2个分支，由其他分支合并而来。</p><p>feature、release、hotfix分别用于功能点开发、优化，特定版本测试，线上问题紧急处理，同一类型的分支会产生多个。</p><p>分支划分如下：</p><ul><li>master：与线上版本保持绝对一致；</li><li>develop：开发分支，由下文提到的release、feature、hotfix分支合并过后的代码；</li><li>feature：实际功能点开发分支，建议每个功能新建一个feature， 具有关联关系的功能公用一个feature分支；</li><li>release：每一次开发完成之后，从develop创建出来的分支，以此分支为基准，进行测试；</li><li>hotfix：该分支主要用于修复线上bug；</li></ul><p>命名规范约定如下：</p><ul><li>feature分支命名：feature/name</li><li>release分支命名：release/name</li><li>hotfix分支命名：hotfix/name</li></ul><p>比如有一个「优化分布式Session」的需求，可在develop分支的基础上创建新分支 feature/optimize_distributed_session进行开发，开发完成后合并到develop分支。</p><h2 id="分支详细介绍和处理流程"><a href="#分支详细介绍和处理流程" class="headerlink" title="分支详细介绍和处理流程"></a>分支详细介绍和处理流程</h2><h3 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h3><p>主分支，与线上运行的版本始终保持一致，任何时候都不要直接修改master分支。</p><p>一个版本的release分支、hotfix分支开发完成后，会合并代码到master分支，也就是说master分支主要来源于release分支和hotfix分支。</p><h3 id="develop分支"><a href="#develop分支" class="headerlink" title="develop分支"></a>develop分支</h3><p>开发分支，始终保持最新完成以及bug修复后的代码，新增功能时基于该分支创建feature分支。</p><p>一个版本的release分支、hotfix分支开发完成后，也会合并到develop分支，另外，一个版本的feature功能开发完成后，也会合并到develop分支。也就是说develop分支来源于feature、release、hotfix分支。</p><h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>开发新功能或优化现有功能时，会创建feature分支，以develop为基础创建。一般会有多个功能同时开发，但上线时间可能不同，在适当的时候将特定的feature分支合并到develop分支，并创建release分支，进入测试状态。</p><h3 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a>release分支</h3><p>当一组feature开发完成，会首先合并到develop分支，开始进入提测阶段时，会创建release分支。</p><p>以release分支代码为基准提测，测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。</p><p>测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。</p><h3 id="hotfix分支"><a href="#hotfix分支" class="headerlink" title="hotfix分支"></a>hotfix分支</h3><p>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</p><h2 id="特殊情况处理和注意点"><a href="#特殊情况处理和注意点" class="headerlink" title="特殊情况处理和注意点"></a>特殊情况处理和注意点</h2><p>develop分支已存在未上线的feature代码, 此时需要紧急上线一个新功能, 但develop的代码不能上，如何处理 ？</p><ul><li>以master为基线创建feature， 在完成之后，代码合并到master分支；</li><li>为了保证develop是最新代码，需要从master合并到develop分支；</li></ul><p>以develop为基线，创建了f1和f2两个feature分支之后, f1,f2开发一半的时候，发现两个分支代码需要有依赖怎么办 ？</p><p>最好在开发开始前确定两个功能是否相关,若相关则只创建一个分支,两个功能在一起开发;<br>如果已经创建，则需要合并到一个分支；</p><p>一定要保证commit历史记录的整洁，代码合并时，根据情况选择merge或rebase;</p><p>使用<strong>rebase注意</strong>，一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作；</p><p>提交说明规范：</p><ul><li>提交说明最好限制在一行以内，50个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解；</li><li>如果关联jira，写上jira地址；</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621b66e3c8a8d15?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="git-flow工具"><a href="#git-flow工具" class="headerlink" title="git-flow工具"></a>git-flow工具</h2><p>上面的流程在第一次接触时，会觉得有点复杂，通过git-flow工具可以把这些流程自动化。它是一个命令行工具，支持各个平台，比如OSX、Linux、Windows等支持。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>通过 git flow init 命令进行初始化，以交互式的方式进行，主要是约定分支的命名，建议使用默认值；</p><h3 id="开发新功能"><a href="#开发新功能" class="headerlink" title="开发新功能"></a>开发新功能</h3><p>git flow feature start f1 添加新特性，这个操作创建了一个基于develop的特性分支，并切换到这个分支之下。</p><p>git flow feature finish f1 完成新特性，这个操作会合并f1分支到develop分支，并删除特性分支，切换回develop分支。</p><p>git flow feature publish f1 发布新分支，发布新特性分支到远程服务器，其它用户也可以使用这分支。</p><h3 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h3><p>git flow release start r1 [BASE] 创建发布版本，[BASE]是以哪个分支或commit为基础进行发版，一般为develop。</p><p>git flow release publish r1 发布release分支，其他同事就可以看到这个分支，并修改一些小问题。</p><p>git flow release finish r1 完成release分支，会合并release分支到master分支，用release分支名打Tag，合并release分支到 develop分支，最后移除release分支。</p><h3 id="修复线上问题"><a href="#修复线上问题" class="headerlink" title="修复线上问题"></a>修复线上问题</h3><p>有可能需要修正 master 分支上某个 TAG 标记的生产版本。</p><p>git flow hotfix start VERSION [BASENAME] 创建hotfix分支，VERSION 参数标记着修正版本，[BASENAME]为finish release时填写的版本号。</p><p>git flow hotfix finish VERSION，当完成紧急修复分支，代码合并到develop和 master分支。相应地，master分支打上修正版本的 TAG。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621fe4eee2e8e95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇介绍具体的规范，包括分支的划分和命名
      
    
    </summary>
    
      <category term="Git" scheme="https://chongdee.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://chongdee.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git 工作流和git commit规范</title>
    <link href="https://chongdee.github.io/2021/07/20/Git/git%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%92%8Cgit%20commit%E8%A7%84%E8%8C%83/"/>
    <id>https://chongdee.github.io/2021/07/20/Git/git 工作流和git commit规范/</id>
    <published>2021-07-20T08:41:38.192Z</published>
    <updated>2021-07-20T08:42:32.703Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>统一团队的Git工作流，包括分支使用、tag规范、issue等</li><li>统一团队的Git Commit日志标准，便于后续代码review,版本发布以及日志自动化生成</li></ul><h2 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h2><ul><li><p>git flow工作流：</p><ul><li>master为主分支，属保护分支，不能直接在此进行代码修改和提交。</li><li>develop为日常使用分支。</li><li>feature新功能分支，当完成一个功能并测试通过后进行合并到develop分支中。</li><li>hotfix线上紧急漏洞修复分支，从master分支拉取创建，修复完bug后合并到master和develop分支中。</li></ul></li></ul><ul><li>gitlab flow工作流（最大原则叫做”上游优先”（upsteam first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支）：</li></ul><p><strong>master-&gt;pre-production-&gt;production</strong></p><ul><li>master开发环境分支</li><li>pre-production预发环境分支</li><li>production生产环境分支</li></ul><h2 id="git-commit规范"><a href="#git-commit规范" class="headerlink" title="git commit规范"></a>git commit规范</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BLANK</span> <span class="attr">LINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BLANK</span> <span class="attr">LINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">占位标签解析：</span><br><span class="line"><span class="section">type:代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。所有的type类型如下：</span></span><br><span class="line"><span class="section">scope:scope说明commit影响的范围。scope依据项目而定，</span></span><br><span class="line">例如在业务项目中可以依据菜单或者功能模块划分，</span><br><span class="line">如果是组件库开发，则可以依据组件划分。</span><br><span class="line"><span class="section">subject:是commit的简短描述</span></span><br><span class="line"><span class="section">body:提交代码的详细描述</span></span><br><span class="line"><span class="section">footer:如果代码的提交是不兼容变更或关闭缺陷，则Footer必需，否则可以省略。</span></span><br><span class="line"></span><br><span class="line"><span class="section">feat[特性]:新增feature </span></span><br><span class="line"><span class="section">fix[修复]: 修复bug     </span></span><br><span class="line"><span class="section">docs[文档]: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等</span></span><br><span class="line"><span class="section">style[格式]: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑</span></span><br><span class="line"><span class="section">refactor[重构]: 代码重构，没有加新功能或者修复bug</span></span><br><span class="line"><span class="section">perf[优化]: 优化相关，比如提升性能、体验</span></span><br><span class="line"><span class="section">test[测试]: 测试用例，包括单元测试、集成测试等</span></span><br><span class="line"><span class="section">chore[工具]: 改变构建流程、或者增加依赖库、工具等</span></span><br><span class="line"><span class="section">revert[回滚]: 回滚到上一个版本</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">特性:添加头像功能</span></span><br><span class="line"><span class="section">特性:添加收藏功能</span></span><br><span class="line"><span class="section">修复:在android机器上传崩溃问题解决</span></span><br><span class="line"><span class="section">文档:修改README,增加了使用说明</span></span><br><span class="line"><span class="section">优化:首页图片加载缓慢优化</span></span><br><span class="line"><span class="section">重构:对头像功能进行封装重构</span></span><br></pre></td></tr></table></figure><h2 id="Git标签打包规范"><a href="#Git标签打包规范" class="headerlink" title="Git标签打包规范"></a>Git标签打包规范</h2><p><strong>Tag版本号：</strong>Tag包括3位版本，前缀使用v。比如v1.2.31。Tag命名规范：</p><p>1.新功能开发使用第2位版本号，bug修复使用第3位版本号</p><p>2.首版本号是全新的功能类，功能模块上线才做的调整</p><p><strong>标题格式：项目名-日期内容格式：&lt;分类&gt;—&lt;内容&gt;&lt;分类&gt;：</strong><br>新功能、bug修复、优化、依赖升级、重构、漏洞&amp;补丁</p><p><strong>示例：</strong><br>此图片引用自:<a href="https://juejin.cn/post/6844903619662200839" target="_blank" rel="noopener">我们的GIT工作流</a></p><h2 id="Git-Commit格式校验"><a href="#Git-Commit格式校验" class="headerlink" title="Git Commit格式校验"></a>Git Commit格式校验</h2><ul><li>准备commitlint/cli用于格式校验</li><li>准备husky用于git提交代码时触发校验</li></ul><p>全局安装commitlint/cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure><p>2.在项目根目录创建配置文件commitlint.config.js，可以使用以下命令创建</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"module.exports = &#123;extends: ['@commitlint/config-conventional']&#125;"</span> &gt; commitlint<span class="selector-class">.config</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p>3.在配置文件中定义提交规范，可使用以下配置：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"module.exports = &#123;extends: ['@commitlint/config-conventional']&#125;"</span></span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'type-enum'</span>: [<span class="number">2</span>, <span class="string">'always'</span>, [</span><br><span class="line">      <span class="string">"feat"</span>, <span class="string">"fix"</span>, <span class="string">"docs"</span>, <span class="string">"style"</span>, <span class="string">"refactor"</span>, <span class="string">"test"</span>, <span class="string">"chore"</span>, <span class="string">"revert"</span></span><br><span class="line">    ]],</span><br><span class="line">    <span class="string">'subject-full-stop'</span>: [<span class="number">0</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'subject-case'</span>: [<span class="number">0</span>, <span class="string">'never'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.项目添加husky，进行git提交触发校验，安装如下：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>5.安装完成后在package.json中配置如下信息</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"commitmsg"</span>: <span class="string">"commitlint -e $GIT_PARAMS"</span>,</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"config"</span>: &#123;</span><br><span class="line">    <span class="string">"commitizen"</span>: &#123;</span><br><span class="line">      <span class="string">"path"</span>: <span class="string">"cz-customizable"</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>6.经过以上步骤，git commit的规范校验已经完成。可以进行代码提交了。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不规范提交&gt;git commit -m <span class="string">"添加新功能"</span></span><br><span class="line">提示：</span><br><span class="line">⧗   input: 添加新功能</span><br><span class="line">✖   subject may <span class="keyword">not</span> be empty [subject-empty]</span><br><span class="line">✖  <span class="built_in"> type </span>may <span class="keyword">not</span> be empty [type-empty]</span><br><span class="line"></span><br><span class="line">规范提交&gt;git commit -m <span class="string">"feat: 添加新功能"</span></span><br></pre></td></tr></table></figure><p>汉化与自定义校验规则<br>1.当前项目安装commitlint-config-cz，如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitlint-<span class="built_in">config</span>-cz <span class="comment">--save-dev</span></span><br></pre></td></tr></table></figure><p>2.commitlint校验规则配置添加如下设置：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">'cz'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.下载官方配置文件进行修改。官方配置文件cz-config-EXAMPLE.js。修改示例如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line"><span class="symbol">  types:</span> [</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'特性'</span>,<span class="string">name:</span> <span class="string">'特性:    一个新的特性'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'修复'</span>,<span class="string">name:</span> <span class="string">'修复:    修复一个Bug'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'文档'</span>,<span class="string">name:</span> <span class="string">'文档:    变更的只有文档'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'格式'</span>,<span class="string">name:</span> <span class="string">'格式:    空格, 分号等格式修复'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'重构'</span>,<span class="string">name:</span> <span class="string">'重构:    代码重构，注意和特性、修复区分开'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'性能'</span>,<span class="string">name:</span> <span class="string">'性能:    提升性能'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'测试'</span>,<span class="string">name:</span> <span class="string">'测试:    添加一个测试'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'工具'</span>,<span class="string">name:</span> <span class="string">'工具:    开发工具变动(构建、脚手架工具等)'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'回滚'</span>,<span class="string">name:</span> <span class="string">'回滚:    代码回退'</span>&#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line"><span class="symbol">  scopes:</span> [</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'用户模块'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'订单模块'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'社区模块'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'商品模块'</span>&#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// it needs to match the value for field type. Eg.: 'fix'</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  scopeOverrides: &#123;</span></span><br><span class="line"><span class="comment">    fix: [</span></span><br><span class="line"><span class="comment">      &#123;name: 'merge'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'style'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'e2eTest'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'unitTest'&#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// override the messages, defaults are as follows</span></span><br><span class="line"><span class="symbol">  messages:</span> &#123;</span><br><span class="line"><span class="symbol">    type:</span> <span class="string">'选择一种你的提交类型:'</span>,</span><br><span class="line"><span class="symbol">    scope:</span> <span class="string">'选择一个scope (可选):'</span>,</span><br><span class="line">    <span class="comment">// used if allowCustomScopes is true</span></span><br><span class="line"><span class="symbol">    customScope:</span> <span class="string">'Denote the SCOPE of this change:'</span>,</span><br><span class="line"><span class="symbol">    subject:</span> <span class="string">'简要说明:\n'</span>,</span><br><span class="line"><span class="symbol">    body:</span> <span class="string">'详细说明，使用"|"换行(可选)：\n'</span>,</span><br><span class="line"><span class="symbol">    breaking:</span> <span class="string">'非兼容性说明 (可选):\n'</span>,</span><br><span class="line"><span class="symbol">    footer:</span> <span class="string">'关联关闭的issue，例如：#31, #34(可选):\n'</span>,</span><br><span class="line"><span class="symbol">    confirmCommit:</span> <span class="string">'确定提交?'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="symbol">  allowCustomScopes:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">  allowBreakingChanges:</span> [<span class="string">'特性'</span>, <span class="string">'修复'</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// limit subject length</span></span><br><span class="line"><span class="symbol">  subjectLimit:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="生成changelog"><a href="#生成changelog" class="headerlink" title="生成changelog"></a>生成changelog</h2><p>1.安装conventional-changelog，可以快速生成提交日志</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g conventional-changelog-cli</span><br><span class="line">npm <span class="keyword">install</span> -g cz-conventional-changelog</span><br></pre></td></tr></table></figure><p>2.项目根目录下添加 .czrc 配置文件,文件内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"path"</span>: <span class="string">"cz-conventional-changelog"</span> &#125;</span><br></pre></td></tr></table></figure><p>3.在package.json中的scripts项增加如下指令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"version"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -s -r 0 &amp;&amp; git add CHANGELOG.md"</span></span><br></pre></td></tr></table></figure><p>4.执行npm run version即可在当前目录生成changelog日志了。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://juejin.cn/post/6844903831893966856" target="_blank" rel="noopener">Cz工具集使用介绍 - 规范Git提交说明</a><br><a href="https://juejin.cn/post/6844903831893966856" target="_blank" rel="noopener">git工作流程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;统一团队的Git工作流，包括
      
    
    </summary>
    
      <category term="Git" scheme="https://chongdee.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://chongdee.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
