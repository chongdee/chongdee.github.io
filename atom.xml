<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wong ardee 的博客</title>
  
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongdee.github.io/"/>
  <updated>2018-07-08T14:36:03.501Z</updated>
  <id>https://chongdee.github.io/</id>
  
  <author>
    <name>Wong ardee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markdown快速入门</title>
    <link href="https://chongdee.github.io/2017/12/05/Markdown/"/>
    <id>https://chongdee.github.io/2017/12/05/Markdown/</id>
    <published>2017-12-05T09:46:36.000Z</published>
    <updated>2018-07-08T14:36:03.501Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Markdown快速入门"><a href="#Markdown快速入门" class="headerlink" title="Markdown快速入门"></a>Markdown快速入门</h1><h2 id="一、认识Markdown"><a href="#一、认识Markdown" class="headerlink" title="一、认识Markdown"></a>一、认识Markdown</h2><blockquote><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。<br>Markdown的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。</p></blockquote><h2 id="二、入门语法"><a href="#二、入门语法" class="headerlink" title="二、入门语法"></a>二、入门语法</h2><ol><li><p>标题</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></li><li><p>列表<br> 分为有序列表和无序列表。<br> <strong>有序列表</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  #1. 点后面留一个空格</span><br><span class="line">2.  #2. 点后面留一个空格</span><br><span class="line">3.  #3. 点后面留一个空格</span><br></pre></td></tr></table></figure><p> <strong>无序列表</strong></p><blockquote><p>-或*  浏览器显示实心或空心圆</p></blockquote></li><li><p>引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是引用</span><br></pre></td></tr></table></figure></li><li><p>图片和链接<br>两者格式区别在于“ ! ”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片描述](图片链接)</span><br><span class="line">[链接描述](链接地址)</span><br></pre></td></tr></table></figure></li><li><p>粗体和斜体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**这是粗体**</span><br><span class="line">*这是斜体*</span><br></pre></td></tr></table></figure></li><li><p>表格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables | Are | Cool |</span><br><span class="line">| ------------ |:------------:| -----:|</span><br><span class="line">| col 3 is | right-aligned| $1600 |</span><br><span class="line">| col 2 is | centered | $12 |</span><br><span class="line">| zebra stripes| are neat | &amp;1 |</span><br></pre></td></tr></table></figure></li><li><p>代码框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 上 ```，下```` 符号把代码包裹起来</span><br></pre></td></tr></table></figure></li><li><p>分割线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 *** 即可。</span><br></pre></td></tr></table></figure></li><li><p>下划线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 --- 即可</span><br></pre></td></tr></table></figure></li></ol><h2 id="Markdown命令图"><a href="#Markdown命令图" class="headerlink" title="Markdown命令图"></a>Markdown命令图</h2><p><img src="/img/command.png" alt="&quot;markdown命令图&quot;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Markdown快速入门&quot;&gt;&lt;a href=&quot;#Markdown快速入门&quot; class=&quot;headerlink&quot; title=&quot;Markdown快速入门&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="tutorial" scheme="https://chongdee.github.io/categories/tutorial/"/>
    
    
      <category term="Markdown教程" scheme="https://chongdee.github.io/tags/Markdown%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github Pages搭建个人博客教程</title>
    <link href="https://chongdee.github.io/2017/12/05/hexoTutorial/"/>
    <id>https://chongdee.github.io/2017/12/05/hexoTutorial/</id>
    <published>2017-12-05T09:31:55.000Z</published>
    <updated>2018-07-10T04:48:11.167Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇有关如何使用Github Pages和Hexo搭建自己独立博客的详尽教程，里面介绍了如何使用和配置Hexo框架，如何将Hexo部署到自己的Github项目中，域名注册，以及域名的绑定，还有我在搭建自己博客过程中所遇到的各种困难。</p><h2 id="关于Github"><a href="#关于Github" class="headerlink" title="关于Github"></a>关于Github</h2><h3 id="一、Github的优点"><a href="#一、Github的优点" class="headerlink" title="一、Github的优点"></a>一、Github的优点</h3><ul><li>GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。</li><li>GitHub可以免费使用，并且快速稳定。</li><li>Github上面的世界很精彩，用久了你的眼界会开阔很多。</li></ul><h3 id="二、什么是Github-Pages"><a href="#二、什么是Github-Pages" class="headerlink" title="二、什么是Github Pages"></a>二、什么是Github Pages</h3><p>Github Pages可以被认为是用户编写的、托管在github上的静态网页。</p><h3 id="三、为什么要使用Github-Pages"><a href="#三、为什么要使用Github-Pages" class="headerlink" title="三、为什么要使用Github Pages"></a>三、为什么要使用Github Pages</h3><ul><li>可以绑定你的域名(但暂时貌似只能绑定一个)。</li><li>简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。</li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>在 Windows 环境下安装 Node.js 非常简单，仅须到<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网下载</a>安装文件并执行即可完成安装。ps:根据自己的Windows位数选择下载安装，无脑的下一步就行，不需要配置环境变量。</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ol><li>去<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>根据你的电脑系统，下载对应版本。</li><li>下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。</li><li>鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。<ul><li>安装教程：<a href="https://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html" target="_blank" rel="noopener">如何在windows下安装Git</a></li><li>Git入门教程：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的git教程</a></li></ul></li></ol><p><strong>Git基本操作</strong></p><ul><li>git clone：#将远程仓库复制到本地：git clone #项目地址</li><li>git init：#新建一个仓库</li><li>git pull：#抓取远程仓库所有分支更新并合并到本地</li><li>git add：#跟踪新文件（把目标文件放入暂存区域）git add #文件名/文件夹,如果是跟踪全部修改过的文件：git add –all</li><li>git commit：#提交你的修改：git commit –m “写你提交的文件备注”</li><li>git push：#推送你本地仓库的更新到远程仓库，语法：git push [远程名] [本地分支]:[远程分支]</li></ul><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="一、Hexo安装"><a href="#一、Hexo安装" class="headerlink" title="一、Hexo安装"></a>一、Hexo安装</h3><p>桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g  //安装hexo</span><br><span class="line">npm install hexo-deployer-git --save  //安装hexo部署到git page的deployer</span><br></pre></td></tr></table></figure></p><h3 id="二、Hexo初始化配置"><a href="#二、Hexo初始化配置" class="headerlink" title="二、Hexo初始化配置"></a>二、Hexo初始化配置</h3><ol><li><p>创建Hexo文件夹<br>安装完成后，根据自己喜好建立目录（如E:\Blog\Hexo），直接进入E:\Blog\Hexo文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></li><li><p>本地查看效果<br>执行下面语句，执行完即可登录localhost:4000查看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></li></ol><h2 id="将博客部署到Github-Pages上"><a href="#将博客部署到Github-Pages上" class="headerlink" title="将博客部署到Github Pages上"></a>将博客部署到Github Pages上</h2><p>那么现在本地的博客已经搭建起来了，但是我们只可以通过本地连接查看我们的博客。那么我们现在需要做的就是把本地的博客发布到服务器上，让别人也可以连接我们的博客，而Github Pages就帮我完成了这件事情。但是Github Pages的代码就是寄存在Github上面的。那么接下来我们需要在Github上面创建一个新的项目。</p><h3 id="一、注册Github账户"><a href="#一、注册Github账户" class="headerlink" title="一、注册Github账户"></a>一、注册Github账户</h3><ol><li>访问<a href="https://github.com/" target="_blank" rel="noopener">Github首页</a></li><li>点击Sign up，注册自己的账户</li></ol><h3 id="二、创建项目代码库"><a href="#二、创建项目代码库" class="headerlink" title="二、创建项目代码库"></a>二、创建项目代码库</h3><ol><li><p>注册完登陆后，我们就创建一个我们自己的Github Pages项目。点击New repository。如下图：<br><img src="/img/how-to-create-reposity.png" alt="&quot;GitHub page配置图&quot;"></p><blockquote><p><strong>tips:</strong>hexo博客添加图片，音乐，视频</p></blockquote><ul><li><p>插入外部链接图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![“图片描述”](“图片地址”)</span><br></pre></td></tr></table></figure></li><li><p>添加本地图片<br>在\hexo\source目录下新建文件夹，命名为img或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![“图片描述”](/img/你的图片名字.[图片扩展名])</span><br></pre></td></tr></table></figure></li><li><p>插入音乐(next主题侧边栏插入网易音乐播放器)<br>比如网易云音乐，找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可–ps:以next主题为例<a href="http://weqeo.com/2016/10/11/Hexo%E4%B8%AD%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">在主题中侧边栏插入网易音乐教程</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 </span><br><span class="line">    src=&quot;http://music.163.com/outchain/player?type=2&amp;id=25706282&amp;auto=0&amp;height=66&quot;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></li><li><p>插入视频</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Idina Menze和Caleb Hyles激情对唱Let It Go：</span><br><span class="line">&lt;iframe </span><br><span class="line">    height=498 width=510 </span><br><span class="line">    src=&quot;http://player.youku.com/embed/XNjcyMDU4Njg0&quot; </span><br><span class="line">    frameborder=0 allowfullscreen&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="三、配置SSH密钥"><a href="#三、配置SSH密钥" class="headerlink" title="三、配置SSH密钥"></a>三、配置SSH密钥</h3><p>配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下：</p><h4 id="第一步、看看是否存在SSH密钥-keys"><a href="#第一步、看看是否存在SSH密钥-keys" class="headerlink" title="第一步、看看是否存在SSH密钥(keys)"></a>第一步、看看是否存在SSH密钥(keys)</h4><p>首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/. ssh</span><br></pre></td></tr></table></figure></p><p>检查你本机用户home目录下是否存在.ssh目录</p><p>如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。</p><h4 id="第二步、创建一对新的SSH密钥-keys"><a href="#第二步、创建一对新的SSH密钥-keys" class="headerlink" title="第二步、创建一对新的SSH密钥(keys)"></a>第二步、创建一对新的SSH密钥(keys)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br><span class="line">#这将按照你提供的邮箱地址，创建一对密钥</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><p>直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa</p><p>接着，根据提示，你需要输入密码和确认密码（说到这里，如果你很放心，其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车就行了。所谓的最安全的密码，就是没有密码 哈哈）。相关提示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure></p><p>输入完成之后，屏幕会显示如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in /c/Users/you/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</span><br></pre></td></tr></table></figure></p><h4 id="第三步、在GitHub账户中添加你的公钥"><a href="#第三步、在GitHub账户中添加你的公钥" class="headerlink" title="第三步、在GitHub账户中添加你的公钥"></a>第三步、在GitHub账户中添加你的公钥</h4><p>运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>上面操作完后：</p><ol><li>登陆GitHub,进入你的Account Settings:<br><img src="/img/SSH-github-setting.png" alt="&quot;Account Settings&quot;"></li><li>选择SSH Keys:<br><img src="/img/SSH-github-setting-SSH.png" alt="&quot;SSH Keys&quot;"></li><li>粘贴密钥，添加即可:<br><img src="/img/SSH-github-SSH-OK.png" alt="&quot;SSH Keys&quot;"></li></ol><h4 id="第四步、测试"><a href="#第四步、测试" class="headerlink" title="第四步、测试"></a>第四步、测试</h4><p>可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>如果是下面的反馈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p><p>不要紧张，输入yes就设置好了</p><h4 id="第五步、设置用户信息-SSH-Key配置成功"><a href="#第五步、设置用户信息-SSH-Key配置成功" class="headerlink" title="第五步、设置用户信息,SSH Key配置成功"></a>第五步、设置用户信息,SSH Key配置成功</h4><p>现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;ryanlijianchang&quot;//用户名</span><br><span class="line">$ git config --global user.email  &quot;liji.anchang@163.com&quot;//填写自己的邮箱</span><br></pre></td></tr></table></figure></p><h4 id="第六步、本地的Hexo文件更新到Github库中"><a href="#第六步、本地的Hexo文件更新到Github库中" class="headerlink" title="第六步、本地的Hexo文件更新到Github库中"></a>第六步、本地的Hexo文件更新到Github库中</h4><p>本机已成功连接到github。<br>第一步、登录Github打开自己的项目 username.github.io<br>第二步、打开之后，点击SSH，选择SSH类型地址<br>第三步、复制地址<br>第四步、打开你一开始创建的Hexo文件夹（如E:\Blog\Hexo），用记事本打开刚文件夹下的_config.yml文件<br>第五步、在配置文件里作如下修改，保存<br> <img src="/img/hexo_config.jpg" alt="&quot;SSH Keys&quot;"><br>第六步、在Hexo文件夹下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>或者直接执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d  //同上命令一样功能</span><br></pre></td></tr></table></figure></p><p>执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io(我的是：ryanlijianchang.github.io)。</p><p>假如这时候，报错 ERROR Deployer not found: git，那么就是你的deployer没有安装成功，你需要执行如下命令再安装一次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>这样，你再执行hexo g -d，你的博客就部署到Github上了。</p><p>第七步、在浏览器上输入自己的主页地址</p><p>在浏览器上输入Github Pager为我们生成的外链（例如我的是：<strong><a href="https://chongdee.github.io/">https://chongdee.github.io</a></strong>，而你的只需要把你的github用户名替换掉这个链接中的chongdee，因为我的用户名是这个，那么你自己的专属博客地址就是：<strong><a href="https://[您的用户名].github.io/" target="_blank" rel="noopener">https://[您的用户名].github.io/</a></strong>）即可看到自己的博客了。</p><p>当然，每一个人都可以通过这个地址访问到你的博客了。</p><h2 id="美化自己博客"><a href="#美化自己博客" class="headerlink" title="美化自己博客"></a>美化自己博客</h2><p>那么现在我们的博客已经挂在了Github服务器上面，别人已经可以通过地址来登陆我们的博客了，但是我们这时就有了新的需求，就是自己的博客并不好看，那怎么办的？这很简单，要知道很多前端开发者在Hexo框架下开发了很多的主题给我们使用，我们只需要把他们的主题克隆过来，然后通过修改配置文件即可达到我们所需要的效果。</p><p>那么我们应该怎么修改呢？<br><strong>一、进入<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo的官网主题专栏</a></strong><br><strong>二、挑选我们喜欢的主题</strong><br>可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题)<br><strong>三、克隆主题</strong><br>再打开Hexo文件夹下的themes目录（E:\Blog\hexo\themes），右键Git Bash，在命令行输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址)</span><br></pre></td></tr></table></figure></p><p>下载中，等待下载完成<br><strong>四、修改Hexo配置文件</strong><br>下载完成后，打开Hexo文件夹下的配置文件_config.yml<br>修改参数为：theme: hexo-theme-next<br><strong>五、部署主题，本地查看效果</strong><br>返回Hexo目录，右键Git Bash，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>打开浏览器，输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可看见我们的主题已经更换了。<br><strong>六、如果效果满意，将它部署到Github上</strong><br>打开Hexo文件夹，右键Git Bash，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   (必须要，不然有时因为缓存问题，服务器更新不了主题)</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></p><p><strong>七、打开自己的主页输入 <a href="http://localhost:4000/，" target="_blank" rel="noopener">http://localhost:4000/，</a> 即可看到修改后的效果</strong></p><h2 id="在博客写文章"><a href="#在博客写文章" class="headerlink" title="在博客写文章"></a>在博客写文章</h2><p>一、用hexo发表新文章<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n &quot;文章标题&quot;</span><br></pre></td></tr></table></figure></p><p>其中 我的家 为文章标题，执行命令 hexo n “hello hexo” 后，会在项目 \Hexo\source_posts 中生成 hello hexo.md文件，用编辑器打开编写即可。</p><p>当然，也可以直接在\Hexo\source_posts中新建一个md文件，我就是这么做的。 写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g #生成</span><br><span class="line">$ hexo d #部署 # 可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure></p><p>二、用Markdown写文章<br>我们注意到在 \Hexo\source_posts 文件夹下存放着我们的文章，它们的格式都是以.md格式结尾的，没错，Hexo也是支持Markdown语法的，所以当我们需要写具有格式化的文章时，我们可以使用支持Markdown语法的编辑器进行文章编译，然后保存文件到 \Hexo\source_posts 文件夹下即可。<br>复制进去之后，只要执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure></p><p>推送到我们的Github仓库即可。</p><h2 id="markdown介绍"><a href="#markdown介绍" class="headerlink" title="markdown介绍"></a>markdown介绍</h2><ol><li>那么什么是Markdown？<br> Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</li><li>Markdown有什么优点？<ul><li>专注你的文字内容而不是排版样式。</li><li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li><li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li><li>可读，直观。适合所有人的写作语言。</li></ul></li></ol><p><strong>markdown在线工具</strong><br><a href="http://note.youdao.com/iyoudao/?p=2411&amp;vendor=unsilent14" target="_blank" rel="noopener">有道云markdown指南</a><br><a href="https://maxiang.io/" target="_blank" rel="noopener">马克飞象，专为印象笔记打造的 Markdown 编辑器，非常推荐</a></p><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p><strong>hexo</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g #安装</span><br><span class="line">npm update hexo -g #更新</span><br><span class="line">hexo init #初始化</span><br></pre></td></tr></table></figure></p><p><strong>草稿</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt; #发表草稿。</span><br></pre></td></tr></table></figure></p><p><strong>写作</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;name&quot; #新建文章</span><br><span class="line">hexo g #生成静态网页</span><br><span class="line">hexo p #发表草稿。</span><br><span class="line">hexo s #启动服务</span><br><span class="line">hexo d #部署网站 参数：-g 部署之前先生成静态文件。</span><br></pre></td></tr></table></figure></p><p><strong>服务器</strong><br>Hexo 3.0 把服务器独立成了个别模块，您必须先安装才能使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server --save #安装服务</span><br><span class="line">    </span><br><span class="line">hexo s #启动服务</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo s -s #静态模式</span><br><span class="line">hexo s -i 192.168.1.1 #自定义ip</span><br><span class="line">    </span><br><span class="line">hexo clean #清除缓存</span><br></pre></td></tr></table></figure></p><p><strong>部署</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br><span class="line">hexo g -d #同上</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是一篇有关如何使用Github Pag
      
    
    </summary>
    
      <category term="tutorial" scheme="https://chongdee.github.io/categories/tutorial/"/>
    
    
      <category term="Hexo教程" scheme="https://chongdee.github.io/tags/Hexo%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ES6手册</title>
    <link href="https://chongdee.github.io/2017/12/05/ES6%E6%89%8B%E5%86%8C/"/>
    <id>https://chongdee.github.io/2017/12/05/ES6手册/</id>
    <published>2017-12-05T07:05:56.546Z</published>
    <updated>2018-07-10T07:01:58.582Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="var-和-let-const-的比较"><a href="#var-和-let-const-的比较" class="headerlink" title="var 和 let/const 的比较"></a>var 和 let/const 的比较</h2><blockquote><p>除了 var ，我们现在还可以使用两个新的标识符来定义一个变量 — let 和 const。<br>和 var 不一样的是，let 和 const 不存在变量提升。</p></blockquote><p>使用var的栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;global&apos;;</span><br><span class="line">function getFood(food) &#123;</span><br><span class="line">    if (food) &#123;</span><br><span class="line">        var name = &apos;local&apos;;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">getFood(false); // undefined</span><br></pre></td></tr></table></figure></p><p>当我们用 let 代替 var 的时候，观察会发生什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;global&apos;;</span><br><span class="line">function getFood(food) &#123;</span><br><span class="line">    if (food) &#123;</span><br><span class="line">        let name = &apos;local&apos;;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">getFood(false); // &apos;global&apos;</span><br></pre></td></tr></table></figure></p><p>当我们重构使用 var 的老代码的时候应该注意上面的变化。盲目地使用 let 替换 var 可能会出现出乎意料的情况。</p><blockquote><p><strong>注意：</strong> let 和 const 是块级作用域，因此在变量未被定义之前使用它会产生一个 ReferenceError。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(x); // ReferenceError: x is not defined</span><br><span class="line">let x = &apos;hi&apos;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>最佳实践：</strong> 在早前代码中使用 var 声明意味着需要很小心地编写代码；而当在新的项目编写代码，使用 let 声明一个可以改变的变量，用 const(常量)声明一个不能被重新赋值的变量。</p></blockquote><h2 id="用块级作用域代替-IIFES"><a href="#用块级作用域代替-IIFES" class="headerlink" title="用块级作用域代替 IIFES"></a>用块级作用域代替 IIFES</h2><blockquote><p><strong>函数立即执行表达式</strong>的常见用法是创造一个闭包作用域的函数，在 ES6 中，我们能够创造一个块级作用域<br>而不单单限于函数作用域。</p></blockquote><p>IIFES：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var name = &apos;ChaChaHui&apos;;</span><br><span class="line">&#125;());</span><br><span class="line">console.log(name); // Reference Error</span><br></pre></td></tr></table></figure></p><p>使用 ES6 的块级作用域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let name = &apos;ChaChaHui&apos;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(name); // Reference Error</span><br></pre></td></tr></table></figure></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>我们经常需要给嵌套函数维护一个作用域的上下文 <strong>this</strong>。<br>看看这个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.prefixName = function (arr) &#123;</span><br><span class="line">    return arr.map(function (character) &#123;</span><br><span class="line">        return this.name + character; // Cannot read property &apos;name&apos; of undefined</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一个常用的解决办法是把 <strong>this</strong> 存在一个变量中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.prefixName = function (arr) &#123;</span><br><span class="line">    var that = this; // Store the context of this</span><br><span class="line">    return arr.map(function (character) &#123;</span><br><span class="line">        return that.name + character;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们也可以传递一个合适的 <strong>this</strong> 上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.prefixName = function (arr) &#123;</span><br><span class="line">    return arr.map(function (character) &#123;</span><br><span class="line">        return this.name + character;</span><br><span class="line">    &#125;, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们还可以绑定上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.prefixName = function (arr) &#123;</span><br><span class="line">    return arr.map(function (character) &#123;</span><br><span class="line">        return this.name + character;</span><br><span class="line">    &#125;.bind(this));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>使用 <strong>箭头函数</strong>，<strong>this</strong> 将不会受到影响，并且我们可以重写上面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.prefixName = function (arr) &#123;</span><br><span class="line">    return arr.map(character =&gt; this.name + character);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>最佳实践:</strong>当你需要维护一个 <strong>this</strong> 上下文的时候，如在回调函数中推荐使用箭头函数，这样就可以绑定上下文 <strong>this</strong></p></blockquote><p>在我们写一个函数的时候，箭头函数更加简洁并且可以很简单地返回一个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var squares = arr.map(function (x) &#123; return x * x &#125;); // Function Expression</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3, 4, 5];</span><br><span class="line">const squares = arr.map(x =&gt; x * x); // Arrow Function for terser implementation</span><br></pre></td></tr></table></figure><blockquote><p><strong>最佳实践:</strong>尽可能的使用箭头函数代替原来的写法。</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在 ES6 中，标准库升级了很多，在这些变化中有许多新的字符串方法，比如 .includes( ) 和 .repeat( )。<br><strong>.includes()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &apos;food&apos;;</span><br><span class="line">var substring = &apos;foo&apos;;</span><br><span class="line">console.log(string.indexOf(substring) &gt; -1);</span><br></pre></td></tr></table></figure></p><p>之前我们使用 <strong>.indexOf( )</strong> 函数的返回值是否 &gt;-1 来判断字符串是否包含某些字符串，现在我们更简单地使用 <strong>.includes ( )</strong>来返回一个布尔值来判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const string = &apos;food&apos;;</span><br><span class="line">const substring = &apos;foo&apos;;</span><br><span class="line">console.log(string.includes(substring)); // true</span><br></pre></td></tr></table></figure></p><p><strong>.repeat( )</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function repeat(string, count) &#123;</span><br><span class="line">    var strings = [];</span><br><span class="line">    while(strings.length &lt; count) &#123;</span><br><span class="line">        strings.push(string);</span><br><span class="line">    &#125;</span><br><span class="line">    return strings.join(&apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 ES6 中，可以更简便地实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// String.repeat(numberOfRepetitions)</span><br><span class="line">&apos;meow&apos;.repeat(3); // &apos;meowmeowmeow&apos;</span><br></pre></td></tr></table></figure></p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>使用<strong>模版字符串</strong>我们就可以不用对某些特殊字符进行转义处理了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var text = &quot;This string contains \&quot;double quotes\&quot; which are escaped.&quot;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let text = `This string contains &quot;double quotes&quot; which don&apos;t need to be escaped anymore.`;</span><br></pre></td></tr></table></figure><p><strong>模板字符串</strong>还支持插入，可以把变量值和字符串连接起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;Tiger&apos;;</span><br><span class="line">var age = 13;</span><br><span class="line">console.log(&apos;My cat is named &apos; + name + &apos; and is &apos; + age + &apos; years old.&apos;);</span><br></pre></td></tr></table></figure></p><p>ES6语法更简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const name = &apos;Tiger&apos;;</span><br><span class="line">const age = 13;</span><br><span class="line">console.log(`My cat is named $&#123;name&#125; and is $&#123;age&#125; years old.`);</span><br></pre></td></tr></table></figure></p><p>在 ES5 中，需要换行时，需要这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text = (</span><br><span class="line">    &apos;cat\n&apos; +</span><br><span class="line">    &apos;dog\n&apos; +</span><br><span class="line">    &apos;nickelodeon&apos;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>或者这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text = [</span><br><span class="line">    &apos;cat&apos;,</span><br><span class="line">    &apos;dog&apos;,</span><br><span class="line">    &apos;nickelodeon&apos;</span><br><span class="line">].join(&apos;\n&apos;);</span><br></pre></td></tr></table></figure></p><p><strong>模板字符串</strong>可以支持换行并且不需要额外的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let text = ( `cat</span><br><span class="line">dog</span><br><span class="line">nickelodeon`</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><strong>模板字符串</strong>还支持表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let today = new Date();</span><br><span class="line">let text = `The time and date is $&#123;today.toLocaleString()&#125;`;</span><br></pre></td></tr></table></figure></p><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>解构可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。</p><h3 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4];</span><br><span class="line">var a = arr[0];</span><br><span class="line">var b = arr[1];</span><br><span class="line">var c = arr[2];</span><br><span class="line">var d = arr[3];</span><br></pre></td></tr></table></figure><p>数组解构赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c, d] = [1, 2, 3, 4];</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(b); // 2</span><br></pre></td></tr></table></figure></p><h3 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a>解构对象</h3><h4 id="最基本的解构"><a href="#最基本的解构" class="headerlink" title="最基本的解构"></a>最基本的解构</h4><p>ES5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var luke = &#123; occupation: &apos;jedi&apos;, father: &apos;anakin&apos; &#125;;</span><br><span class="line">var occupation = luke.occupation; // &apos;jedi&apos;</span><br><span class="line">var father = luke.father; // &apos;anakin&apos;</span><br></pre></td></tr></table></figure></p><p>对象解构赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let luke = &#123; occupation: &apos;jedi&apos;, father: &apos;anakin&apos; &#125;;</span><br><span class="line">let &#123;occupation, father&#125; = luke;</span><br><span class="line">console.log(occupation); // &apos;jedi&apos;</span><br><span class="line">console.log(father); // &apos;anakin&apos;</span><br></pre></td></tr></table></figure></p><h4 id="解构并使用别名"><a href="#解构并使用别名" class="headerlink" title="解构并使用别名"></a>解构并使用别名</h4><p>有时接口定义的字段往往带有下划线，但我们的前端更便好于驼峰式命名，那么可以使用别名(rename)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  nick_name: &apos;hehe&apos;</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;nick_name: nickName&#125; = user;</span><br><span class="line">console.log(nickName); //prints: hehe</span><br></pre></td></tr></table></figure></p><h4 id="解构嵌套对象"><a href="#解构嵌套对象" class="headerlink" title="解构嵌套对象"></a>解构嵌套对象</h4><p>有时我们会遇到嵌套对象，如果我们了解未足够多时，会写出这种解构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  name: &apos;hehe&apos;,</span><br><span class="line">  education: &#123;</span><br><span class="line">    degree: &apos;Masters&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 假设我们要提取degree</span><br><span class="line">const &#123;education&#125; = user;</span><br><span class="line">const &#123;degree&#125; = education;</span><br></pre></td></tr></table></figure></p><p>我们会写两行，一层层的剥开，明显繁琐，如果这个对象有三四层结构那简直无法入目。其实可以用解构一步到位的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  name: &apos;hehe&apos;,</span><br><span class="line">  education: &#123;</span><br><span class="line">    degree: &apos;Masters&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;education: &#123;degree&#125;&#125; = user;</span><br><span class="line">console.log(degree); //prints: Masters</span><br></pre></td></tr></table></figure></p><p>没错，就是比别名方法多了一个{ }</p><blockquote><p><strong>如果没有外层怎么办</strong></p></blockquote><p>假设要解构的数据是由接口返回的，由于某种原因会导致某个字段丢失。我们会往往遇到这种意外：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  name: &apos;hehe&apos;</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;education: &#123;degree&#125;&#125; = user;  // TypeError: Cannot match against &apos;undefined&apos; or &apos;null&apos;.</span><br></pre></td></tr></table></figure></p><p>这时你是否会觉得还是我们原始的方法好使：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const education = user || &#123;&#125;;</span><br><span class="line">const degree = education.degree;</span><br></pre></td></tr></table></figure></p><p>其实，神奇的解构可以让你定义一个缺省值，这样，我们不仅可以达到数据防御的目的，而且告别啰嗦的写法了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  name: &apos;hehe&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const &#123;</span><br><span class="line">    education: &#123;</span><br><span class="line">        degree</span><br><span class="line">    &#125; = &#123;&#125;</span><br><span class="line">&#125; = user;</span><br><span class="line">console.log(degree); //prints: undefined</span><br></pre></td></tr></table></figure></p><p>这明显是一股清流啊。</p><blockquote><p><strong>更深层次的对象怎么办？</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const user = &#123;</span><br><span class="line">  id: 123,</span><br><span class="line">  name: &apos;hehe&apos;</span><br><span class="line">&#125;;</span><br><span class="line">const &#123;</span><br><span class="line">    education: &#123;</span><br><span class="line">        school: &#123;</span><br><span class="line">            name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; = &#123;</span><br><span class="line">        school: &#123;</span><br><span class="line">            name: &apos;NB&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; = user;</span><br><span class="line">console.log(name); //prints: NB</span><br></pre></td></tr></table></figure><p>这样整体给education设置一个缺省值，可读性更强，这又是一股清流。<br>在代码中灵活使用解构不仅可以使代码简洁可读，而且逼格大大提升。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在 ES6 之前，我们使用<strong>Browserify</strong>这样的库来创建客户端的模块化，在<strong>node.js</strong>中使用<strong>require</strong>。<br>在 ES6 中，我们可以直接使用所有类型的模块化（AMD 和 CommonJS）。</p><h3 id="使用CommonJS的导出"><a href="#使用CommonJS的导出" class="headerlink" title="使用CommonJS的导出"></a>使用CommonJS的导出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = 1;</span><br><span class="line">module.exports = &#123; foo: &apos;bar&apos; &#125;;</span><br><span class="line">module.exports = [&apos;foo&apos;, &apos;bar&apos;];</span><br><span class="line">module.exports = function bar () &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用ES6的导出"><a href="#使用ES6的导出" class="headerlink" title="使用ES6的导出"></a>使用ES6的导出</h3><p>在ES6中我们可以暴露多个值，使用<strong>exports</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export let name = &apos;David&apos;;</span><br><span class="line">export let age  = 25;​​</span><br></pre></td></tr></table></figure></p><p>或者暴露一个对象列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sumTwo(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function sumThree(a, b, c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; sumTwo, sumThree &#125;;</span><br></pre></td></tr></table></figure></p><p>我们还可以暴露函数、对象和其他的值，通过简单地使用 export 这个关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export function sumTwo(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">export function sumThree(a, b, c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，我们还可以绑定一个默认的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sumTwo(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function sumThree(a, b, c) &#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line">let api = &#123;</span><br><span class="line">    sumTwo,</span><br><span class="line">    sumThree</span><br><span class="line">&#125;;</span><br><span class="line">export default api;</span><br><span class="line">/* Which is the same as</span><br><span class="line"> * export &#123; api as default &#125;;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>最佳实践</strong>：总是在模块的最后面使用 export default 方法，可以让暴露的东西更加清晰并且可以节省时间去找出暴露出来值的名字。尤其是在 CommonJS 中，常见做法就是暴露一个简单的值或者对象。通过这种模式，可以让我们的代码更加易读，并且允许我们在 ES6 和 CommonJS 模块之间插值。</p></blockquote><h3 id="ES6-中的导入"><a href="#ES6-中的导入" class="headerlink" title="ES6 中的导入"></a>ES6 中的导入</h3><p>在 ES6 中同样提供了多样的导入方式，我们可以这么导入一个整个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;underscore&apos;;</span><br></pre></td></tr></table></figure></p><blockquote><p>需要着重注意的一点是简单的导入整个文件会在那个文件的顶部执行所有的代码</p></blockquote><p>和 Python 中类似，我们可以命名导入的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; sumTwo, sumThree &#125; from &apos;math/addition&apos;;</span><br></pre></td></tr></table></figure></p><p>我们还可以重命名导入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    sumTwo as addTwoNumbers,</span><br><span class="line">    sumThree as sumThreeNumbers</span><br><span class="line">&#125; from &apos;math/addition&apos;;</span><br></pre></td></tr></table></figure></p><p>另外，我们可以导入所有的东西（整体加载）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as util from &apos;math/addition&apos;;</span><br></pre></td></tr></table></figure></p><p>最后，我们可以从一个模块中导入一个值的列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import * as additionUtil from &apos;math/addition&apos;;</span><br><span class="line">const &#123; sumTwo, sumThree &#125; = additionUtil;</span><br></pre></td></tr></table></figure></p><p>可以像这样导入默认绑定的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import api from &apos;math/addition&apos;;</span><br><span class="line">// Same as: import &#123; default as api &#125; from &apos;math/addition&apos;;</span><br></pre></td></tr></table></figure></p><p>虽然最好保持导出的简单，但如果需要的话我们有时可以混合默认的导入和混合导入。当我们这样导出的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// foos.js</span><br><span class="line">export &#123; foo as default, foo1, foo2 &#125;;</span><br></pre></td></tr></table></figure></p><p>我们可以这样导入它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import foo, &#123; foo1, foo2 &#125; from &apos;foos&apos;;</span><br></pre></td></tr></table></figure></p><p>当我们用<strong>Commonjs</strong>的语法导入一个模块的暴露出口时（比如 React），我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">const &#123; Component, PropTypes &#125; = React;</span><br></pre></td></tr></table></figure></p><p>还有更精简的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong>导出的值是动态引用的，而不是拷贝。因此，在一个模块中改变一个变量的绑定将影响输出模块中的值。应该避免改变这些导出值的公共接口。</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>在 ES5 中，在函数中我们需要各种操作去处理<strong>默认参数</strong>、<strong>不定参数</strong>和<strong>重命名参数</strong>等需求，在 ES6 中我们可以使用更简洁的语法完成这些需求：</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function addTwoNumbers(x, y) &#123;</span><br><span class="line">    x = x || 0;</span><br><span class="line">    y = y || 0;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 中，函数的参数可以支持设置默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function addTwoNumbers(x=0, y=0) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addTwoNumbers(2, 4); // 6</span><br><span class="line">addTwoNumbers(2); // 2</span><br><span class="line">addTwoNumbers(); // 0</span><br></pre></td></tr></table></figure><h3 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h3><p>在 ES5 中，我们需要这么处理不定参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function logArguments() &#123;</span><br><span class="line">    for (var i=0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        console.log(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<strong>rest</strong>，我们就可以处理不确定数目的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function logArguments(...args) &#123;</span><br><span class="line">    for (let arg of args) &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>在 ES5 中是使用配置对象的模式来处理命名参数，jQuery 中的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function initializeCanvas(options) &#123;</span><br><span class="line">    var height = options.height || 600;</span><br><span class="line">    var width  = options.width  || 400;</span><br><span class="line">    var lineStroke = options.lineStroke || &apos;black&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以利用解构的一个函数的形参实现相同的功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initializeCanvas(&#123; height=600, width=400, lineStroke=&apos;black&apos;&#125;) &#123;</span><br><span class="line">    // Use variables height, width, lineStroke here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想使整个值可选择，我们可以解构赋值一个空的对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initializeCanvas(&#123; height=600, width=400, lineStroke=&apos;black&apos;&#125; = &#123;&#125;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="展开操作"><a href="#展开操作" class="headerlink" title="展开操作"></a>展开操作</h3><p>在 ES5 中，我们可以 apply Math.max 方法来获得一个数组中的最大值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max.apply(null, [-1, 100, 9001, -32]); // 9001</span><br></pre></td></tr></table></figure></p><p>在 ES6 中，我们可以通过展开操作把一个数组的值作为参数传递给一个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(...[-1, 100, 9001, -32]); // 9001</span><br></pre></td></tr></table></figure></p><p>我们可以更简洁地使用这个语法来合并数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let cities = [&apos;San Francisco&apos;, &apos;Los Angeles&apos;];</span><br><span class="line">let places = [&apos;Miami&apos;, ...cities, &apos;Chicago&apos;]; // [&apos;Miami&apos;, &apos;San Francisco&apos;, &apos;Los Angeles&apos;, &apos;Chicago&apos;]</span><br></pre></td></tr></table></figure></p><h2 id="类Classes"><a href="#类Classes" class="headerlink" title="类Classes"></a>类Classes</h2><p>在 ES6 之前，我们通过构造函数来创造一个类，并且通过原型来扩展属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, gender) &#123;</span><br><span class="line">    this.name   = name;</span><br><span class="line">    this.age    = age;</span><br><span class="line">    this.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.incrementAge = function () &#123;</span><br><span class="line">    return this.age += 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后可以这样继承类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Personal(name, age, gender, occupation, hobby) &#123;</span><br><span class="line">    Person.call(this, name, age, gender);</span><br><span class="line">    this.occupation = occupation;</span><br><span class="line">    this.hobby = hobby;</span><br><span class="line">&#125;</span><br><span class="line">Personal.prototype = Object.create(Person.prototype);</span><br><span class="line">Personal.prototype.constructor = Personal;</span><br><span class="line">Personal.prototype.incrementAge = function () &#123;</span><br><span class="line">    Person.prototype.incrementAge.call(this);</span><br><span class="line">    this.age += 20;</span><br><span class="line">    console.log(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在 ES6 中，提供了更多的语法糖，可以直接创造一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(name, age, gender) &#123;</span><br><span class="line">        this.name   = name;</span><br><span class="line">        this.age    = age;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">      this.age += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 extends 关键字来继承一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Personal extends Person &#123;</span><br><span class="line">    constructor(name, age, gender, occupation, hobby) &#123;</span><br><span class="line">        super(name, age, gender);</span><br><span class="line">        this.occupation = occupation;</span><br><span class="line">        this.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">        super.incrementAge();</span><br><span class="line">        this.age += 20;</span><br><span class="line">        console.log(this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>最佳实践：</strong>虽然使用 ES6 的语法创造类的时候，js引擎是如何实现类以及如何操作原型是令人费解的，但是未来对初学者来说这是一个好的开始，同时也可以让我们写更简洁的代码。</p></blockquote><h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p><strong>Symbols</strong>在 ES6 之前就已经存在，但是我们现在可以直接使用一个开发的接口了。Symbols 是不可改变并且是独一无二的，可以在任意哈希中作一个key。<br><strong>Symbol()</strong><br>调用 Symbol() 或者 Symbol(description) 可以创造一个独一无二的符号，但是在全局是看不到的。Symbol() 的一个使用情况是给一个类或者命名空间打上补丁，但是可以确定的是你不会去更新它。比如，你想给 React.Component 类添加一个 refreshComponent 方法，但是可以确定的是你不会在之后更新这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const refreshComponent = Symbol();</span><br><span class="line">React.Component.prototype[refreshComponent] = () =&gt; &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Symbol.for(key)<br>Symbol.for(key) 同样会创造一个独一无二并且不可改变的 Symbol，但是它可以全局看到，两个相同的调用 Symbol.for(key) 会返回同一个 Symbol 类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Symbol(&apos;foo&apos;) === Symbol(&apos;foo&apos;) // false</span><br><span class="line">Symbol.for(&apos;foo&apos;) === Symbol(&apos;foo&apos;) // false</span><br><span class="line">Symbol.for(&apos;foo&apos;) === Symbol.for(&apos;foo&apos;) // true</span><br></pre></td></tr></table></figure></p><p>对于 Symbols 的普遍用法（尤其是Symbol.for(key)）是为了协同性。它可以通过在一个第三方插件中已知的接口中对象中的参数中寻找用 Symbol 成员来实现，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function reader(obj) &#123;</span><br><span class="line">    const specialRead = Symbol.for(&apos;specialRead&apos;);</span><br><span class="line">    if (obj[specialRead]) &#123;</span><br><span class="line">        const reader = obj[specialRead]();</span><br><span class="line">        // do something with reader</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new TypeError(&apos;object cannot be read&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在另一个库中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const specialRead = Symbol.for(&apos;specialRead&apos;);</span><br><span class="line">class SomeReadableType &#123;</span><br><span class="line">    [specialRead]() &#123;</span><br><span class="line">        const reader = createSomeReaderFrom(this);</span><br><span class="line">        return reader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>Maps 在 JavaScript 中是一个非常必需的数据结构，在 ES6 之前，我们通过对象来创建哈希映射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var map = new Object();</span><br><span class="line">map[key1] = &apos;value1&apos;;</span><br><span class="line">map[key2] = &apos;value2&apos;;</span><br></pre></td></tr></table></figure></p><p>然而有时我们用特殊的方法去修改对象属性时会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; getOwnProperty(&#123; hasOwnProperty: &apos;Hah, overwritten&apos;&#125;, &apos;Pwned&apos;);</span><br><span class="line">&gt; TypeError: Property &apos;hasOwnProperty&apos; is not a function</span><br></pre></td></tr></table></figure></p><p>实际上<strong>Maps</strong>允许我们对值进行 set、get 和 search 操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map();</span><br><span class="line">&gt; map.set(&apos;name&apos;, &apos;david&apos;);</span><br><span class="line">&gt; map.get(&apos;name&apos;); // david</span><br><span class="line">&gt; map.has(&apos;name&apos;); // true</span><br></pre></td></tr></table></figure></p><p><strong>Maps</strong>更令人惊奇的部分就是它不仅限于使用字符串作为 key，还可以用其他任何类型的数据作为 key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let map = new Map([</span><br><span class="line">    [&apos;name&apos;, &apos;david&apos;],</span><br><span class="line">    [true, &apos;false&apos;],</span><br><span class="line">    [1, &apos;one&apos;],</span><br><span class="line">    [&#123;&#125;, &apos;object&apos;],</span><br><span class="line">    [function () &#123;&#125;, &apos;function&apos;]</span><br><span class="line">]);</span><br><span class="line">for (let key of map.keys()) &#123;</span><br><span class="line">    console.log(typeof key);</span><br><span class="line">    // &gt; string, boolean, number, object, function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong>但我们使用 map.get() 方法去测试相等时，如果在 Maps 中使用 函数 或者 对象 等非原始类型值的时候测试将不起作用，所以我们应该使用 Strings, Booleans 和 Numbers 这样的原始类型的值。</p></blockquote><p>我们还可以使用 .entries() 来遍历迭代：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let [key, value] of map.entries()) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>WeakMaps<br>在 ES6 之前，为了存储私有变量，我们有各种各样的方法去实现，其中一种方法就是用命名约定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    constructor(age) &#123;</span><br><span class="line">        this._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    _incrementAge() &#123;</span><br><span class="line">        this._age += 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是命名约定在代码中仍然会令人混淆并且并不会真正的保持私有变量不被访问。现在，我们可以使用<strong>WeakMaps</strong>来存储变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let _age = new WeakMap();</span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(age) &#123;</span><br><span class="line">        _age.set(this, age);</span><br><span class="line">    &#125;</span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">        let age = _age.get(this) + 1;</span><br><span class="line">        _age.set(this, age);</span><br><span class="line">        if (age &gt; 50) &#123;</span><br><span class="line">            console.log(&apos;Midlife crisis&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 WeakMaps 存储变量很酷的一件事是它的 key 他不需要属性名称，可以使用 Reflect.ownKeys() 来查看这一点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; const person = new Person(50);</span><br><span class="line">&gt; person.incrementAge(); // &apos;Midlife crisis&apos;</span><br><span class="line">&gt; Reflect.ownKeys(person); // []</span><br></pre></td></tr></table></figure></p><p>一个更实际的实践就是可以 WeakMaps 储存 DOM 元素，而不会污染元素本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let map = new WeakMap();</span><br><span class="line">let el  = document.getElementById(&apos;someElement&apos;);</span><br><span class="line">// Store a weak reference to the element with a key</span><br><span class="line">map.set(el, &apos;reference&apos;);</span><br><span class="line">// Access the value of the element</span><br><span class="line">let value = map.get(el); // &apos;reference&apos;</span><br><span class="line">// Remove the reference</span><br><span class="line">el.parentNode.removeChild(el);</span><br><span class="line">el = null;</span><br><span class="line">// map is empty, since the element is destroyed</span><br></pre></td></tr></table></figure></p><p>如上所示，当一个对象被垃圾回收机制销毁的时候， WeakMap 将会自动地删除关于这个对象的键值对。</p><blockquote><p><strong>注意：</strong>为了进一步说明这个例子的可行性，请参考jQuery如何存储与具有引用的DOM元素相对应的对象缓存。使用<strong>WeakMap</strong>，一旦它从文档中删除,jQuery可以自动释放与特定DOM元素相关联的任何内存。一般来说，<strong>WeakMap</strong>对于包装DOM元素的任何库都非常有用。</p></blockquote><h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>Promises 可以让我们远离平行的代码（回调地狱）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func1(function (value1) &#123;</span><br><span class="line">    func2(value1, function (value2) &#123;</span><br><span class="line">        func3(value2, function (value3) &#123;</span><br><span class="line">            func4(value3, function (value4) &#123;</span><br><span class="line">                func5(value4, function (value5) &#123;</span><br><span class="line">                    // Do something with value 5</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>转变成垂直代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func1(value1)</span><br><span class="line">    .then(func2)</span><br><span class="line">    .then(func3)</span><br><span class="line">    .then(func4)</span><br><span class="line">    .then(func5, value5 =&gt; &#123;</span><br><span class="line">        // Do something with value 5</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>在 ES6 之前，我们使用<a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener">bluebird</a>或者<a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">Q</a>，现在我们可以使用原生的<strong>Promise</strong>了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt;</span><br><span class="line">    reject(new Error(&apos;Failed to fulfill Promise&apos;)))</span><br><span class="line">        .catch(reason =&gt; console.log(reason));</span><br></pre></td></tr></table></figure></p><p>我们有两个处理器，<strong>resolve</strong>（当Promise是 <strong>fulfilled</strong> 时的回调）和 reject（当Promise是<strong>rejected</strong>时的回调）：</p><blockquote><p><strong>Promises的好处：</strong>对错误的处理使用一些嵌套回调错误提示会使代码很混乱，使用Promise ，我们有一个清晰的路径来处理冒泡的错误并适当地处理它们，在Promis 确定了resolved/rejected之后，他的值是不可改变的－－它永远不会改变。</p></blockquote><p>这是使用 Promise 的一个实际的栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var request = require(&apos;request&apos;);</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  request.get(url, (error, response, body) =&gt; &#123;</span><br><span class="line">    if (body) &#123;</span><br><span class="line">        resolve(JSON.parse(body));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(&#123;&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们还可以使用 Promise.all() 来 并行 处理多个异步函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let urls = [</span><br><span class="line">  &apos;/api/commits&apos;,</span><br><span class="line">  &apos;/api/issues/opened&apos;,</span><br><span class="line">  &apos;/api/issues/assigned&apos;,</span><br><span class="line">  &apos;/api/issues/completed&apos;,</span><br><span class="line">  &apos;/api/issues/comments&apos;,</span><br><span class="line">  &apos;/api/pullrequests&apos;</span><br><span class="line">];</span><br><span class="line">let promises = urls.map((url) =&gt; &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    $.ajax(&#123; url: url &#125;)</span><br><span class="line">      .done((data) =&gt; &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">Promise.all(promises)</span><br><span class="line">  .then((results) =&gt; &#123;</span><br><span class="line">    // Do something with results of all our promises</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Generators-生成器"><a href="#Generators-生成器" class="headerlink" title="Generators 生成器"></a>Generators 生成器</h2><p> 就像 Promises 可以帮我们避免回调地狱，Generators 可以帮助我们让代码风格更整洁－－用同步的代码风格来写异步代码，它本质上是一个可以暂停计算并且可以随后返回表达式的值的函数。<br> 一个简单的栗子使用 generators：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> function* sillyGenerator() &#123;</span><br><span class="line">    yield 1;</span><br><span class="line">    yield 2;</span><br><span class="line">    yield 3;</span><br><span class="line">    yield 4;</span><br><span class="line">&#125;</span><br><span class="line">var generator = sillyGenerator();</span><br><span class="line">&gt; console.log(generator.next()); // &#123; value: 1, done: false &#125;</span><br><span class="line">&gt; console.log(generator.next()); // &#123; value: 2, done: false &#125;</span><br><span class="line">&gt; console.log(generator.next()); // &#123; value: 3, done: false &#125;</span><br><span class="line">&gt; console.log(generator.next()); // &#123; value: 4, done: false &#125;</span><br></pre></td></tr></table></figure></p><p>next 可以回去到下一个 yield 返回的值，当然上面的代码是非常不自然的，我们可以利用 Generators 来用同步的方式来写异步操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Hiding asynchronousity with Generators</span><br><span class="line">function request(url) &#123;</span><br><span class="line">    getJSON(url, function(response) &#123;</span><br><span class="line">        generator.next(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 generator 函数将会返回需要的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function* getData() &#123;</span><br><span class="line">    var entry1 = yield request(&apos;http://some_api/item1&apos;);</span><br><span class="line">    var data1  = JSON.parse(entry1);</span><br><span class="line">    var entry2 = yield request(&apos;http://some_api/item2&apos;);</span><br><span class="line">    var data2  = JSON.parse(entry2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 yield，我们可以保证 entry1 有 data1 中我们需要解析并储存的数据。<br>虽然我们可以利用 Generators 来用同步的方式来写异步操作，但是确认错误的传播变得不再清晰，我们可以在 Generators 中加上 Promise：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function request(url) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        getJSON(url, resolve);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们写一个函数逐步调用 next 并且利用 request 方法产生一个 Promise：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function iterateGenerator(gen) &#123;</span><br><span class="line">    var generator = gen();</span><br><span class="line">    (function iterate(val) &#123;</span><br><span class="line">        var ret = generator.next();</span><br><span class="line">        if(!ret.done) &#123;</span><br><span class="line">            ret.value.then(iterate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Generators 中加上 Promise 之后我们可以更清晰的使用 Promise 中的 .catch 和 reject来捕捉错误，让我们使用新的 Generator，和之前的还是蛮相似的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iterateGenerator(function* getData() &#123;</span><br><span class="line">    var entry1 = yield request(&apos;http://some_api/item1&apos;);</span><br><span class="line">    var data1  = JSON.parse(entry1);</span><br><span class="line">    var entry2 = yield request(&apos;http://some_api/item2&apos;);</span><br><span class="line">    var data2  = JSON.parse(entry2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async Await"></a>Async Await</h2><p>当 ES6 真正到来的时候，async await 可以用更少的处理实现 Promise 和 Generators 所实现的异步处理：</p><blockquote><p>async await 是Generators的语法糖</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var request = require(&apos;request&apos;);</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    request(url, function(error, response, body) &#123;</span><br><span class="line">      resolve(body);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function main() &#123;</span><br><span class="line">  var data = await getJSON();</span><br><span class="line">  console.log(data); // NOT undefined!</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure><blockquote><p>在 js 引擎中，它所实现的和 Generators 其实是一样的，我更推荐在之上使用 async await + Promises，更多的资源和使用 ES7 和 用 babel 转化可以<a href="http://masnun.com/2015/11/11/using-es7-asyncawait-today-with-babel.html" target="_blank" rel="noopener">看这里</a>。</p></blockquote><h2 id="Getter-Setter-函数"><a href="#Getter-Setter-函数" class="headerlink" title="Getter/Setter 函数"></a>Getter/Setter 函数</h2><p>ES6 已经开始实现了 getter 和 setter 函数，比如下面这个栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Employee &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this._name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    get name() &#123;</span><br><span class="line">      if(this._name) &#123;</span><br><span class="line">        return &apos;Mr. &apos; + this._name.toUpperCase();  </span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return undefined;</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    set name(newName) &#123;</span><br><span class="line">      if (newName == this._name) &#123;</span><br><span class="line">        console.log(&apos;I already have this name.&apos;);</span><br><span class="line">      &#125; else if (newName) &#123;</span><br><span class="line">        this._name = newName;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var emp = new Employee(&quot;James Bond&quot;);</span><br><span class="line">// uses the get method in the background</span><br><span class="line">if (emp.name) &#123;</span><br><span class="line">  console.log(emp.name);  // Mr. JAMES BOND</span><br><span class="line">&#125;</span><br><span class="line">// uses the setter in the background</span><br><span class="line">emp.name = &quot;Bond 007&quot;;</span><br><span class="line">console.log(emp.name);  // Mr. BOND 007</span><br></pre></td></tr></table></figure></p><p>最新版本的浏览器也支持对象中的 getter 和 setter 函数，我们可以使用它们来实现 计算属性，对对象属性添加监听和预处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  firstName: &apos;James&apos;,</span><br><span class="line">  lastName: &apos;Bond&apos;,</span><br><span class="line">  get fullName() &#123;</span><br><span class="line">      console.log(&apos;Getting FullName&apos;);</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">  set fullName (name) &#123;</span><br><span class="line">      console.log(&apos;Setting FullName&apos;);</span><br><span class="line">      var words = name.toString().split(&apos; &apos;);</span><br><span class="line">      this.firstName = words[0] || &apos;&apos;;</span><br><span class="line">      this.lastName = words[1] || &apos;&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.fullName; // James Bond</span><br><span class="line">person.fullName = &apos;Bond 007&apos;;</span><br><span class="line">person.fullName; // Bond 007</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;var-和-let-const-的比较&quot;&gt;&lt;a href=&quot;#var-和-let-const-的比较&quot; class=&quot;headerlink&quot; title=&quot;var 
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://chongdee.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://chongdee.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
