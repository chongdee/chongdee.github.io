<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>andy Wong&#39;s Blog</title>
  
  <subtitle>知道的越多，不知道的越多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chongdee.github.io/"/>
  <updated>2021-07-20T08:42:53.871Z</updated>
  <id>https://chongdee.github.io/</id>
  
  <author>
    <name>andy Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分支使用规范</title>
    <link href="https://chongdee.github.io/2021/07/20/Git/%E5%88%86%E6%94%AF%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>https://chongdee.github.io/2021/07/20/Git/分支使用规范/</id>
    <published>2021-07-20T08:41:46.747Z</published>
    <updated>2021-07-20T08:42:53.871Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇介绍具体的规范，包括分支的划分和命名规范，不同类型的分支应对不同的场景，然后会介绍下工作流工具git-flow，如何简化我们的操作。</p><h2 id="分支构成"><a href="#分支构成" class="headerlink" title="分支构成"></a>分支构成</h2><p>master和develop分支一直存在，且名称不会变化，一般不直接修改这2个分支，由其他分支合并而来。</p><p>feature、release、hotfix分别用于功能点开发、优化，特定版本测试，线上问题紧急处理，同一类型的分支会产生多个。</p><p>分支划分如下：</p><ul><li>master：与线上版本保持绝对一致；</li><li>develop：开发分支，由下文提到的release、feature、hotfix分支合并过后的代码；</li><li>feature：实际功能点开发分支，建议每个功能新建一个feature， 具有关联关系的功能公用一个feature分支；</li><li>release：每一次开发完成之后，从develop创建出来的分支，以此分支为基准，进行测试；</li><li>hotfix：该分支主要用于修复线上bug；</li></ul><p>命名规范约定如下：</p><ul><li>feature分支命名：feature/name</li><li>release分支命名：release/name</li><li>hotfix分支命名：hotfix/name</li></ul><p>比如有一个「优化分布式Session」的需求，可在develop分支的基础上创建新分支 feature/optimize_distributed_session进行开发，开发完成后合并到develop分支。</p><h2 id="分支详细介绍和处理流程"><a href="#分支详细介绍和处理流程" class="headerlink" title="分支详细介绍和处理流程"></a>分支详细介绍和处理流程</h2><h3 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h3><p>主分支，与线上运行的版本始终保持一致，任何时候都不要直接修改master分支。</p><p>一个版本的release分支、hotfix分支开发完成后，会合并代码到master分支，也就是说master分支主要来源于release分支和hotfix分支。</p><h3 id="develop分支"><a href="#develop分支" class="headerlink" title="develop分支"></a>develop分支</h3><p>开发分支，始终保持最新完成以及bug修复后的代码，新增功能时基于该分支创建feature分支。</p><p>一个版本的release分支、hotfix分支开发完成后，也会合并到develop分支，另外，一个版本的feature功能开发完成后，也会合并到develop分支。也就是说develop分支来源于feature、release、hotfix分支。</p><h3 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h3><p>开发新功能或优化现有功能时，会创建feature分支，以develop为基础创建。一般会有多个功能同时开发，但上线时间可能不同，在适当的时候将特定的feature分支合并到develop分支，并创建release分支，进入测试状态。</p><h3 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a>release分支</h3><p>当一组feature开发完成，会首先合并到develop分支，开始进入提测阶段时，会创建release分支。</p><p>以release分支代码为基准提测，测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。</p><p>测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。</p><h3 id="hotfix分支"><a href="#hotfix分支" class="headerlink" title="hotfix分支"></a>hotfix分支</h3><p>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</p><h2 id="特殊情况处理和注意点"><a href="#特殊情况处理和注意点" class="headerlink" title="特殊情况处理和注意点"></a>特殊情况处理和注意点</h2><p>develop分支已存在未上线的feature代码, 此时需要紧急上线一个新功能, 但develop的代码不能上，如何处理 ？</p><ul><li>以master为基线创建feature， 在完成之后，代码合并到master分支；</li><li>为了保证develop是最新代码，需要从master合并到develop分支；</li></ul><p>以develop为基线，创建了f1和f2两个feature分支之后, f1,f2开发一半的时候，发现两个分支代码需要有依赖怎么办 ？</p><p>最好在开发开始前确定两个功能是否相关,若相关则只创建一个分支,两个功能在一起开发;<br>如果已经创建，则需要合并到一个分支；</p><p>一定要保证commit历史记录的整洁，代码合并时，根据情况选择merge或rebase;</p><p>使用<strong>rebase注意</strong>，一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作；</p><p>提交说明规范：</p><ul><li>提交说明最好限制在一行以内，50个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解；</li><li>如果关联jira，写上jira地址；</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621b66e3c8a8d15?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h2 id="git-flow工具"><a href="#git-flow工具" class="headerlink" title="git-flow工具"></a>git-flow工具</h2><p>上面的流程在第一次接触时，会觉得有点复杂，通过git-flow工具可以把这些流程自动化。它是一个命令行工具，支持各个平台，比如OSX、Linux、Windows等支持。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>通过 git flow init 命令进行初始化，以交互式的方式进行，主要是约定分支的命名，建议使用默认值；</p><h3 id="开发新功能"><a href="#开发新功能" class="headerlink" title="开发新功能"></a>开发新功能</h3><p>git flow feature start f1 添加新特性，这个操作创建了一个基于develop的特性分支，并切换到这个分支之下。</p><p>git flow feature finish f1 完成新特性，这个操作会合并f1分支到develop分支，并删除特性分支，切换回develop分支。</p><p>git flow feature publish f1 发布新分支，发布新特性分支到远程服务器，其它用户也可以使用这分支。</p><h3 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h3><p>git flow release start r1 [BASE] 创建发布版本，[BASE]是以哪个分支或commit为基础进行发版，一般为develop。</p><p>git flow release publish r1 发布release分支，其他同事就可以看到这个分支，并修改一些小问题。</p><p>git flow release finish r1 完成release分支，会合并release分支到master分支，用release分支名打Tag，合并release分支到 develop分支，最后移除release分支。</p><h3 id="修复线上问题"><a href="#修复线上问题" class="headerlink" title="修复线上问题"></a>修复线上问题</h3><p>有可能需要修正 master 分支上某个 TAG 标记的生产版本。</p><p>git flow hotfix start VERSION [BASENAME] 创建hotfix分支，VERSION 参数标记着修正版本，[BASENAME]为finish release时填写的版本号。</p><p>git flow hotfix finish VERSION，当完成紧急修复分支，代码合并到develop和 master分支。相应地，master分支打上修正版本的 TAG。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621fe4eee2e8e95?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇介绍具体的规范，包括分支的划分和命名
      
    
    </summary>
    
      <category term="Git" scheme="https://chongdee.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://chongdee.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git 工作流和git commit规范</title>
    <link href="https://chongdee.github.io/2021/07/20/Git/git%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%92%8Cgit%20commit%E8%A7%84%E8%8C%83/"/>
    <id>https://chongdee.github.io/2021/07/20/Git/git 工作流和git commit规范/</id>
    <published>2021-07-20T08:41:38.192Z</published>
    <updated>2021-07-20T08:42:32.703Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>统一团队的Git工作流，包括分支使用、tag规范、issue等</li><li>统一团队的Git Commit日志标准，便于后续代码review,版本发布以及日志自动化生成</li></ul><h2 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h2><ul><li><p>git flow工作流：</p><ul><li>master为主分支，属保护分支，不能直接在此进行代码修改和提交。</li><li>develop为日常使用分支。</li><li>feature新功能分支，当完成一个功能并测试通过后进行合并到develop分支中。</li><li>hotfix线上紧急漏洞修复分支，从master分支拉取创建，修复完bug后合并到master和develop分支中。</li></ul></li></ul><ul><li>gitlab flow工作流（最大原则叫做”上游优先”（upsteam first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支）：</li></ul><p><strong>master-&gt;pre-production-&gt;production</strong></p><ul><li>master开发环境分支</li><li>pre-production预发环境分支</li><li>production生产环境分支</li></ul><h2 id="git-commit规范"><a href="#git-commit规范" class="headerlink" title="git commit规范"></a>git commit规范</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BLANK</span> <span class="attr">LINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BLANK</span> <span class="attr">LINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">占位标签解析：</span><br><span class="line"><span class="section">type:代表某次提交的类型，比如是修复一个bug还是增加一个新的feature。所有的type类型如下：</span></span><br><span class="line"><span class="section">scope:scope说明commit影响的范围。scope依据项目而定，</span></span><br><span class="line">例如在业务项目中可以依据菜单或者功能模块划分，</span><br><span class="line">如果是组件库开发，则可以依据组件划分。</span><br><span class="line"><span class="section">subject:是commit的简短描述</span></span><br><span class="line"><span class="section">body:提交代码的详细描述</span></span><br><span class="line"><span class="section">footer:如果代码的提交是不兼容变更或关闭缺陷，则Footer必需，否则可以省略。</span></span><br><span class="line"></span><br><span class="line"><span class="section">feat[特性]:新增feature </span></span><br><span class="line"><span class="section">fix[修复]: 修复bug     </span></span><br><span class="line"><span class="section">docs[文档]: 仅仅修改了文档，比如README, CHANGELOG, CONTRIBUTE等等</span></span><br><span class="line"><span class="section">style[格式]: 仅仅修改了空格、格式缩进、都好等等，不改变代码逻辑</span></span><br><span class="line"><span class="section">refactor[重构]: 代码重构，没有加新功能或者修复bug</span></span><br><span class="line"><span class="section">perf[优化]: 优化相关，比如提升性能、体验</span></span><br><span class="line"><span class="section">test[测试]: 测试用例，包括单元测试、集成测试等</span></span><br><span class="line"><span class="section">chore[工具]: 改变构建流程、或者增加依赖库、工具等</span></span><br><span class="line"><span class="section">revert[回滚]: 回滚到上一个版本</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">特性:添加头像功能</span></span><br><span class="line"><span class="section">特性:添加收藏功能</span></span><br><span class="line"><span class="section">修复:在android机器上传崩溃问题解决</span></span><br><span class="line"><span class="section">文档:修改README,增加了使用说明</span></span><br><span class="line"><span class="section">优化:首页图片加载缓慢优化</span></span><br><span class="line"><span class="section">重构:对头像功能进行封装重构</span></span><br></pre></td></tr></table></figure><h2 id="Git标签打包规范"><a href="#Git标签打包规范" class="headerlink" title="Git标签打包规范"></a>Git标签打包规范</h2><p><strong>Tag版本号：</strong>Tag包括3位版本，前缀使用v。比如v1.2.31。Tag命名规范：</p><p>1.新功能开发使用第2位版本号，bug修复使用第3位版本号</p><p>2.首版本号是全新的功能类，功能模块上线才做的调整</p><p><strong>标题格式：项目名-日期内容格式：&lt;分类&gt;—&lt;内容&gt;&lt;分类&gt;：</strong><br>新功能、bug修复、优化、依赖升级、重构、漏洞&amp;补丁</p><p><strong>示例：</strong><br>此图片引用自:<a href="https://juejin.cn/post/6844903619662200839" target="_blank" rel="noopener">我们的GIT工作流</a></p><h2 id="Git-Commit格式校验"><a href="#Git-Commit格式校验" class="headerlink" title="Git Commit格式校验"></a>Git Commit格式校验</h2><ul><li>准备commitlint/cli用于格式校验</li><li>准备husky用于git提交代码时触发校验</li></ul><p>全局安装commitlint/cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure><p>2.在项目根目录创建配置文件commitlint.config.js，可以使用以下命令创建</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"module.exports = &#123;extends: ['@commitlint/config-conventional']&#125;"</span> &gt; commitlint<span class="selector-class">.config</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p>3.在配置文件中定义提交规范，可使用以下配置：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"module.exports = &#123;extends: ['@commitlint/config-conventional']&#125;"</span></span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'@commitlint/config-conventional'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'type-enum'</span>: [<span class="number">2</span>, <span class="string">'always'</span>, [</span><br><span class="line">      <span class="string">"feat"</span>, <span class="string">"fix"</span>, <span class="string">"docs"</span>, <span class="string">"style"</span>, <span class="string">"refactor"</span>, <span class="string">"test"</span>, <span class="string">"chore"</span>, <span class="string">"revert"</span></span><br><span class="line">    ]],</span><br><span class="line">    <span class="string">'subject-full-stop'</span>: [<span class="number">0</span>, <span class="string">'never'</span>],</span><br><span class="line">    <span class="string">'subject-case'</span>: [<span class="number">0</span>, <span class="string">'never'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.项目添加husky，进行git提交触发校验，安装如下：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>5.安装完成后在package.json中配置如下信息</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"commitmsg"</span>: <span class="string">"commitlint -e $GIT_PARAMS"</span>,</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">"config"</span>: &#123;</span><br><span class="line">    <span class="string">"commitizen"</span>: &#123;</span><br><span class="line">      <span class="string">"path"</span>: <span class="string">"cz-customizable"</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>6.经过以上步骤，git commit的规范校验已经完成。可以进行代码提交了。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不规范提交&gt;git commit -m <span class="string">"添加新功能"</span></span><br><span class="line">提示：</span><br><span class="line">⧗   input: 添加新功能</span><br><span class="line">✖   subject may <span class="keyword">not</span> be empty [subject-empty]</span><br><span class="line">✖  <span class="built_in"> type </span>may <span class="keyword">not</span> be empty [type-empty]</span><br><span class="line"></span><br><span class="line">规范提交&gt;git commit -m <span class="string">"feat: 添加新功能"</span></span><br></pre></td></tr></table></figure><p>汉化与自定义校验规则<br>1.当前项目安装commitlint-config-cz，如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitlint-<span class="built_in">config</span>-cz <span class="comment">--save-dev</span></span><br></pre></td></tr></table></figure><p>2.commitlint校验规则配置添加如下设置：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">'cz'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.下载官方配置文件进行修改。官方配置文件cz-config-EXAMPLE.js。修改示例如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use strict'</span>;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line"><span class="symbol">  types:</span> [</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'特性'</span>,<span class="string">name:</span> <span class="string">'特性:    一个新的特性'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'修复'</span>,<span class="string">name:</span> <span class="string">'修复:    修复一个Bug'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'文档'</span>,<span class="string">name:</span> <span class="string">'文档:    变更的只有文档'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'格式'</span>,<span class="string">name:</span> <span class="string">'格式:    空格, 分号等格式修复'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'重构'</span>,<span class="string">name:</span> <span class="string">'重构:    代码重构，注意和特性、修复区分开'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'性能'</span>,<span class="string">name:</span> <span class="string">'性能:    提升性能'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'测试'</span>,<span class="string">name:</span> <span class="string">'测试:    添加一个测试'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'工具'</span>,<span class="string">name:</span> <span class="string">'工具:    开发工具变动(构建、脚手架工具等)'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">value:</span> <span class="string">'回滚'</span>,<span class="string">name:</span> <span class="string">'回滚:    代码回退'</span>&#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line"><span class="symbol">  scopes:</span> [</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'用户模块'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'订单模块'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'社区模块'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">name:</span> <span class="string">'商品模块'</span>&#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// it needs to match the value for field type. Eg.: 'fix'</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  scopeOverrides: &#123;</span></span><br><span class="line"><span class="comment">    fix: [</span></span><br><span class="line"><span class="comment">      &#123;name: 'merge'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'style'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'e2eTest'&#125;,</span></span><br><span class="line"><span class="comment">      &#123;name: 'unitTest'&#125;</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// override the messages, defaults are as follows</span></span><br><span class="line"><span class="symbol">  messages:</span> &#123;</span><br><span class="line"><span class="symbol">    type:</span> <span class="string">'选择一种你的提交类型:'</span>,</span><br><span class="line"><span class="symbol">    scope:</span> <span class="string">'选择一个scope (可选):'</span>,</span><br><span class="line">    <span class="comment">// used if allowCustomScopes is true</span></span><br><span class="line"><span class="symbol">    customScope:</span> <span class="string">'Denote the SCOPE of this change:'</span>,</span><br><span class="line"><span class="symbol">    subject:</span> <span class="string">'简要说明:\n'</span>,</span><br><span class="line"><span class="symbol">    body:</span> <span class="string">'详细说明，使用"|"换行(可选)：\n'</span>,</span><br><span class="line"><span class="symbol">    breaking:</span> <span class="string">'非兼容性说明 (可选):\n'</span>,</span><br><span class="line"><span class="symbol">    footer:</span> <span class="string">'关联关闭的issue，例如：#31, #34(可选):\n'</span>,</span><br><span class="line"><span class="symbol">    confirmCommit:</span> <span class="string">'确定提交?'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="symbol">  allowCustomScopes:</span> <span class="literal">true</span>,</span><br><span class="line"><span class="symbol">  allowBreakingChanges:</span> [<span class="string">'特性'</span>, <span class="string">'修复'</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// limit subject length</span></span><br><span class="line"><span class="symbol">  subjectLimit:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="生成changelog"><a href="#生成changelog" class="headerlink" title="生成changelog"></a>生成changelog</h2><p>1.安装conventional-changelog，可以快速生成提交日志</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g conventional-changelog-cli</span><br><span class="line">npm <span class="keyword">install</span> -g cz-conventional-changelog</span><br></pre></td></tr></table></figure><p>2.项目根目录下添加 .czrc 配置文件,文件内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"path"</span>: <span class="string">"cz-conventional-changelog"</span> &#125;</span><br></pre></td></tr></table></figure><p>3.在package.json中的scripts项增加如下指令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"version"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -s -r 0 &amp;&amp; git add CHANGELOG.md"</span></span><br></pre></td></tr></table></figure><p>4.执行npm run version即可在当前目录生成changelog日志了。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://juejin.cn/post/6844903831893966856" target="_blank" rel="noopener">Cz工具集使用介绍 - 规范Git提交说明</a><br><a href="https://juejin.cn/post/6844903831893966856" target="_blank" rel="noopener">git工作流程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;统一团队的Git工作流，包括
      
    
    </summary>
    
      <category term="Git" scheme="https://chongdee.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://chongdee.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>输入URL请求过程，http版本对比</title>
    <link href="https://chongdee.github.io/2021/07/20/HTTP/%E8%BE%93%E5%85%A5URL%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%EF%BC%8Chttp%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94/"/>
    <id>https://chongdee.github.io/2021/07/20/HTTP/输入URL请求过程，http版本对比/</id>
    <published>2021-07-20T08:37:01.813Z</published>
    <updated>2021-07-20T08:38:10.020Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="浏览器输入-URL-发生了什么"><a href="#浏览器输入-URL-发生了什么" class="headerlink" title="浏览器输入 URL 发生了什么"></a>浏览器输入 URL 发生了什么</h2><ol><li>输入网址并DNS域名解析</li><li>TCP/IP连接：三次握手</li><li>HTTP请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>断开连接：TCP 四次挥手</li><li>浏览器渲染页面</li></ol><p>当我们在浏览器中键入 URL：<a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a> 时，浏览器会先去寻找该域名所对应的 IP 地址，毕竟最终通信我们还是得用 IP 才能找到对方的地址，域名只是方便用户记忆的别名。</p><p>那么如何找到域名所对应的 IP 地址呢？接下来让笔者先来给大家介绍我们遇到的第一块内容：DNS。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS 的作用就是通过域名查询到具体的 IP。</p><p>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p><p>当你在浏览器中想访问 www.google.com 时，会通过进行以下操作：</p><ol><li>本地客户端向服务器发起请求查询 IP 地址</li><li>查看浏览器有没有该域名的 IP 缓存</li><li>查看操作系统有没有该域名的 IP 缓存</li><li>查看 Host 文件有没有该域名的解析配置</li><li>如果这时候还没得话，会通过直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li><li>然后去该服务器查询 google.com 这个二级域名</li><li>接下来查询 www.google.com 这个三级域名的地址</li><li>返回给 DNS 客户端并缓存起来<br>图片<br>image.png<br>以上介绍的是 DNS 递归查询，还有种是迭代查询，区别就是前者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端；后者由客户端去做请求。<br>这时可能会有好奇的读者会问：DNS 在做解析的时候，向这些服务器发送的请求到底是基于 TCP 还是 UDP 协议的？</li></ol><p>其实在当前的网络环境中，这两种协议都有用的。通过 UDP 去进行一些数据量少的请求，这时候能用到 UDP 性能快的优势；对于数据量大且需要保证数据完整有序的时候会选择用 TCP 去请求，保证数据的正确及完整性。</p><p>后续的内容中我们也会介绍 UDP 及 TCP 协议。</p><p>当浏览器获取域名的 IP 地址后，马上会通过 TCP 协议与服务器建立连接。接下来我们来聊聊 TCP 协议的内容。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 建立连接需要进行三次握手：</p><p>图片<br>最开始两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB（一个数据结构，里面包含了协议需要的很多内容，有兴趣的可以自行了解）。服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。</p><p><strong>第一次握手</strong></p><p>客户端向服务端发送连接请求报文段(SYN)。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。</p><p><strong>第二次握手</strong></p><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答(ACK + SYN)，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><p><strong>第三次握手</strong></p><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文(ACK)。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p><p>PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie 达到减少 RTT（一次请求来回的时间） 的目的。</p><p><strong>这里会有个经典面试题：为什么 TCP 需要三次而不是两次握手？</strong></p><p>因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p><p>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p><p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p><p>当建立连接并请求完成后，TCP 连接并不会马上断开。得益于 HTTP 1.1 协议中的 keep-alive 属性，连接可以短暂的保留一段时间，具体如何断开得看服务端的设置或者客户端主动 close 掉。</p><p>一旦 close，TCP 协议就会进行四次握手来断开连接。</p><p>图片</p><p><strong>第一次握手</strong></p><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><p><strong>第二次握手</strong></p><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p><p><strong>第三次握手</strong></p><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p><p>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将服务端的第二次和第三次握手合并，延迟 ACK 包的发送。</p><p><strong>第四次握手</strong></p><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><p><strong>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</strong></p><p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p><p>建立和断开连接涉及到的两种握手都是 TCP 中很重要的知识。当然除了这些内容之外，TCP 也还有很多东西我们需要学习，比如说 TCP 协议是如何实现有序且完整的传递数据，这其中涉及到的内容我们马上就会学到。</p><h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><p>首先我们先来学习 TCP 协议是如何实现完整送达数据的。毕竟网络波动及各种不确定因素的存在会导致数据传递发生丢失，一旦出现这种情况我们得确保协议有重传的机制。就好比我们在业务中上传某些重要数据一样，一次没收到响应或者发生别的情况时，会进行多次重试。</p><p>ARQ 协议也就是超时重传机制协议。通过确认和超时机制保证了数据的正确送达，其中包含停止等待 ARQ 和连续 ARQ 协议。</p><p>停止等待 ARQ</p><p>正常传输过程</p><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p><p>出现错误时</p><p>1 .报文丢失或出错</p><p>在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p><p>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传。</p><p>PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。</p><ol><li>ACK 超时或丢失</li></ol><p>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p><p>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p><p>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。</p><p>连续 ARQ</p><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p><p>累计确认</p><p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。</p><p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下文说到。</p><p>滑动窗口</p><p>窗口这个概念在 TCP 中经常会看到，就比如我们在上面小节中讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。</p><p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</p><p>图片<br>发送端窗口大小是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p><p>当发送端接收到应答报文后，会随之将窗口进行滑动</p><p>图片<br>刷过算法的同学看到这两张图应该会很熟悉，毕竟滑动窗口在算法中也是一类高频题目。</p><p>滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p><p>Zero 窗口</p><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p><p>拥塞处理</p><p>拥塞处理是 TCP 中作用很大的功能模块，主要通过一些算法来控制数据的传输，防止拥塞网络。</p><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p><p>慢开始算法</p><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。举个例子在日常下载时，我们的下载网速都是逐渐变快的。</p><p>慢开始算法步骤具体如下：</p><p>1.连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）<br>2.每过一个 RTT 就将窗口大小乘二<br>3.指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。<br>拥塞避免算法</p><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p><p>在传输过程中如果协议认为网络拥塞了，会马上进行以下步骤：</p><p>•将阈值设为当前拥塞窗口的一半<br>•将拥塞窗口设为 1 MSS<br>•启动拥塞避免算法<br>快速重传</p><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，说明发送端传过去的数据对端都没有收到，此时会启动快速重传。主要算法为：</p><p>TCP Reno</p><p>•拥塞窗口减半<br>•将阈值设为当前拥塞窗口<br>•进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）<br>•使用拥塞避免算法<br>TCP New Ren 改进后的快恢复</p><p>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p><p>在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p><p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p><p>说完了 TCP 协议，我们再来聊聊它的兄弟协议 UDP 吧。因为 UDP 相对 TCP 功能简单，因此涉及到的知识并不多。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h3><p>UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。TCP 协议就会这样干，毕竟得保证报文的有序。</p><p>具体来说：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li></ul><p>由于 UDP 对于报文处理的很简单，因此会带来一些弊端。</p><h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><ol><li>无连接，也就是说通信不需要建立和断开连接。</li><li>协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的</li><li>没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景就会很有用。</li></ol><h3 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h3><p>因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p><p>图片</p><p>头部包含了以下几个数据</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p>讲完 TCP 及 UDP 这两块内容以后，我们接下去看浏览器对于 <a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a> 链接在进行完 TCP 三次握手后的后续动作是什么。</p><blockquote><p>因为我们输入的协议是 HTTPS，这个协议我们可以看成是 HTTP 协议加上 TLS 安全协议。因此在进行完 TCP 连接后不会马上开始 HTTP 协议层面的传输，而是开始 TLS 协议的握手。</p></blockquote><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 最重要的组成部分就是 TLS 协议了，因为是这个协议保证了安全性。</p><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>既然需要保证安全性，那么肯定需要用到加密技术。在 TLS 中使用了两种加密技术，分别为：<strong>对称加密</strong>和<strong>非对称加密</strong>。</p><h3 id="对称加密："><a href="#对称加密：" class="headerlink" title="对称加密："></a>对称加密：</h3><p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><h3 id="非对称加密："><a href="#非对称加密：" class="headerlink" title="非对称加密："></a>非对称加密：</h3><p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>TLS 握手过程如下图：</p><p>图片</p><ol><li>客户端发送一个随机值，需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密<br>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</li></ol><p>PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。因此如果在意网络传输性能的话，应该选用 TLS1.3 协议。</p><p><strong>当 TLS 完成握手以后，就真的开始进行 HTTP 协议层面的传输数据了。</strong></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>对于 HTTP 协议来说，前端工程师主要了解常见状态码以及 header 即可，毕竟这些是我们日常编码中经常需要接触的内容。</p><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><p>2XX 成功</p><ul><li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li><li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li><li>206 Partial Content，进行范围请求</li></ul><p>3XX 重定向</p><ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li><li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p>4XX 客户端错误</p><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li>403 forbidden，表示对请求资源的访问被服务器拒绝</li><li>404 not found，表示在服务器上没有找到请求的资源</li></ul><p>5XX 服务器错误</p><ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>浏览器想要优先使用的连接类型，比如 keep-alive、close</td></tr><tr><td>Date</td><td>创建报文时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Via</td><td>代理服务器相关信息</td></tr><tr><td>Transfer-Encoding</td><td>传输编码方式</td></tr><tr><td>Upgrade</td><td>要求客户端升级协议</td></tr><tr><td>Warning</td><td>在内容中可能存在错误</td></tr></tbody></table><table><thead><tr><th>请求字段</th><th>作用</th></tr></thead><tbody><tr><td>Accept</td><td>能正确接收的媒体类型</td></tr><tr><td>Accept-Charset</td><td>能正确接收的字符集</td></tr><tr><td>Accept-Encoding</td><td>能正确接收的编码格式列表</td></tr><tr><td>Accept-Language</td><td>能正确接收的语言列表</td></tr><tr><td>Expect</td><td>期待服务端的指定行为</td></tr><tr><td>From</td><td>请求方邮箱地址</td></tr><tr><td>Host</td><td>服务器的域名</td></tr><tr><td>If-Match</td><td>两端资源标记比较</td></tr><tr><td>If-Modified-Since</td><td>本地资源未修改返回 304（比较时间）</td></tr><tr><td>If-None-Match</td><td>本地资源未修改返回 304（比较标记）</td></tr><tr><td>User-Agent</td><td>客户端信息</td></tr><tr><td>Max-Forwards</td><td>限制可被代理及网关转发的次数</td></tr><tr><td>Proxy-Authorization</td><td>向代理服务器发送验证信息</td></tr><tr><td>Range</td><td>请求某个内容的一部分</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面</td></tr><tr><td>TE</td><td>传输编码方式</td></tr></tbody></table><table><thead><tr><th>响应字段</th><th>作用</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否支持某些种类的范围</td></tr><tr><td>Age</td><td>资源在代理缓存中存在的时间</td></tr><tr><td>ETag</td><td>资源标识</td></tr><tr><td>Location</td><td>客户端重定向到某个 URL</td></tr><tr><td>Proxy-Authenticate</td><td>向代理服务器发送验证信息</td></tr><tr><td>Server</td><td>服务器名字</td></tr><tr><td>WWW-Authenticate</td><td>获取资源需要的验证信息</td></tr></tbody></table><table><thead><tr><th>实体字段</th><th>作用</th></tr></thead><tbody><tr><td>Allow</td><td>资源的正确请求方式</td></tr><tr><td>Content-Encoding</td><td>内容的编码格式</td></tr><tr><td>Content-Language</td><td>内容使用的语言</td></tr><tr><td>Content-Length</td><td>request body 长度</td></tr><tr><td>Content-Location</td><td>返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td>Base64加密格式的内容 MD5检验值</td></tr><tr><td>Content-Range</td><td>内容的位置范围</td></tr><tr><td>Content-Type</td><td>内容的媒体类型</td></tr><tr><td>Expires</td><td>内容的过期时间</td></tr><tr><td>Last_modified</td><td>内容的最后修改时间</td></tr></tbody></table><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><p>最后几段内容我们再来聊聊一些新的协议，先来聊聊 HTTP 2.0。这个协议相比于 HTTP 1.1 而言，可以说是大幅度提高了 web 的性能。</p><p>在 HTTP 1.1 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用域名发散等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><p>但是在 HTTP 2.0 中这个问题被极大地优化了，但是还是没有被解决。因为 HTTP 2.0 底下还是 TCP 协议，TCP 需要保证数据正确性的做法也会带来队头阻塞的问题，所以说问题并没被解决。但是这个问题被后续的新协议彻底解决了，我们下文再表。</p><p>我们先来感受下 HTTP 2.0 比 HTTP 1.X 到底快了多少，可以通过 该链接[4] 体验。</p><p>图片<br>在 HTTP 1.X 中，因为队头阻塞的原因，你会发现请求是这样的</p><p>图片<br>在 HTTP 2.0 中，因为引入了多路复用，你会发现请求是这样的：</p><p>图片</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在 HTTP 2.0 中，有两个非常重要的概念，<strong>分别是帧（frame）</strong>和<strong>流（stream）</strong>。</p><p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p><p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术可以极大的提高传输性能。</p><p>图片</p><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p>HTTP 2.0 中所有加强性能的核心点在于此。<strong>在之前的 HTTP 版本中，我们是通过文本的方式传输数据</strong>。在 HTTP 2.0 中引入了新的编码机制，所有<strong>传输的数据都会被分割，并采用二进制格式编码为二进制帧</strong>。</p><p>图片<br>二进制帧分为很多类型，在上图中我们可以发现存在了 HEADERS 帧和 DATA 帧，除了这些之外还有还几种，各位读者有兴趣的话可以自行了解。</p><h2 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h2><p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p><p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p><h2 id="服务端-Push"><a href="#服务端-Push" class="headerlink" title="服务端 Push"></a>服务端 Push</h2><p>这个不用学了，因为用的太少，Chrome 或移除这个功能了。详情见 Chrome to remove HTTP/2 Push[5]。</p><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标很远大，希望替代 TCP 协议。</p><ul><li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制</li><li>实现了自己的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，也就是说 QUIC 可以在 0-RTT 的情况下建立安全连接并传输数据</li><li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包</li><li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li><li>在丢失两个包或以上的情况就使用重传机制，因为算不出来了</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>HTTP 2.0 其实还涉及了挺多内容，就比如说二进制帧的各种类型以及分别的功能是什么。</li><li>HTTP 3.0 是个更新的协议，对比 2.0 又有了很多性能优化。</li><li>QUIC 是个性能很强又兼顾 TCP 功能的协议，有些 CDN 厂商已经支持后台开启该功能。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;浏览器输入-URL-发生了什么&quot;&gt;&lt;a href=&quot;#浏览器输入-URL-发生了什么&quot; class=&quot;headerlink&quot; title=&quot;浏览器输入 URL 发生
      
    
    </summary>
    
      <category term="HTTP" scheme="https://chongdee.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://chongdee.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>cors跨域详解</title>
    <link href="https://chongdee.github.io/2021/07/20/HTTP/cors%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>https://chongdee.github.io/2021/07/20/HTTP/cors跨域详解/</id>
    <published>2021-07-20T08:31:36.538Z</published>
    <updated>2021-07-20T08:32:16.477Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><p>本文详细介绍CORS的内部机制。</p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><ul><li>请求方法是以下三种方法之一：<ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li>HTTP的头信息不超出以下几种字段：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain<br>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</li></ul></li></ul><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对这两种请求的处理，是不一样的。</p><h2 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h2><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span>: api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-<span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-<span class="string">Credentials:</span> <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-<span class="string">Headers:</span> FooBar</span><br><span class="line">Content-<span class="string">Type:</span> text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</p><p><strong>（1）Access-Control-Allow-Origin</strong></p><p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p><p><strong>（2）Access-Control-Allow-Credentials</strong></p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>（3）Access-Control-Expose-Headers</strong></p><p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><h3 id="3-2-withCredentials-属性"><a href="#3-2-withCredentials-属性" class="headerlink" title="3.2 withCredentials 属性"></a>3.2 withCredentials 属性</h3><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Access-Control-Allow-Credentials:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="attr">withCredentials</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><h3 id="4-1-预检请求"><a href="#4-1-预检请求" class="headerlink" title="4.1 预检请求"></a>4.1 预检请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>下面是一段浏览器的JavaScript脚本。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">'http://api.alice.com/cors'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="built_in">url</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/<span class="number">1.1</span></span><br><span class="line">Origin: http:<span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Request-<span class="function"><span class="keyword">Method</span>:</span> PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure><p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p><p>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p><p><strong>（1）Access-Control-Request-Method</strong></p><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p><p><strong>（2）Access-Control-Request-Headers</strong></p><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p><h3 id="4-2-预检请求的回应"><a href="#4-2-预检请求的回应" class="headerlink" title="4.2 预检请求的回应"></a>4.2 预检请求的回应</h3><p>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="string">Date:</span> Mon, <span class="number">01</span> Dec <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line"><span class="string">Server:</span> Apache/<span class="number">2.0</span><span class="number">.61</span> (Unix)</span><br><span class="line">Access-Control-Allow-<span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//api.bob.com</span></span><br><span class="line">Access-Control-Allow-<span class="string">Methods:</span> GET, POST, PUT</span><br><span class="line">Access-Control-Allow-<span class="string">Headers:</span> X-Custom-Header</span><br><span class="line">Content-<span class="string">Type:</span> text/html; charset=utf<span class="number">-8</span></span><br><span class="line">Content-<span class="string">Encoding:</span> gzip</span><br><span class="line">Content-<span class="string">Length:</span> <span class="number">0</span></span><br><span class="line">Keep-<span class="string">Alive:</span> timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line"><span class="string">Connection:</span> Keep-Alive</span><br><span class="line">Content-<span class="string">Type:</span> text/plain</span><br></pre></td></tr></table></figure><p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="noopener">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>如果服务器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot <span class="keyword">load</span> <span class="keyword">http</span>://api.alice.com.</span><br><span class="line">Origin <span class="keyword">http</span>://api.bob.com <span class="keyword">is</span> <span class="keyword">not</span> allowed <span class="keyword">by</span> <span class="keyword">Access</span>-Control-<span class="keyword">Allow</span>-Origin.</span><br></pre></td></tr></table></figure><p>服务器回应的其他CORS相关字段如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Access-Control-Allow-Methods:</span> <span class="string">GET,</span> <span class="string">POST,</span> <span class="string">PUT</span></span><br><span class="line"><span class="attr">Access-Control-Allow-Headers:</span> <span class="string">X-Custom-Header</span></span><br><span class="line"><span class="attr">Access-Control-Allow-Credentials:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">Access-Control-Max-Age:</span> <span class="number">1728000</span></span><br></pre></td></tr></table></figure><p><strong>（1）Access-Control-Allow-Methods</strong></p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><p><strong>（2）Access-Control-Allow-Headers</strong></p><p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><p><strong>（3）Access-Control-Allow-Credentials</strong></p><p>该字段与简单请求时的含义相同。</p><p><strong>（4）Access-Control-Max-Age</strong></p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><h3 id="4-3-浏览器的正常请求和回应"><a href="#4-3-浏览器的正常请求和回应" class="headerlink" title="4.3 浏览器的正常请求和回应"></a>4.3 浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p><p>下面是”预检”请求之后，浏览器的正常CORS请求。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span>: api.alice.com</span><br><span class="line"><span class="attribute">X-Custom-Header</span>: value</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面头信息的Origin字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-<span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//api.bob.com</span></span><br><span class="line">Content-<span class="string">Type:</span> text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure><p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p><h2 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h2><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解–阮一峰的网络日志</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;CORS&quot;&gt;&lt;a href=&quot;#CORS&quot; class=&quot;headerlink&quot; title=&quot;CORS&quot;&gt;&lt;/a&gt;CORS&lt;/h2&gt;&lt;p&gt;CORS是一个W3C标准
      
    
    </summary>
    
      <category term="HTTP" scheme="https://chongdee.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://chongdee.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>cookie、session、token 的区别</title>
    <link href="https://chongdee.github.io/2021/07/20/HTTP/cookie%E3%80%81session%E3%80%81token%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://chongdee.github.io/2021/07/20/HTTP/cookie、session、token 的区别/</id>
    <published>2021-07-20T08:30:52.243Z</published>
    <updated>2021-07-20T08:31:23.380Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>众所周知，http 是无状态协议，浏览器和服务器不可能凭协议的实现辨别请求的上下文。</p><p>于是 cookie 登场，既然协议本身不能分辨链接，那就在请求头部手动带着上下文信息吧。</p><p>举个例子，以前去旅游的时候，到了景区可能会需要存放行李，被大包小包压着，旅游也不开心啦。在存放行李后，服务员会给你一个牌子，上面写着你的行李放在哪个格子，离开时，你就能凭这个牌子和上面的数字成功取回行李。</p><p>cookie 做的正是这么一件事，旅客就像客户端，寄存处就像服务器，凭着写着数字的牌子，寄存处（服务器）就能分辨出不同旅客（客户端）。</p><p>你会不会想到，如果牌子被偷了怎么办，cookie 也会被偷吗？确实会，这就是一个很常被提到的网络安全问题——CSRF。</p><p>cookie 诞生初似乎是用于电商存放用户购物车一类的数据，但现在前端拥有两个 storage（local、session），两种数据库（websql、IndexedDB），根本不愁信息存放问题，所以现在基本上 100% 都是在连接上证明客户端的身份。例如登录之后，服务器给你一个标志，就存在 cookie 里，之后再连接时，都会自动带上 cookie，服务器便分清谁是谁。另外，cookie 还可以用于跟踪一个用户，这就产生了隐私问题，于是也就有了“禁用 cookie”这个选项（然而现在这个时代禁用 cookie 是挺麻烦的事情）。</p><h3 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h3><p>现实世界的例子明白了，在计算机中怎么才能设置 cookie 呢？一般来说，安全起见，cookie 都是依靠 set-cookie 头设置，且不允许 JavaScript 设置。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span></span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; Expires=<span class="params">&lt;date&gt;</span></span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; Max-Age=<span class="params">&lt;non-zero-digit&gt;</span></span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; Domain=<span class="params">&lt;domain-value&gt;</span></span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; Path=<span class="params">&lt;path-value&gt;</span></span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; Secure</span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; HttpOnly</span><br><span class="line"></span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; SameSite=Strict</span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; SameSite=Lax</span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; SameSite=None; Secure</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple attributes are also possible, for example:</span></span><br><span class="line">Set-Cookie: <span class="params">&lt;cookie-name&gt;</span>=<span class="params">&lt;cookie-value&gt;</span>; Domain=<span class="params">&lt;domain-value&gt;</span>; Secure; HttpOnly</span><br></pre></td></tr></table></figure><p>其中 <cookie-name>=<cookie-value> 这样的 kv 对，内容随你定，另外还有 HttpOnly、SameSite 等配置，一条 Set-Cookie 只配置一项 cookie。</cookie-value></cookie-name></p><ul><li>Expires 设置 cookie 的过期时间（时间戳），这个时间是客户端时间。</li><li>Max-Age 设置 cookie 的保留时长（秒数），同时存在 Expires 和 Max-Age 的话，Max-Age 优先</li><li>Domain 设置生效的域名，默认就是当前域名，不包含子域名</li><li>Path 设置生效路径，/ 全匹配</li><li>Secure 设置 cookie 只在 https 下发送，防止中间人攻击</li><li>HttpOnly 设置禁止 JavaScript 访问 cookie，<strong>防止XSS</strong></li><li>SameSite 设置跨域时不携带 cookie，<strong>防止CSRF</strong></li></ul><p><strong>Secure 和 HttpOnly 是强烈建议开启的</strong>。SameSite 选项需要根据实际情况讨论，因为 SameSite 可能会导致即使你用 CORS 解决了跨越问题，依然会因为请求没自带 cookie 引起一系列问题，一开始还以为是 axios 配置问题，绕了一大圈，然而根本没关系。</p><p>其实因为 Chrome 在某一次更新后把没设置 SameSite 默认为 Lax，你不在服务器手动把 SameSite 设置为 None 就不会自动带 cookie 了。</p><h3 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h3><p>参考 MDN，cookie 的发送格式如下（其中 PHPSESSID 相关内容下面会提到）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cookie: &lt;cookie-list&gt;</span><br><span class="line">Cookie: <span class="attribute">name</span>=value</span><br><span class="line">Cookie: <span class="attribute">name</span>=value; <span class="attribute">name2</span>=value2; <span class="attribute">name3</span>=value3</span><br><span class="line"></span><br><span class="line">Cookie: <span class="attribute">PHPSESSID</span>=298zf09hf012fh2; <span class="attribute">csrftoken</span>=u32t4o3tb3gg43; <span class="attribute">_gat</span>=1</span><br></pre></td></tr></table></figure><p>在发送 cookie 时，并不会把上面提到的 Expires 等配置传到服务器，因为服务器在设置后就不需要关心这些信息了，只要现代浏览器运作正常，收到的 cookie 就是没问题的。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>从 cookie 说到 session，是因为 session 才是真正的“信息”，如上面提到的，cookie 是容器，里面装着 PHPSESSID=298zf09hf012fh2;，这就是一个 session ID。</p><p>不知道 session 和 session id 会不会让你看得有点头晕？</p><p>当初 session 的存在就是要为客户端和服务器连接提供的信息，所以我将 session 理解为信息，而 session id 是获取信息的钥匙，通常是一串唯一的哈希码。</p><p>接下来分析两个 node.js express 的中间件，理解两种 session 的实现方式。</p><p>session 信息可以储存在客户端，如 cookie-session，也可以储存在服务器，如 express-session。使用 session ID 就是把 session 放在服务器里，用 cookie 里的 id 寻找服务器的信息。</p><h3 id="客户端储存"><a href="#客户端储存" class="headerlink" title="客户端储存"></a>客户端储存</h3><p>对于 cookie-session 库，比较容易理解，其实就是把所有信息加密后塞到 cookie 里。其中涉及到 cookies 库。在设置 session 时其实就是调用 cookies.set，把信息写到 set-cookie 里，再返回浏览器。换言之，取值和赋值的本质都是操作 cookie。</p><p>浏览器在接收到 set-cookie 头后，会把信息写到 cookie 里。在下次发送请求时，信息又通过 cookie 原样带回来，所以服务器什么东西都不用存，只负责获取和处理 cookie 里的信息，这种实现方法不需要 session ID。</p><p>这是一段使用 cookie-session 中间件为请求添加 cookie 的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="keyword">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> cookieSession = <span class="keyword">require</span>(<span class="string">'cookie-session'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line">app.<span class="keyword">use</span>(</span><br><span class="line">  cookieSession(&#123;</span><br><span class="line">    name: <span class="string">'session'</span>,</span><br><span class="line">    keys: [</span><br><span class="line">      <span class="comment">/* secret keys */</span></span><br><span class="line">      <span class="string">'key'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// Cookie Options</span></span><br><span class="line">    maxAge: <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>, <span class="comment">// 24 hours</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>&#123;</span><br><span class="line">  req.session.test = <span class="string">'hey'</span></span><br><span class="line">  res.json(&#123;</span><br><span class="line">    wow: <span class="string">'crazy'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3001</span>)</span><br></pre></td></tr></table></figure><p>在通过 app.use(cookieSession()) 使用中间件之前，请求是不会设置 cookie 的，添加后再访问（并且在设置 req.session 后，若不添加 session 信息就没必要、也没内容写到 cookie 里），就能看到服务器响应头部新增了下面两行，分别写入 session 和 session.sig：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: <span class="attribute">session</span>=eyJ0ZXN0IjoiaGV5In0=; <span class="attribute">path</span>=/; <span class="attribute">expires</span>=Tue, 23 Feb 2021 01:07:05 GMT; httponly</span><br><span class="line">Set-Cookie: session.<span class="attribute">sig</span>=QBoXofGvnXbVoA8dDmfD-GMMM6E; <span class="attribute">path</span>=/; <span class="attribute">expires</span>=Tue, 23 Feb 2021 01:07:05 GMT; httponly</span><br></pre></td></tr></table></figure><p>然后你就能在 DevTools 的 Application 标签看到 cookie 成功写入。session 的值 eyJ0ZXN0IjoiaGV5In0= 通过 base64 解码即可得到 {“test”:”hey”}，这就是所谓的“将 session 信息放到客户端”，因为 base64 编码并不是加密，这就跟明文传输没啥区别，所以<strong>请不要在客户端 session 里放用户密码之类的机密信息</strong>。</p><p>即使现代浏览器和服务器做了一些约定，例如使用 https、跨域限制、还有上面提到 cookie 的 httponly 和 sameSite 配置等，保障了 cookie 安全。但是想想，传输安全保障了，如果有人偷看你电脑里的 cookie，密码又恰好存在 cookie，那就能无声无息地偷走密码。相反的，只放其他信息或是仅仅证明“已登录”标志的话，只要退出一次，这个 cookie 就失效了，算是降低了潜在危险。</p><p>说回第二个值 session.sig，它是一个 27 字节的 SHA1 签名，<strong>用以校验 session 是否被篡改，是 cookie 安全的又一层保障。</strong></p><h3 id="服务器储存"><a href="#服务器储存" class="headerlink" title="服务器储存"></a>服务器储存</h3><p>既然要储存在服务器，那么 express-session 就需要一个容器 store，它可以是内存、redis、mongoDB 等等等等，内存应该是最快的，但是重启程序就没了，<strong>redis 可以作为备选，用数据库存 session 的场景感觉不多</strong>。</p><p>express-session 的源码没 cookie-session 那么简明易懂，里面有一个有点绕的问题，req.session 到底是怎么插入的？</p><p><strong>不关注实现可以跳过下面几行</strong>，有兴趣的话可以跟着思路看看 express-session 的源码：</p><p>我们可以从 .session = 这个关键词开始找，找到：</p><ul><li>store.generate 否决这个，容易看出这个是初始化使用的</li><li>Store.prototype.createSession 这个是根据 req 和 sess 参数在 req 中设置 session 属性，没错，就是你了</li></ul><p>于是全局搜索 createSession，锁定 index 里的 inflate（就是填充的意思）函数。</p><p>最后寻找 inflate 的调用点，是使用 sessionID 为参数的 store.get 的回调函数，一切说得通啦——</p><p>在监测到客户端送来的 cookie 之后，可以从 cookie 获取 sessionID，再使用 id 在 store 中获取 session 信息，挂到 req.session 上，经过这个中间件，你就能顺利地使用 req 中的 session。</p><p>那赋值怎么办呢？这就和上面储存在客户端不同了，上面要修改客户端 cookie 信息，但是对于储存在服务器的情况，你修改了 session 那就是“实实在在地修改”了嘛，不用其他花里胡哨的方法，内存中的信息就是修改了，下次获取内存里的对应信息也是修改后的信息。（仅限于内存的实现方式，使用数据库时仍需要额外的写入）</p><p>在请求没有 session id 的情况下，通过 store.generate 创建新的 session，在你写 session 的时候，cookie 可以不改变，只要根据原来的 cookie 访问内存里的 session 信息就可以了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="keyword">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> parseurl = <span class="keyword">require</span>(<span class="string">'parseurl'</span>)</span><br><span class="line"><span class="keyword">var</span> session = <span class="keyword">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">use</span>(</span><br><span class="line">  session(&#123;</span><br><span class="line">    secret: <span class="string">'keyboard cat'</span>,</span><br><span class="line">    resave: <span class="keyword">false</span>,</span><br><span class="line">    saveUninitialized: <span class="keyword">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.<span class="keyword">use</span>(<span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!req.session.views) &#123;</span><br><span class="line">    req.session.views = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get the url pathname</span></span><br><span class="line">  <span class="keyword">var</span> pathname = parseurl(req).pathname</span><br><span class="line"></span><br><span class="line">  <span class="comment">// count the views</span></span><br><span class="line">  req.session.views[pathname] = (req.session.views[pathname] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/foo'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>&#123;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    session: req.session,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/bar'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res, next)</span> </span>&#123;</span><br><span class="line">  res.send(<span class="string">'you viewed this page '</span> + req.session.views[<span class="string">'/bar'</span>] + <span class="string">' times'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3001</span>)</span><br></pre></td></tr></table></figure><h3 id="两种储存方式的对比"><a href="#两种储存方式的对比" class="headerlink" title="两种储存方式的对比"></a>两种储存方式的对比</h3><p>首先还是计算机世界最重要的哲学问题：时间和空间的抉择。</p><p>储存在客户端的情况，解放了服务器存放 session 的内存，但是每次都带上一堆 base64 处理的 session 信息，如果量大的话传输就会很缓慢。</p><p>储存在服务器相反，用服务器的内存拯救了带宽。</p><p>另外，在退出登录的实现和结果，也是有区别的。</p><p>储存在服务器的情况就很简单，如果 req.session.isLogin = true 是登录，那么 req.session.isLogin = false 就是退出。</p><p>但是状态存放在客户端要做到真正的“即时退出登录”就很困难了。你可以在 session 信息里加上过期日期，也可以直接依靠 cookie 的过期日期，过期之后，就当是退出了。</p><p>但是如果你不想等到 session 过期，现在就想退出登录！怎么办？认真想想你会发现，仅仅依靠客户端储存的 session 信息真的没有办法做到。</p><p>即使你通过 req.session = null 删掉客户端 cookie，那也只是删掉了，但是如果有人曾经把 cookie 复制出来了，那他手上的 cookie 直到 session 信息里的过期时间前，都是有效的。</p><p>说“即时退出登录”有点标题党的意味，其实我想表达的是，你没办法立即废除一个 session，这可能会造成一些隐患。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>session 说完了，那么出现频率超高的关键字 token 又是什么？</p><p>不妨谷歌搜一下 token 这个词，可以看到冒出来几个（年纪大的人）比较熟悉的图片：密码器。过去网上银行不是只要短信认证就能转账，还要经过一个密码器，上面显示着一个变动的密码，在转账时你需要输入密码器中的代码才能转账，这就是 token 现实世界中的例子。凭借一串码或是一个数字证明自己身份，这事情不就和上面提到的行李问题还是一样的吗……</p><p><strong>其实本质上 token 的功能就是和 session id 一模一样</strong>。你把 session id 说成 session token 也没什么问题（Wikipedia 里就写了这个别名）。</p><p>其中的区别在于，session id 一般存在 cookie 里，自动带上；token 一般是要你主动放在请求中，例如设置请求头的 Authorization 为 bearer:<access_token>。</access_token></p><p>然而上面说的都是一般情况，根本没有明确规定！</p><p>剧透一下，下面要讲的 JWT（JSON Web Token）！他是一个 token！但是里面放着 session 信息！放在客户端，并且可以随你选择放在 cookie 或是手动添加在 Authorization！但是他就叫 token！</p><p>所以，个人觉得你不能通过存放的位置判断是 token 或是 session id，也不能通过内容判断是 token 或是 session 信息，session、session id 以及 token 都是很意识流的东西，只要你明白他是什么、怎么用就好了，怎么称呼不太重要。</p><p>另外在搜索资料时也看到有些文章说 session 和 token 的区别就是新旧技术的区别，好像有点道理。</p><p>在 session 的 Wikipedia 页面上 HTTP session token 这一栏，举例都是 JSESSIONID (JSP)、PHPSESSID (PHP)、CGISESSID (CGI)、ASPSESSIONID (ASP) 等比较传统的技术，就像 SESSIONID 是他们的代名词一般；而在研究现在各种平台的 API 接口和 OAuth2.0 登录时，都是使用 access token 这样的字眼，这个区别着实有点意思。</p><p>理解 session 和 token 的联系之后，可以在哪里能看到“活的” token 呢？</p><p>打开 GitHub 进入设置，找到 Settings / Developer settings，可以看到 Personal access tokens 选项，生成新的 token 后，你就可以带着它通过 GitHub API，证明“你就是你”。</p><p>在 OAuth 系统中也使用了 Access token 这个关键词，写过微信登录的朋友应该都能感受到 token 是个什么啦。</p><p>Token 在权限证明上真的很重要，不可泄漏，谁拿到 token，谁就是“主人”。所以要做一个 Token 系统，刷新或删除 Token 是必须要的，这样在尽快弥补 token 泄漏的问题。</p><p>在理解了三个关键字和两种储存方式之后，下面我们正式开始说“用户登录”相关的知识和两种登录规范——JWT 和 OAuth2.0。</p><p>接着你可能会频繁见到 Authentication 和 Authorization 这两个单词，它们都是 Auth 开头，但可不是一个意思，简单来说前者是验证，后者是授权。在编写登录系统时，要先验证用户身份，设置登录状态，给用户发送 token 就是授权。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>全称 JSON Web Token（RFC 7519），是的，JWT 就是一个 token。为了方便理解，提前告诉大家，JWT 用的是上面客户端储存的方式，所以这部分可能会经常用到上面提到的名称。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>虽说 JWT 就是客户端储存 session 信息的一种，但是 JWT 有着自己的结构：Header.Payload.Signature（分为三个部分，用 . 隔开）</p><p><strong>Header</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>typ 说明 token 类型是 JWT，alg 代表签名算法，HMAC、SHA256、RSA 等。然后将其 base64 编码。</p><p><strong>Payload</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Payload 是放置 session 信息的位置，最后也要将这些信息进行 base64 编码，结果就和上面客户端储存的 session 信息差不多。</p><p>不过 JWT 有一些约定好的属性，被称为 Registered claims，包括：</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p><strong>Signature</strong><br>最后一部分是签名，和上面提到的 session.sig 一样是用于防止篡改，不过 JWT 把签名和内容组合到一起罢了。</p><p>JWT 签名的生成算法是这样的：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(<span class="name">header</span>) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(<span class="name">payload</span>),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>使用 Header 里 alg 的算法和自己设定的密钥 secret 编码 base64UrlEncode(header) + “.” + base64UrlEncode(payload)</p><p>最后将三部分通过 . 组合在一起，你可以通过 jwt.io Debugger 形象地看到 JWT 的组成原理：</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>在验证用户，顺利登录后，会给用户返回 JWT。因为 JWT 的信息没有加密，所以别往里面放密码，详细原因在客户端储存的 cookie 中提到。</p><p>用户访问需要授权的连接时，可以把 token 放在 cookie，也可以在请求头带上 Authorization: Bearer <token>。（手动放在请求头不受 CORS 限制，不怕 CSRF）</token></p><p>这样可以用于自家登录，也可以用于第三方登录。单点登录也是 JWT 的常用领域。</p><p><strong>JWT 也因为信息储存在客户端造成无法让自己失效的问题，这算是 JWT 的一个缺点</strong>。</p><h3 id="HTTP-authentication"><a href="#HTTP-authentication" class="headerlink" title="HTTP authentication"></a>HTTP authentication</h3><p>HTTP authentication 是一种标准化的校验方式，<strong>不会使用 cookie 和 session</strong> 相关技术。请求头带有 Authorization: Basic <credentials> 格式的授权字段。</credentials></p><p>其中 credentials 就是 Base64 编码的用户名 + : + 密码（或 token），以后看到 Basic authentication，意识到就是每次请求都带上用户名密码就好了。</p><p>Basic authentication 大概比较适合 serverless，毕竟他没有运行着的内存，无法记录 session，直接每次都带上验证就完事了。</p><h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>OAuth 2.0（RFC 6749）也是用 token 授权的一种协议，它的特点是你可以在<strong>有限范围内使用别家接口</strong>，也可以借此使用别家的登录系统登录自家应用，也就是第三方应用登录。（注意啦注意啦，OAuth 2.0 授权流程说不定面试会考哦！）</p><p>既然是第三方登录，那除了应用本身，必定存在第三方登录服务器。在 OAuth 2.0 中涉及三个角色：用户、应用提供方、登录平台，相互调用关系如下：</p><pre><code>+--------+                               +---------------+|        |--(A)- Authorization Request -&gt;|   Resource    ||        |                               |     Owner     ||        |&lt;-(B)-- Authorization Grant ---|               ||        |                               +---------------+|        ||        |                               +---------------+|        |--(C)-- Authorization Grant --&gt;| Authorization || Client |                               |     Server    ||        |&lt;-(D)----- Access Token -------|               ||        |                               +---------------+|        ||        |                               +---------------+|        |--(E)----- Access Token ------&gt;|    Resource   ||        |                               |     Server    ||        |&lt;-(F)--- Protected Resource ---|               |+--------+                               +---------------+</code></pre><p>很多大公司都提供 OAuth 2.0 第三方登录，这里就拿小聋哥的微信举例吧——</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>一般来说，应用提供方需要先在登录平台申请好 AppID 和 AppSecret。（微信使用这个名称，其他平台也差不多，一个 ID 和一个 Secret）</p><h4 id="获取-code"><a href="#获取-code" class="headerlink" title="获取 code"></a>获取 code</h4><p>什么是授权临时票据（code）？答：第三方通过 code 进行获取 access_token 的时候需要用到，code 的超时时间为 10 分钟，一个 code 只能成功换取一次 access_token 即失效。code 的临时性和一次保障了微信授权登录的安全性。第三方可通过使用 https 和 state 参数，进一步加强自身授权登录的安全性。</p><p>在这一步中，用户先在登录平台进行身份校验。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">https://open.weixin.qq.com/connect/qrconnect?</span></span><br><span class="line">appid=APPID&amp;</span><br><span class="line">redirect_uri=REDIRECT_URI&amp;</span><br><span class="line">response_type=code&amp;</span><br><span class="line">scope=SCOPE&amp;</span><br><span class="line">state=STATE</span><br><span class="line"><span class="comment">#wechat_redirect</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>appid</td><td>是</td><td>应用唯一标识</td></tr><tr><td>redirect_uri</td><td>是</td><td>请使用 urlEncode 对链接进行处理</td></tr><tr><td>response_type</td><td>是</td><td>填 code</td></tr><tr><td>scope</td><td>是</td><td>应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写 snsapi_login</td></tr><tr><td>state</td><td>否</td><td>用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止 csrf 攻击（跨站请求伪造攻击）</td></tr></tbody></table><p>注意一下 scope 是 OAuth2.0 权限控制的特点，定义了这个 code 换取的 token 可以用于什么接口。</p><p>正确配置参数后，打开这个页面看到的是授权页面，在用户授权成功后，登录平台会带着 code 跳转到应用提供方指定的 redirect_uri：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect_uri?code=CODE&amp;<span class="keyword">state</span>=STATE</span><br></pre></td></tr></table></figure><p>授权失败时，跳转到</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect_uri?<span class="keyword">state</span>=STATE</span><br></pre></td></tr></table></figure><p>也就是失败时没 code。</p><h4 id="获取-token"><a href="#获取-token" class="headerlink" title="获取 token"></a>获取 token</h4><p>在跳转到重定向 URI 之后，应用提供方的后台需要使用微信给你的code获取 token，同时，你也可以用传回来的 state 进行来源校验。</p><p>要获取 token，传入正确参数访问这个接口：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">https://api.weixin.qq.com/sns/oauth2/access_token?</span></span><br><span class="line">appid=APPID&amp;</span><br><span class="line">secret=SECRET&amp;</span><br><span class="line">code=CODE&amp;</span><br><span class="line">grant_type=authorization_code</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>appid</td><td>是</td><td>应用唯一标识，在微信开放平台提交应用审核通过后获得</td></tr><tr><td>secret</td><td>是</td><td>应用密钥 AppSecret，在微信开放平台提交应用审核通过后获得</td></tr><tr><td>code</td><td>是</td><td>填写第一步获取的 code 参数</td></tr><tr><td>grant_type</td><td>是</td><td>填 authorization_code，是其中一种授权模式，微信现在只支持这一种</td></tr></tbody></table><p>正确的返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"access_token"</span>: <span class="string">"ACCESS_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"expires_in"</span>: <span class="number">7200</span>,</span><br><span class="line">  <span class="attr">"refresh_token"</span>: <span class="string">"REFRESH_TOKEN"</span>,</span><br><span class="line">  <span class="attr">"openid"</span>: <span class="string">"OPENID"</span>,</span><br><span class="line">  <span class="attr">"scope"</span>: <span class="string">"SCOPE"</span>,</span><br><span class="line">  <span class="attr">"unionid"</span>: <span class="string">"o6_bmasdasdsad6_2sgVt7hMZOPfL"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到 token 之后你就可以根据之前申请 code 填写的 scope 调用接口了。</p><h4 id="使用-token-调用微信接口"><a href="#使用-token-调用微信接口" class="headerlink" title="使用 token 调用微信接口"></a>使用 token 调用微信接口</h4><table><thead><tr><th>授权作用域（scope）</th><th>接口</th><th>接口说明</th></tr></thead><tbody><tr><td>snsapi_base</td><td>/sns/oauth2/access_token</td><td>通过 code 换取 access_token、refresh_token 和已授权 scope</td></tr><tr><td>snsapi_base</td><td>/sns/oauth2/refresh_token</td><td>刷新或续期 access_token 使用</td></tr><tr><td>snsapi_base</td><td>/sns/auth</td><td>检查 access_token 有效性</td></tr><tr><td>snsapi_userinfo</td><td>/sns/userinfo</td><td>获取用户个人信息</td></tr></tbody></table><p>例如获取个人信息就是 GET <a href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN" target="_blank" rel="noopener">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a></p><p>注意啦，在微信 OAuth 2.0，access_token 使用 query 传输，而不是上面提到的 Authorization。</p><p>使用 Authorization 的例子，如 GitHub 的授权，前面的步骤基本一致，在获取 token 后，这样请求接口：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">"Authorization: token OAUTH-TOKEN"</span> <span class="string">https:</span><span class="comment">//api.github.com</span></span><br></pre></td></tr></table></figure><p>说回微信的 userinfo 接口，返回的数据格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"openid"</span>: <span class="string">"OPENID"</span>,</span><br><span class="line">  <span class="attr">"nickname"</span>: <span class="string">"NICKNAME"</span>,</span><br><span class="line">  <span class="attr">"sex"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"province"</span>:<span class="string">"PROVINCE"</span>,</span><br><span class="line">  <span class="attr">"city"</span>:<span class="string">"CITY"</span>,</span><br><span class="line">  <span class="attr">"country"</span>:<span class="string">"COUNTRY"</span>,</span><br><span class="line">  <span class="attr">"headimgurl"</span>:<span class="string">"https://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46"</span>,</span><br><span class="line">  <span class="attr">"privilege"</span>:[ <span class="string">"PRIVILEGE1"</span> <span class="string">"PRIVILEGE2"</span> ],</span><br><span class="line">  <span class="attr">"unionid"</span>: <span class="string">"o6_bmasdasdsad6_2sgVt7hMZOPfL"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后续使用"><a href="#后续使用" class="headerlink" title="后续使用"></a>后续使用</h4><p>在使用 token 获取用户个人信息后，你可以接着用 userinfo 接口返回的 openid，结合 session 技术实现在自己服务器登录。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录</span></span><br><span class="line">req<span class="selector-class">.session</span><span class="selector-class">.id</span> = openid</span><br><span class="line"><span class="keyword">if</span> (req<span class="selector-class">.session</span><span class="selector-class">.id</span>) &#123;</span><br><span class="line">  <span class="comment">//   已登录</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//   未登录</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出</span></span><br><span class="line">req<span class="selector-class">.session</span><span class="selector-class">.id</span> = null</span><br><span class="line"><span class="comment">// 清除 session</span></span><br></pre></td></tr></table></figure><p>总结一下 OAuth2.0 的流程和重点：</p><ul><li>为你的应用申请 ID 和 Secret</li><li>准备好重定向接口</li><li>正确传参获取 code   <strong>（重要）</strong></li><li>code 传入你的重定向接口</li><li>在重定向接口中使用 code 获取 token &lt;- 重要</li><li>传入 token 使用微信接口</li></ul><p>OAuth2.0 着重于第三方登录和权限限制。而且 OAuth2.0 不止微信使用的这一种授权方式，其他方式可以看阮老师的OAuth 2.0 的四种方式。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>JWT 和 OAuth2.0 都是成体系的鉴权方法，不代表登录系统就一定要这么复杂。</p><p>简单登录系统其实就以上面两种 session 储存方式为基础就能做到。</p><ol><li>使用服务器储存 session 为基础，可以用类似 req.session.isLogin = true 的方法标志该 session 的状态为已登录。</li><li>使用客户端储存 session 为基础，设置 session 的过期日期和登录人就基本能用了。</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"exp"</span>: <span class="number">1614088104313</span>,</span><br><span class="line">  <span class="attr">"usr"</span>: <span class="string">"admin"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（就是和 JWT 原理基本一样，不过没有一套体系）</p><ol><li>甚至你可以使用上面的知识自己写一个 express 的登录系统：</li><li>初始化一个 store，内存、redis、数据库都可以</li><li>在用户身份验证成功后，随机生成一串哈希码作为 token</li><li>用 set-cookie 写到客户端</li><li>再在服务器写入登录状态，以内存为例就是在 store 中添加哈希码作为属性</li><li>下次请求带着 cookie 的话检查 cookie 带来的 token 是否已经写入 store 中即可</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录成功后</span></span><br><span class="line">store[HASH] = <span class="literal">true</span></span><br><span class="line">cookie.<span class="keyword">set</span>(<span class="string">'token'</span>, HASH)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要鉴权的请求钟</span></span><br><span class="line"><span class="keyword">const</span> hash = cookie.<span class="keyword">get</span>(<span class="string">'token'</span>)</span><br><span class="line"><span class="keyword">if</span> (store[hash]) &#123;</span><br><span class="line">  <span class="comment">// 已登录</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 未登录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出</span></span><br><span class="line"><span class="keyword">const</span> hash = cookie.<span class="keyword">get</span>(<span class="string">'token'</span>)</span><br><span class="line">delete store[hash]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以下列出本文重点：</p><ul><li>cookie 是储存 session/session id/token 的容器</li><li>cookie 设置一般通过 set-cookie 请求头设置</li><li>session 信息可以存放在浏览器，也可以存放在服务器</li><li>session 存放在服务器时，以 session id 为钥匙获取信息</li><li>token/session/session id 三者的界限是模糊的</li><li>一般新技术使用 token，传统技术使用 session id</li><li>cookie/token/session/session id 都是用于鉴权的实用技术</li><li>JWT 是浏览器储存 session 的一种</li><li>JWT 常用于单点登录（SSO）</li><li>OAuth2.0 的 token 不是由应用端颁发，存在另外的授权服务器</li><li>OAuth2.0 常用于第三方应用登录</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;p&gt;众所周知
      
    
    </summary>
    
      <category term="HTTP" scheme="https://chongdee.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://chongdee.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>总结18个webpack插件</title>
    <link href="https://chongdee.github.io/2021/07/20/webpack/%E6%80%BB%E7%BB%9318%E4%B8%AAwebpack%E6%8F%92%E4%BB%B6/"/>
    <id>https://chongdee.github.io/2021/07/20/webpack/总结18个webpack插件/</id>
    <published>2021-07-20T07:51:02.521Z</published>
    <updated>2021-07-20T07:51:57.614Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h1><p>何为插件(Plugin)？专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。</p><p>Plugin 的特点</p><ul><li>是一个独立的模块</li><li>模块对外暴露一个 js 函数</li><li>函数的原型 <code>(prototype)</code> 上定义了一个注入 <code>compiler</code> 对象的 <code>apply</code>方法 <code>apply</code> 函数中需要有通过 <code>compiler</code> 对象挂载的 <code>webpack</code> 事件钩子，钩子的回调中能拿到当前编译的 <code>compilation</code> 对象，如果是异步编译插件的话可以拿到回调 <code>callback</code></li><li>完成自定义子编译流程并处理 <code>complition</code> 对象的内部数据</li><li>如果异步编译插件的话，数据处理完成后执行 <code>callback</code> 回调。</li></ul><p>下面介绍 18 个常用的 webpack 插件</p><h2 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h2><p>模块热更新插件。<code>Hot-Module-Replacement</code> 的热更新是依赖于 <code>webpack-dev-server</code>，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，<code>HRM</code> 是只更新修改的部分。</p><p><code>HotModuleReplacementPlugin</code>是<code>webpack</code>模块自带的，所以引入<code>webpack</code>后，在<code>plugins</code>配置项中直接使用即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// 热更新插件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>生成 html 文件。将 webpack 中<code>entry</code>配置的相关入口 <code>chunk</code> 和 <code>extract-text-webpack-plugin</code>抽取的 css 样式 插入到该插件提供的<code>template</code>或者<code>templateContent</code>配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式<code>link</code>插入到<code>head</code>元素中，<code>script</code>插入到<code>head</code>或者<code>body</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">    minify: &#123;</span><br><span class="line">      <span class="comment">// 压缩HTML文件</span></span><br><span class="line">      removeComments: <span class="literal">true</span>, <span class="comment">// 移除HTML中的注释</span></span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空白符与换行符</span></span><br><span class="line">      minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩内联css</span></span><br><span class="line">    &#125;,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>inject 有四个选项值</p><ul><li>true：默认值，<code>script</code> 标签位于 <code>html</code> 文件的 <code>body</code> 底部</li><li>body：<code>script</code> 标签位于 <code>html</code> 文件的 <code>body</code> 底部（同 true）</li><li>head：<code>script</code> 标签位于 <code>head</code> 标签内</li><li>false：不插入生成的 js 文件，只是单纯的生成一个 <code>html</code> 文件</li></ul><p>多页应用打包</p><p>有时，我们的应用不一定是一个单页应用，而是一个多页应用，那么如何使用 webpack 进行打包呢。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    login: <span class="string">'./src/login.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[hash:6].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/login.html'</span>,</span><br><span class="line">      filename: <span class="string">'login.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要配置多个 <code>HtmlWebpackPlugin</code>，那么 <code>filename</code> 字段不可缺省，否则默认生成的都是 <code>index.html</code>。</p><p>但是有个问题，<code>index.html</code> 和 <code>login.html</code> 会发现，都同时引入了 <code>index.f7d21a.js</code> 和 <code>login.f7d21a.js</code>，通常这不是我们想要的，我们希望 <code>index.html</code> 中只引入 <code>index.f7d21a.js</code>，<code>login.html</code> 只引入 <code>login.f7d21a.js</code>。</p><p><code>HtmlWebpackPlugin</code> 提供了一个 <code>chunks</code> 的参数，可以接受一个数组，配置此参数仅会将数组中指定的 js 引入到 html 文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">      chunks: [<span class="string">'index'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/login.html'</span>,</span><br><span class="line">      filename: <span class="string">'login.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">      chunks: [<span class="string">'login'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行 <code>npm run build</code>，可以看到 <code>index.html</code> 中仅引入了 index 的 js 文件，而 <code>login.html</code> 中也仅引入了 login 的 js 文件。</p><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h2><p><code>clean-webpack-plugin</code> 用于在打包前清理上一次项目生成的 bundle 文件，它会根据 <code>output.path</code> 自动清理文件夹；这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h2><p>将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// 将css分离到/dist文件夹下的css文件夹中的index.css</span></span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h2><p>将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 <code>sourceMap</code>。只能用在 webpack4 中，对比另一个插件 extract-text-webpack-plugin 有以下特点:</p><ul><li>异步加载</li><li>不重复编译，性能更好</li><li>更容易使用</li><li>只针对 CSS</li></ul><p>这个插件应该只用在生产环境配置，并且在 <code>loaders</code> 链中不使用 <code>style-loader</code>, 而且这个插件暂时不支持 HMR</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: <span class="string">'../'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span>,</span><br><span class="line">          <span class="string">'less-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].[contenthash:8].css'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'css/[id].[contenthash:8].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="purifycss-webpack"><a href="#purifycss-webpack" class="headerlink" title="purifycss-webpack"></a>purifycss-webpack</h2><p>有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurifyCssWebpack(&#123;</span><br><span class="line">      paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h2><p>我们希望减小 css 打包后的体积，可以用到 <code>optimize-css-assets-webpack-plugin</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h2><p><code>uglifyJsPlugin</code> 是 <code>vue-cli</code> 默认使用的压缩代码方式，用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。它使用的是单线程压缩代码，打包时间较慢，所以可以在开发环境将其关闭，生产环境部署时再把它打开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: <span class="literal">true</span>,  <span class="comment">//是否启用文件缓存</span></span><br><span class="line">    parallel: <span class="literal">true</span>   <span class="comment">//使用多进程并行运行来提高构建速度</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="ParallelUglifyPlugin"><a href="#ParallelUglifyPlugin" class="headerlink" title="ParallelUglifyPlugin"></a>ParallelUglifyPlugin</h2><p>开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 <code>UglifyJS</code> 去压缩代码，但是变成了并行执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">    <span class="comment">//cacheDir 用于配置缓存存放的目录路径。</span></span><br><span class="line">    cacheDir: <span class="string">'.cache/'</span>,</span><br><span class="line">    sourceMap: <span class="literal">true</span>,</span><br><span class="line">    uglifyJS: &#123;</span><br><span class="line">      output: &#123;</span><br><span class="line">        comments: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a>terser-webpack-plugin</h2><p>Webpack4.0 默认是使用 <code>terser-webpack-plugin</code> 这个压缩插件，在此之前是使用 <code>uglifyjs-webpack-plugin</code>，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 <code>parallel</code> 参数，使用多进程压缩，加快压缩。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>) <span class="comment">// 压缩js代码</span></span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      parallel: <span class="number">4</span>, <span class="comment">// 开启几个进程来处理压缩，默认是 os.cpus().length - 1</span></span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 是否缓存</span></span><br><span class="line">      sourceMap: <span class="literal">false</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NoErrorsPlugin"><a href="#NoErrorsPlugin" class="headerlink" title="NoErrorsPlugin"></a>NoErrorsPlugin</h2><p>报错但不退出 webpack 进程。编译出现错误时，使用 <code>NoEmitOnErrorsPlugin</code> 来跳过输出阶段。这样可以确保输出资源不会包含错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins: [<span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()]</span><br></pre></td></tr></table></figure><h2 id="compression-webpack-plugin"><a href="#compression-webpack-plugin" class="headerlink" title="compression-webpack-plugin"></a>compression-webpack-plugin</h2><p>所有现代浏览器都支持 <code>gzip</code> 压缩，启用 <code>gzip</code> 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</p><p>gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">    <span class="comment">// gzip压缩配置</span></span><br><span class="line">    test: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">    threshold: <span class="number">10240</span>, <span class="comment">// 对超过10kb的数据进行压缩</span></span><br><span class="line">    deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除原文件</span></span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当然，这个方法还需要后端配置支持。</p><h2 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h2><p>我们可以通过 <code>DefinePlugin</code> 可以定义一些全局的变量，我们可以在模块当中直接使用这些变量，无需作任何声明，<code>DefinePlugin</code> 是 <code>webpack</code> 自带的插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    DESCRIPTION: <span class="string">'This Is The Test Text.'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接引用</span></span><br><span class="line"><span class="built_in">console</span>.log(DESCRIPTION)</span><br></pre></td></tr></table></figure><h2 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h2><p>自动加载模块。 任何时候，当 <code>identifier</code> 被当作未赋值的变量时， module 就会自动被加载，并且 <code>identifier</code> 会被这个 module 输出的内容所赋值。这是 webpack 自带的插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      jquery: <span class="string">'./lib/jquery'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//提供全局的变量，在模块中使用无需用require引入</span></span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      $: <span class="string">'jquery'</span>,</span><br><span class="line">      React: <span class="string">'react'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DLLPlugin"><a href="#DLLPlugin" class="headerlink" title="DLLPlugin"></a>DLLPlugin</h2><p>这是在一个额外的独立的 webpack 设置中创建一个只有 dll 的 <code>bundle(dll-only-bundle)</code>。 这个插件会生成一个名为 <code>manifest.json</code> 的文件，这个文件是用来让 <code>DLLReferencePlugin</code> 映射到相关的依赖上去的。</p><p><strong>使用步骤如下</strong></p><p>1、在 build 下创建 <code>webpack.dll.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [</span><br><span class="line">      <span class="string">'vue-router'</span>,</span><br><span class="line">      <span class="string">'vuex'</span>,</span><br><span class="line">      <span class="string">'vue/dist/vue.common.js'</span>,</span><br><span class="line">      <span class="string">'vue/dist/vue.js'</span>,</span><br><span class="line">      <span class="string">'vue-loader/lib/component-normalizer.js'</span>,</span><br><span class="line">      <span class="string">'vue'</span>,</span><br><span class="line">      <span class="string">'axios'</span>,</span><br><span class="line">      <span class="string">'echarts'</span>,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(<span class="string">'./dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    library: <span class="string">'[name]_library'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.resolve(<span class="string">'./dist'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]_library'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 建议加上代码压缩插件，否则dll包会比较大。</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在 <code>webpack.prod.conf.js</code> 的 plugin 后面加入配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">  manifest: <span class="built_in">require</span>(<span class="string">'../dist/vendor-manifest.json'</span>),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、<code>package.json</code>文件中添加快捷命令<code>(build:dll)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">  <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue src"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</span><br><span class="line">  <span class="string">"build:dll"</span>: <span class="string">"webpack --config build/webpack.dll.conf.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产环境打包的时候先<code>npm run build:dll</code>命令会在打包目录下生成 <code>vendor-manifest.json</code> 文件与 vendor.dll.js 文件。然后<code>npm run build</code>生产其他文件。</p><p>4、根目录下的入口 <code>index.html</code> 加入引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./vendor.dll.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h2><p><code>HappyPack</code> 能让 webpack 把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。要注意的是 <code>HappyPack</code> 对 <code>file-loader</code>、<code>url-loader</code> 支持的不友好，所以不建议对该 loader 使用。</p><p>1、HappyPack 插件安装</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> -D happypack</span><br></pre></td></tr></table></figure><p>2、<code>webpack.base.conf.js</code> 文件对 module.rules 进行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      use: [<span class="string">'happypack/loader?id=vue'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在生产环境 <code>webpack.prod.conf.js</code> 文件进行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="comment">// 构造出共享进程池，在进程池中包含5个子进程</span></span><br><span class="line"><span class="keyword">const</span> HappyPackThreadPool = HappyPack.ThreadPool(&#123; <span class="attr">size</span>: <span class="number">5</span> &#125;)</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">    id: <span class="string">'babel'</span>,</span><br><span class="line">    <span class="comment">// 如何处理.js文件，用法和Loader配置中一样</span></span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    threadPool: HappyPackThreadPool,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'vue'</span>, <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: vueLoaderConfig,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    threadPool: HappyPackThreadPool,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>注意，当项目较小时，多线程打包反而会使打包速度变慢。</strong></p><h2 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h2><p>我们在 <code>public/index.html</code> 中引入了静态资源，但是打包的时候 webpack 并不会帮我们拷贝到 dist 目录，因此 <code>copy-webpack-plugin</code> 就可以很好地帮我做拷贝的工作了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="string">'public/js/*.js'</span>,</span><br><span class="line">          to: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'js'</span>),</span><br><span class="line">          flatten: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h2><p>这是 webpack 内置插件，它的作用是：忽略第三方包指定目录，让这些指定目录不要被打包进去。</p><p>比如我们要使用 <code>moment</code> 这个第三方依赖库，该库主要是对时间进行格式化，并且支持多个国家语言。虽然我设置了语言为中文，但是在打包的时候，是会将所有语言都打包进去的。这样就导致包很大，打包速度又慢。对此，我们可以用 <code>IgnorePlugin</code> 使得指定目录被忽略，从而使得打包变快，文件变小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去</span></span><br><span class="line">  <span class="keyword">new</span> Webpack.IgnorePlugin(<span class="regexp">/\.\/locale/</span>, /moment/),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们虽然按照上面的方法忽略了包含<code>’./locale/&#39;</code>该字段路径的文件目录，但是也使得我们使用的时候不能显示中文语言了，所以这个时候可以手动引入中文语言的目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动引入所需要的语言包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment/locale/zh-cn'</span></span><br><span class="line"></span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = moment().endOf(<span class="string">'day'</span>).fromNow()</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Plugin&quot;&gt;&lt;a href=&quot;#Plugin&quot; class=&quot;headerlink&quot; title=&quot;Plugin&quot;&gt;&lt;/a&gt;Plugin&lt;/h1&gt;&lt;p&gt;何为插件
      
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>总结18个webpack插件</title>
    <link href="https://chongdee.github.io/2021/07/20/Webpack/%E6%80%BB%E7%BB%9318%E4%B8%AAwebpack%E6%8F%92%E4%BB%B6/"/>
    <id>https://chongdee.github.io/2021/07/20/Webpack/总结18个webpack插件/</id>
    <published>2021-07-20T07:51:02.521Z</published>
    <updated>2021-07-20T07:51:57.614Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h1><p>何为插件(Plugin)？专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。plugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。</p><p>Plugin 的特点</p><ul><li>是一个独立的模块</li><li>模块对外暴露一个 js 函数</li><li>函数的原型 <code>(prototype)</code> 上定义了一个注入 <code>compiler</code> 对象的 <code>apply</code>方法 <code>apply</code> 函数中需要有通过 <code>compiler</code> 对象挂载的 <code>webpack</code> 事件钩子，钩子的回调中能拿到当前编译的 <code>compilation</code> 对象，如果是异步编译插件的话可以拿到回调 <code>callback</code></li><li>完成自定义子编译流程并处理 <code>complition</code> 对象的内部数据</li><li>如果异步编译插件的话，数据处理完成后执行 <code>callback</code> 回调。</li></ul><p>下面介绍 18 个常用的 webpack 插件</p><h2 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h2><p>模块热更新插件。<code>Hot-Module-Replacement</code> 的热更新是依赖于 <code>webpack-dev-server</code>，后者是在打包文件改变时更新打包文件或者 reload 刷新整个页面，<code>HRM</code> 是只更新修改的部分。</p><p><code>HotModuleReplacementPlugin</code>是<code>webpack</code>模块自带的，所以引入<code>webpack</code>后，在<code>plugins</code>配置项中直接使用即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// 热更新插件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>生成 html 文件。将 webpack 中<code>entry</code>配置的相关入口 <code>chunk</code> 和 <code>extract-text-webpack-plugin</code>抽取的 css 样式 插入到该插件提供的<code>template</code>或者<code>templateContent</code>配置项指定的内容基础上生成一个 html 文件，具体插入方式是将样式<code>link</code>插入到<code>head</code>元素中，<code>script</code>插入到<code>head</code>或者<code>body</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">    minify: &#123;</span><br><span class="line">      <span class="comment">// 压缩HTML文件</span></span><br><span class="line">      removeComments: <span class="literal">true</span>, <span class="comment">// 移除HTML中的注释</span></span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>, <span class="comment">// 删除空白符与换行符</span></span><br><span class="line">      minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩内联css</span></span><br><span class="line">    &#125;,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>inject 有四个选项值</p><ul><li>true：默认值，<code>script</code> 标签位于 <code>html</code> 文件的 <code>body</code> 底部</li><li>body：<code>script</code> 标签位于 <code>html</code> 文件的 <code>body</code> 底部（同 true）</li><li>head：<code>script</code> 标签位于 <code>head</code> 标签内</li><li>false：不插入生成的 js 文件，只是单纯的生成一个 <code>html</code> 文件</li></ul><p>多页应用打包</p><p>有时，我们的应用不一定是一个单页应用，而是一个多页应用，那么如何使用 webpack 进行打包呢。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    login: <span class="string">'./src/login.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].[hash:6].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/login.html'</span>,</span><br><span class="line">      filename: <span class="string">'login.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要配置多个 <code>HtmlWebpackPlugin</code>，那么 <code>filename</code> 字段不可缺省，否则默认生成的都是 <code>index.html</code>。</p><p>但是有个问题，<code>index.html</code> 和 <code>login.html</code> 会发现，都同时引入了 <code>index.f7d21a.js</code> 和 <code>login.f7d21a.js</code>，通常这不是我们想要的，我们希望 <code>index.html</code> 中只引入 <code>index.f7d21a.js</code>，<code>login.html</code> 只引入 <code>login.f7d21a.js</code>。</p><p><code>HtmlWebpackPlugin</code> 提供了一个 <code>chunks</code> 的参数，可以接受一个数组，配置此参数仅会将数组中指定的 js 引入到 html 文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">      chunks: [<span class="string">'index'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/login.html'</span>,</span><br><span class="line">      filename: <span class="string">'login.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">      chunks: [<span class="string">'login'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行 <code>npm run build</code>，可以看到 <code>index.html</code> 中仅引入了 index 的 js 文件，而 <code>login.html</code> 中也仅引入了 login 的 js 文件。</p><h2 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h2><p><code>clean-webpack-plugin</code> 用于在打包前清理上一次项目生成的 bundle 文件，它会根据 <code>output.path</code> 自动清理文件夹；这个插件在生产环境用的频率非常高，因为生产环境经常会通过 hash 生成很多 bundle 文件，如果不进行清理的话每次都会生成新的，导致文件夹非常庞大。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>),</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h2><p>将 css 成生文件，而非内联 。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// 将css分离到/dist文件夹下的css文件夹中的index.css</span></span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h2><p>将 CSS 提取为独立的文件的插件，对每个包含 css 的 js 文件都会创建一个 CSS 文件，支持按需加载 css 和 <code>sourceMap</code>。只能用在 webpack4 中，对比另一个插件 extract-text-webpack-plugin 有以下特点:</p><ul><li>异步加载</li><li>不重复编译，性能更好</li><li>更容易使用</li><li>只针对 CSS</li></ul><p>这个插件应该只用在生产环境配置，并且在 <code>loaders</code> 链中不使用 <code>style-loader</code>, 而且这个插件暂时不支持 HMR</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: <span class="string">'../'</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span>,</span><br><span class="line">          <span class="string">'less-loader'</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].[contenthash:8].css'</span>,</span><br><span class="line">      chunkFilename: <span class="string">'css/[id].[contenthash:8].css'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="purifycss-webpack"><a href="#purifycss-webpack" class="headerlink" title="purifycss-webpack"></a>purifycss-webpack</h2><p>有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurifyCssWebpack(&#123;</span><br><span class="line">      paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h2><p>我们希望减小 css 打包后的体积，可以用到 <code>optimize-css-assets-webpack-plugin</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h2><p><code>uglifyJsPlugin</code> 是 <code>vue-cli</code> 默认使用的压缩代码方式，用来对 js 文件进行压缩，从而减小 js 文件的大小，加速 load 速度。它使用的是单线程压缩代码，打包时间较慢，所以可以在开发环境将其关闭，生产环境部署时再把它打开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">    uglifyOptions: &#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sourceMap: <span class="literal">true</span>,  <span class="comment">//是否启用文件缓存</span></span><br><span class="line">    parallel: <span class="literal">true</span>   <span class="comment">//使用多进程并行运行来提高构建速度</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="ParallelUglifyPlugin"><a href="#ParallelUglifyPlugin" class="headerlink" title="ParallelUglifyPlugin"></a>ParallelUglifyPlugin</h2><p>开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，每个子进程其实还是通过 <code>UglifyJS</code> 去压缩代码，但是变成了并行执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ParallelUglifyPlugin = <span class="built_in">require</span>(<span class="string">'webpack-parallel-uglify-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ParallelUglifyPlugin(&#123;</span><br><span class="line">    <span class="comment">//cacheDir 用于配置缓存存放的目录路径。</span></span><br><span class="line">    cacheDir: <span class="string">'.cache/'</span>,</span><br><span class="line">    sourceMap: <span class="literal">true</span>,</span><br><span class="line">    uglifyJS: &#123;</span><br><span class="line">      output: &#123;</span><br><span class="line">        comments: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a>terser-webpack-plugin</h2><p>Webpack4.0 默认是使用 <code>terser-webpack-plugin</code> 这个压缩插件，在此之前是使用 <code>uglifyjs-webpack-plugin</code>，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 <code>parallel</code> 参数，使用多进程压缩，加快压缩。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>) <span class="comment">// 压缩js代码</span></span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      parallel: <span class="number">4</span>, <span class="comment">// 开启几个进程来处理压缩，默认是 os.cpus().length - 1</span></span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 是否缓存</span></span><br><span class="line">      sourceMap: <span class="literal">false</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NoErrorsPlugin"><a href="#NoErrorsPlugin" class="headerlink" title="NoErrorsPlugin"></a>NoErrorsPlugin</h2><p>报错但不退出 webpack 进程。编译出现错误时，使用 <code>NoEmitOnErrorsPlugin</code> 来跳过输出阶段。这样可以确保输出资源不会包含错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins: [<span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()]</span><br></pre></td></tr></table></figure><h2 id="compression-webpack-plugin"><a href="#compression-webpack-plugin" class="headerlink" title="compression-webpack-plugin"></a>compression-webpack-plugin</h2><p>所有现代浏览器都支持 <code>gzip</code> 压缩，启用 <code>gzip</code> 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</p><p>gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">    <span class="comment">// gzip压缩配置</span></span><br><span class="line">    test: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">    threshold: <span class="number">10240</span>, <span class="comment">// 对超过10kb的数据进行压缩</span></span><br><span class="line">    deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除原文件</span></span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当然，这个方法还需要后端配置支持。</p><h2 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h2><p>我们可以通过 <code>DefinePlugin</code> 可以定义一些全局的变量，我们可以在模块当中直接使用这些变量，无需作任何声明，<code>DefinePlugin</code> 是 <code>webpack</code> 自带的插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">    DESCRIPTION: <span class="string">'This Is The Test Text.'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接引用</span></span><br><span class="line"><span class="built_in">console</span>.log(DESCRIPTION)</span><br></pre></td></tr></table></figure><h2 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h2><p>自动加载模块。 任何时候，当 <code>identifier</code> 被当作未赋值的变量时， module 就会自动被加载，并且 <code>identifier</code> 会被这个 module 输出的内容所赋值。这是 webpack 自带的插件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      jquery: <span class="string">'./lib/jquery'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">//提供全局的变量，在模块中使用无需用require引入</span></span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      $: <span class="string">'jquery'</span>,</span><br><span class="line">      React: <span class="string">'react'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DLLPlugin"><a href="#DLLPlugin" class="headerlink" title="DLLPlugin"></a>DLLPlugin</h2><p>这是在一个额外的独立的 webpack 设置中创建一个只有 dll 的 <code>bundle(dll-only-bundle)</code>。 这个插件会生成一个名为 <code>manifest.json</code> 的文件，这个文件是用来让 <code>DLLReferencePlugin</code> 映射到相关的依赖上去的。</p><p><strong>使用步骤如下</strong></p><p>1、在 build 下创建 <code>webpack.dll.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [</span><br><span class="line">      <span class="string">'vue-router'</span>,</span><br><span class="line">      <span class="string">'vuex'</span>,</span><br><span class="line">      <span class="string">'vue/dist/vue.common.js'</span>,</span><br><span class="line">      <span class="string">'vue/dist/vue.js'</span>,</span><br><span class="line">      <span class="string">'vue-loader/lib/component-normalizer.js'</span>,</span><br><span class="line">      <span class="string">'vue'</span>,</span><br><span class="line">      <span class="string">'axios'</span>,</span><br><span class="line">      <span class="string">'echarts'</span>,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(<span class="string">'./dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    library: <span class="string">'[name]_library'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      path: path.resolve(<span class="string">'./dist'</span>, <span class="string">'[name]-manifest.json'</span>),</span><br><span class="line">      name: <span class="string">'[name]_library'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 建议加上代码压缩插件，否则dll包会比较大。</span></span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在 <code>webpack.prod.conf.js</code> 的 plugin 后面加入配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">  manifest: <span class="built_in">require</span>(<span class="string">'../dist/vendor-manifest.json'</span>),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、<code>package.json</code>文件中添加快捷命令<code>(build:dll)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"npm run dev"</span>,</span><br><span class="line">  <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue src"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"node build/build.js"</span>,</span><br><span class="line">  <span class="string">"build:dll"</span>: <span class="string">"webpack --config build/webpack.dll.conf.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产环境打包的时候先<code>npm run build:dll</code>命令会在打包目录下生成 <code>vendor-manifest.json</code> 文件与 vendor.dll.js 文件。然后<code>npm run build</code>生产其他文件。</p><p>4、根目录下的入口 <code>index.html</code> 加入引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./vendor.dll.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h2><p><code>HappyPack</code> 能让 webpack 把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程。要注意的是 <code>HappyPack</code> 对 <code>file-loader</code>、<code>url-loader</code> 支持的不友好，所以不建议对该 loader 使用。</p><p>1、HappyPack 插件安装</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> -D happypack</span><br></pre></td></tr></table></figure><p>2、<code>webpack.base.conf.js</code> 文件对 module.rules 进行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: [<span class="string">'happypack/loader?id=babel'</span>],</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">      exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">      use: [<span class="string">'happypack/loader?id=vue'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在生产环境 <code>webpack.prod.conf.js</code> 文件进行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="comment">// 构造出共享进程池，在进程池中包含5个子进程</span></span><br><span class="line"><span class="keyword">const</span> HappyPackThreadPool = HappyPack.ThreadPool(&#123; <span class="attr">size</span>: <span class="number">5</span> &#125;)</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">    id: <span class="string">'babel'</span>,</span><br><span class="line">    <span class="comment">// 如何处理.js文件，用法和Loader配置中一样</span></span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    threadPool: HappyPackThreadPool,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'vue'</span>, <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: vueLoaderConfig,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    threadPool: HappyPackThreadPool,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>注意，当项目较小时，多线程打包反而会使打包速度变慢。</strong></p><h2 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h2><p>我们在 <code>public/index.html</code> 中引入了静态资源，但是打包的时候 webpack 并不会帮我们拷贝到 dist 目录，因此 <code>copy-webpack-plugin</code> 就可以很好地帮我做拷贝的工作了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">from</span>: <span class="string">'public/js/*.js'</span>,</span><br><span class="line">          to: path.resolve(__dirname, <span class="string">'dist'</span>, <span class="string">'js'</span>),</span><br><span class="line">          flatten: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h2><p>这是 webpack 内置插件，它的作用是：忽略第三方包指定目录，让这些指定目录不要被打包进去。</p><p>比如我们要使用 <code>moment</code> 这个第三方依赖库，该库主要是对时间进行格式化，并且支持多个国家语言。虽然我设置了语言为中文，但是在打包的时候，是会将所有语言都打包进去的。这样就导致包很大，打包速度又慢。对此，我们可以用 <code>IgnorePlugin</code> 使得指定目录被忽略，从而使得打包变快，文件变小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去</span></span><br><span class="line">  <span class="keyword">new</span> Webpack.IgnorePlugin(<span class="regexp">/\.\/locale/</span>, /moment/),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们虽然按照上面的方法忽略了包含<code>’./locale/&#39;</code>该字段路径的文件目录，但是也使得我们使用的时候不能显示中文语言了，所以这个时候可以手动引入中文语言的目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动引入所需要的语言包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'moment/locale/zh-cn'</span></span><br><span class="line"></span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = moment().endOf(<span class="string">'day'</span>).fromNow()</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Plugin&quot;&gt;&lt;a href=&quot;#Plugin&quot; class=&quot;headerlink&quot; title=&quot;Plugin&quot;&gt;&lt;/a&gt;Plugin&lt;/h1&gt;&lt;p&gt;何为插件
      
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>从零构建到优化一个类似vue-cli的脚手架</title>
    <link href="https://chongdee.github.io/2021/07/20/webpack/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%88%B0%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCvue-cli%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>https://chongdee.github.io/2021/07/20/webpack/从零构建到优化一个类似vue-cli的脚手架/</id>
    <published>2021-07-20T07:49:22.423Z</published>
    <updated>2021-07-20T07:50:06.406Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想必大多数人在开发 vue 等 SPA 项目都时候都会直接用 <code>vue-cli</code> 等脚手架开发，一是方便省去了好多配置上的功夫，二是 <code>vue-cli</code> 毕竟是久经考验较为成熟的东西，遇到问题也能在网上找到相应解决方案。</p><p>但是，如果我们要更好地理解脚手架的配置及其构建打包的机制，我们就有必要从零开始，依葫芦画瓢自己配置一个类似于 vue-cli 这样的项目了。在此，我做了以下简单配置，请各位大佬批评指正，并诚心希望能得到大佬的指点，解决文章最后关于 <code>Tree Shaking</code> 导致打包缺失 css 的问题。</p><p>本文主要包括如下配置：</p><ul><li>区分环境变量及合并配置</li><li><code>webpack-dev-server</code> 本地服务器 </li><li><code>HtmlWebpackPlugin</code> 生成 html</li><li><code>CleanWebpackPlugin</code> 清理文件夹</li><li><code>loader</code> 及 <code>babel</code> 配置</li><li><code>HotModuleReplacementPlugin</code> 热更新</li><li><code>postcss-loader</code> 增加 css 前缀</li><li><code>vue SPA</code> 引入及解析</li><li><code>vue-router</code> 安装与使用</li><li><code>mini-css-extract-plugin</code> 分离 css</li><li><code>purifycss-webpack purify-css</code> 消除冗余 css</li><li><code>optimize-css-assets-webpack-plugin</code> 压缩 css</li><li><code>terser-webpack-plugin</code> 压缩 js</li><li><code>splitChunks</code> 提取公共代码</li><li><code>image-webpack-loader</code> 图片压缩</li><li><code>gZip</code> 加速优化</li></ul><p>项目源码：<a href="https://github.com/Michael-lzg/webpack-vue-cli" target="_blank" rel="noopener">https://github.com/Michael-lzg/webpack-vue-cli</a></p><p>如果对 webpack 基本配置还不了解的小伙伴，可查看以下文章<br><a href="https://juejin.im/post/5db0fd1bf265da4d4216a9c5" target="_blank" rel="noopener">从零开始构建一个 webpack 项目</a><br><a href="https://juejin.im/post/5eb766296fb9a0432f0ff8c7#heading-19" target="_blank" rel="noopener">搭建一个 vue-cli4+webpack 移动端框架（开箱即用）</a></p><p>废话不多说，老司机带你立刻上路。</p><h3 id="搭建-webpack-项目框架"><a href="#搭建-webpack-项目框架" class="headerlink" title="搭建 webpack 项目框架"></a>搭建 webpack 项目框架</h3><h4 id="构建项目结构"><a href="#构建项目结构" class="headerlink" title="构建项目结构"></a>构建项目结构</h4><ol><li><p>创建 <code>webpack-vue-cli</code> 文件夹，<code>npm-init-y</code> 初始化项目</p></li><li><p>安装 webpack 相关依赖</p></li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli webpack-<span class="built_in">dev</span>-server webpack-merge --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>如果 <code>webpack</code> 和 <code>webpack-cli</code> 没有全局安装的话，要先全局安装</p><ol><li>建立项目文件夹</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── src   <span class="comment">// webpack配置文件</span></span><br><span class="line">    |——main.js  <span class="comment">// 入口文件</span></span><br><span class="line">├── <span class="keyword">static</span>   <span class="comment">// 项目打包路径</span></span><br><span class="line">├── index.html   <span class="comment">// 模板html</span></span><br><span class="line">├── webpack.base.js   <span class="comment">// 打包基本配置</span></span><br><span class="line">├── webpack.dev.js   <span class="comment">// 本地环境配置</span></span><br><span class="line">├── webpack.prod.js   <span class="comment">// 生产环境配置</span></span><br></pre></td></tr></table></figure><p><code>index.html</code> 和 <code>main.js</code> 的代码不多说，直接进入 webpack 配置环节。</p><h4 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h4><p>为了更好的优化打包，我们将 webpack 的配置分开开发环境和生产环境。</p><ul><li>webpack.base.js 公共配置文件</li><li>webpack.dev.js 开发环境的配置文件</li><li>webpack.prod.js 生产环境的配置文件</li></ul><p>在 <code>webpack.dev.js</code> 和 <code>webpack.prod.js</code>，我们可以利用 <code>webpack-merge</code> 进行配置的合并。</p><p>然后，我们在 package.json 定义不同环境的打包命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server  --config webpack.dev.js --mode development"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --config webpack.prod.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公共配置"><a href="#公共配置" class="headerlink" title="公共配置"></a>公共配置</h4><p>我们先来看一下 <code>webpack.base.js</code> 的公共配置，定义好入口文件和出口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: path.join(__dirname, <span class="string">'/src/main.js'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span>, <span class="comment">// 每次保存 hash 都变化</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 <code>node.js</code> 构建，所以在 <code>webpack.dev.js</code> 进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>) <span class="comment">// 引入webpack-merge功能模块</span></span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>) <span class="comment">// 引入webpack.common.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  <span class="comment">// 将webpack.common.js合并到当前文件</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8899'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>, <span class="comment">//不跳转</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 热更新</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'development'</span>, <span class="comment">// 设置mode</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h4><p><code>HtmlWebpackPlugin</code> 简化了 HTML 文件的创建，它可以根据 html 模板在打包后自动为你生产打包后的 html 文件。这对于在文件名中包含每次会随着编译而发生变化哈希的<code>bundle</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>), <span class="comment">// new一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>至此就搭建好一个乞丐版的 <code>webpack</code> 项目了，你可以随意编写代码，分别在开发环境和生产环境执行命令查看效果。</p><h4 id="loader-配置"><a href="#loader-配置" class="headerlink" title="loader 配置"></a>loader 配置</h4><p><code>loader</code> 可以让 <code>webpack</code> 能够去处理那些非 <code>javaScript</code> 文件（<code>webpack</code> 自身只理解 <code>javaScript</code>）。<code>loader</code> 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>对于 <code>loader</code> 的科普和配置，在这里不做一一说明，直接奉上代码，分别是处理样式，<code>js</code> 和文件的 <code>loader</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更方便的配置和优化 <code>babel-loader</code>，我们可以将其提取出来，在根目录下新建 <code>.babelrc</code> 文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a>CleanWebpackPlugin</h4><p>在每次构建前清理/dist 文件夹，生产最新的打包文件，这时候就用到 <code>CleanWebpackPlugin</code> 插件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>), <span class="comment">// new一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h4><p><code>HotModuleReplacementPlugin</code>（HMR）是一个很实用的插件，可以在我们修改代码后自动刷新预览效果，在开发环境使用。</p><ol><li><p><code>devServer</code> 配置项中设置 <code>hot: true</code></p></li><li><p><code>HotModuleReplacementPlugin</code> 是 webpack 模块自带的，所以引入 webpack 后，在 <code>plugins</code> 配置项中直接使用即可。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// 热更新插件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="增加-css-前缀"><a href="#增加-css-前缀" class="headerlink" title="增加 css 前缀"></a>增加 css 前缀</h4><p>平时我们写 css 时，一些属性需要手动加上前缀，比如<code>-webkit-border-radius: 10px;</code>，在 webpack 中我们可以让他自动加上</p><ol><li>安装依赖</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure><ol><li>在项目根目录下新建 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>), <span class="comment">// 引用autoprefixer模块</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>修改样式 loader</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>至此，一个 webpack 项目基本搭建而成，下面介绍 vue 的引用和项目优化。</p><h3 id="搭建-vue-SPA-模板"><a href="#搭建-vue-SPA-模板" class="headerlink" title="搭建 vue SPA 模板"></a>搭建 vue SPA 模板</h3><h4 id="vue-SPA"><a href="#vue-SPA" class="headerlink" title="vue SPA"></a>vue SPA</h4><p>1、搭建一个类似于 <code>vue-cli</code> 的脚手架，首先我们来依葫芦画瓢，在 <code>main.js</code> 写上一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、然后在 src 文件夹下新建 <code>APP.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>SPA项目<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、安装相关依赖</p><p>到这里，我们 <code>npm run dev</code> 试一下就报错了。因为我们没有安装相关依赖，下面我们下来安装一下依赖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> vue vue-loader vue-<span class="keyword">template</span>-compiler -D</span><br></pre></td></tr></table></figure><ul><li>vue: vue 的源码</li><li>vue-loader：解析.vue 文件</li><li>vue-template-compiler： 编译 vue</li></ul><p>4、在 webpack 配置 vue-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> VueLoaderPlugin()],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h4><p>1、安装依赖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> vue-router -D</span><br></pre></td></tr></table></figure><p>2、在 src 文件夹下新建 router/index</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/admin'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/admin.vue'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>3、在 main.js 引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就这样，一个类似于 <code>vue-cli</code> 的脚手架就搭建好了，你可以愉快地写 <code>.vue</code> 文件进行 SPA 开发。</p><h3 id="webpack-优化打包"><a href="#webpack-优化打包" class="headerlink" title="webpack 优化打包"></a>webpack 优化打包</h3><h4 id="分离-css"><a href="#分离-css" class="headerlink" title="分离 css"></a>分离 css</h4><p>虽然 webpack 的理念是把 css、js 全都打包到一个文件里，但要是我们想把 css 分离出来，这里我们用到 <code>mini-css-extract-plugin</code>。对比另一个插件 <code>extract-text-webpack-plugin</code>，它有以下优点:</p><ul><li>异步加载</li><li>不重复编译，性能更好</li><li>更容易使用</li><li>只针对 CSS</li></ul><p>但是<code>mini-css-extract-plugin</code> 不支持 <code>HMR</code>，所以我们只能在生产环境使用它。</p><p>1、安装依赖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> mini-css-<span class="keyword">extract</span>-<span class="keyword">plugin</span> -D</span><br></pre></td></tr></table></figure><p>2、在<code>webpack.prod.js</code> 配置 <code>loader</code> 和 <code>plugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: MiniCssExtractPlugin.loader,</span><br><span class="line">          options: &#123;</span><br><span class="line">            publicPath: <span class="string">'../'</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'css-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span>,</span><br><span class="line">        <span class="string">'less-loader'</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">"css/[name].[contenthash:8].css"</span>,</span><br><span class="line">    chunkFilename: <span class="string">'css/[id].[contenthash:8].css'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>分离 css 需要将 <code>css loader</code> 中的 <code>style-loader</code> 替换为 <code>MiniCssExtractPlugin</code></p><h4 id="消除冗余-css"><a href="#消除冗余-css" class="headerlink" title="消除冗余 css"></a>消除冗余 css</h4><p>有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。</p><p>1、安装依赖</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i purifycss-webpack purify-css <span class="keyword">glob</span> -<span class="built_in">D</span></span><br></pre></td></tr></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurifyCssWebpack(&#123;</span><br><span class="line">      paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="压缩-css"><a href="#压缩-css" class="headerlink" title="压缩 css"></a>压缩 css</h4><p>我们希望减小 css 打包后的体积，可以用到 <code>optimize-css-assets-webpack-plugin</code>。<br>1、安装依赖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="keyword">optimize</span>-css-assets-webpack-<span class="keyword">plugin</span> -D</span><br></pre></td></tr></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h4 id="压缩-js"><a href="#压缩-js" class="headerlink" title="压缩 js"></a>压缩 js</h4><p>Webpack4.0 默认是使用 <code>terser-webpack-plugin</code> 这个压缩插件，在此之前是使用 <code>uglifyjs-webpack-plugin</code>，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 <code>parallel</code> 参数，使用多进程压缩，加快压缩。</p><p>1、安装依赖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> terser-webpack-<span class="keyword">plugin</span> -D</span><br></pre></td></tr></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>) <span class="comment">// 压缩js代码</span></span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      parallel: <span class="number">4</span>, <span class="comment">// 开启几个进程来处理压缩，默认是 os.cpus().length - 1</span></span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 是否缓存</span></span><br><span class="line">      sourceMap: <span class="literal">false</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h4><p>在用 webpack 打包的时候，对于一些不经常更新的第三方库，比如 vue 全家桶的一些东西， 我们希望能和自己的代码分离开。webpack4 使用 <code>splitChunks</code> 的方法进行配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  <span class="comment">// 分离chunks</span></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: <span class="string">'all'</span>,</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      vendor: &#123;</span><br><span class="line">        name: <span class="string">"vendor"</span>,</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">10</span>,</span><br><span class="line">        chunks: <span class="string">"initial"</span> <span class="comment">// 只打包初始时依赖的第三方</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p>在项目中有些图片太大影响加载，我们用 <code>image-webpack-loader</code> 进行压缩。</p><p>1、安装依赖</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="built_in">image</span>-webpack-loader -D</span><br></pre></td></tr></table></figure><p>2、配置 loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpg|svg|gif)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        esModule: <span class="literal">false</span>,</span><br><span class="line">        limit: <span class="number">1000</span>,  <span class="comment">// 限制只有小于1kb的图片才转为base64</span></span><br><span class="line">        outputPath: <span class="string">'images'</span>, <span class="comment">// 设置打包后图片存放的文件夹名称</span></span><br><span class="line">        name: <span class="string">'[name][hash:8].[ext]'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">        mozjpeg: &#123;</span><br><span class="line">          progressive: <span class="literal">true</span>,</span><br><span class="line">          quality: <span class="number">65</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 使用 imagemin**-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">        optipng: &#123;</span><br><span class="line">          enabled: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// // 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">        pngquant: &#123;</span><br><span class="line">          quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">          speed: <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">        gifsicle: &#123;</span><br><span class="line">          interlaced: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">        webp: &#123;</span><br><span class="line">          quality: <span class="number">75</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gZip-加速优化"><a href="#gZip-加速优化" class="headerlink" title="gZip 加速优化"></a>gZip 加速优化</h4><p>所有现代浏览器都支持 <code>gzip</code> 压缩，启用 <code>gzip</code> 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</p><p>gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    config.plugins.push(</span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">        <span class="comment">// gzip压缩配置</span></span><br><span class="line">        test: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">        threshold: <span class="number">10240</span>, <span class="comment">// 对超过10kb的数据进行压缩</span></span><br><span class="line">        deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除原文件</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tree-shaking（求助，生产环境打包生成不了样式）"><a href="#tree-shaking（求助，生产环境打包生成不了样式）" class="headerlink" title="tree-shaking（求助，生产环境打包生成不了样式）"></a>tree-shaking（求助，生产环境打包生成不了样式）</h3><p>按以上的方式构建项目，在开发环境一直都是顺顺利利的，然而一执行 <code>npm run build</code>，打开页面，发现样式全都缺失了。打开 <code>dist/css</code> 文件夹，发现三个 css 文件，只有 <code>index.css</code> 有部分文件（是 main.js 引入额初始化样式，但也是不全的），另外两个 css 文件则是空空如也，也就是.vue 里面的样式全都缺失了。</p><p>查看资源，初步判断为 webpack4 默认使用 <code>tree-shaking</code>，会把 <strong>在模块的层面上做到打包后的代码只包含被引用并被执行的模块，而不被引用或不被执行的模块被删除掉，以起到减包的效果</strong>。但是我已经按相关资源在 <code>package.json</code> 配置了 <code>sideEffects</code> 了，但是还是没用，实在苦恼！！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"*.less"</span>,</span><br><span class="line">    <span class="string">"*.css"</span>,</span><br><span class="line">    <span class="string">"*.vue"</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;想必大多数人在开发 vue 等 SPA 
      
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>从零构建到优化一个类似vue-cli的脚手架</title>
    <link href="https://chongdee.github.io/2021/07/20/Webpack/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%88%B0%E4%BC%98%E5%8C%96%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%BC%BCvue-cli%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>https://chongdee.github.io/2021/07/20/Webpack/从零构建到优化一个类似vue-cli的脚手架/</id>
    <published>2021-07-20T07:49:22.423Z</published>
    <updated>2021-07-20T07:50:06.406Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想必大多数人在开发 vue 等 SPA 项目都时候都会直接用 <code>vue-cli</code> 等脚手架开发，一是方便省去了好多配置上的功夫，二是 <code>vue-cli</code> 毕竟是久经考验较为成熟的东西，遇到问题也能在网上找到相应解决方案。</p><p>但是，如果我们要更好地理解脚手架的配置及其构建打包的机制，我们就有必要从零开始，依葫芦画瓢自己配置一个类似于 vue-cli 这样的项目了。在此，我做了以下简单配置，请各位大佬批评指正，并诚心希望能得到大佬的指点，解决文章最后关于 <code>Tree Shaking</code> 导致打包缺失 css 的问题。</p><p>本文主要包括如下配置：</p><ul><li>区分环境变量及合并配置</li><li><code>webpack-dev-server</code> 本地服务器 </li><li><code>HtmlWebpackPlugin</code> 生成 html</li><li><code>CleanWebpackPlugin</code> 清理文件夹</li><li><code>loader</code> 及 <code>babel</code> 配置</li><li><code>HotModuleReplacementPlugin</code> 热更新</li><li><code>postcss-loader</code> 增加 css 前缀</li><li><code>vue SPA</code> 引入及解析</li><li><code>vue-router</code> 安装与使用</li><li><code>mini-css-extract-plugin</code> 分离 css</li><li><code>purifycss-webpack purify-css</code> 消除冗余 css</li><li><code>optimize-css-assets-webpack-plugin</code> 压缩 css</li><li><code>terser-webpack-plugin</code> 压缩 js</li><li><code>splitChunks</code> 提取公共代码</li><li><code>image-webpack-loader</code> 图片压缩</li><li><code>gZip</code> 加速优化</li></ul><p>项目源码：<a href="https://github.com/Michael-lzg/webpack-vue-cli" target="_blank" rel="noopener">https://github.com/Michael-lzg/webpack-vue-cli</a></p><p>如果对 webpack 基本配置还不了解的小伙伴，可查看以下文章<br><a href="https://juejin.im/post/5db0fd1bf265da4d4216a9c5" target="_blank" rel="noopener">从零开始构建一个 webpack 项目</a><br><a href="https://juejin.im/post/5eb766296fb9a0432f0ff8c7#heading-19" target="_blank" rel="noopener">搭建一个 vue-cli4+webpack 移动端框架（开箱即用）</a></p><p>废话不多说，老司机带你立刻上路。</p><h3 id="搭建-webpack-项目框架"><a href="#搭建-webpack-项目框架" class="headerlink" title="搭建 webpack 项目框架"></a>搭建 webpack 项目框架</h3><h4 id="构建项目结构"><a href="#构建项目结构" class="headerlink" title="构建项目结构"></a>构建项目结构</h4><ol><li><p>创建 <code>webpack-vue-cli</code> 文件夹，<code>npm-init-y</code> 初始化项目</p></li><li><p>安装 webpack 相关依赖</p></li></ol><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli webpack-<span class="built_in">dev</span>-server webpack-merge --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>如果 <code>webpack</code> 和 <code>webpack-cli</code> 没有全局安装的话，要先全局安装</p><ol><li>建立项目文件夹</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── src   <span class="comment">// webpack配置文件</span></span><br><span class="line">    |——main.js  <span class="comment">// 入口文件</span></span><br><span class="line">├── <span class="keyword">static</span>   <span class="comment">// 项目打包路径</span></span><br><span class="line">├── index.html   <span class="comment">// 模板html</span></span><br><span class="line">├── webpack.base.js   <span class="comment">// 打包基本配置</span></span><br><span class="line">├── webpack.dev.js   <span class="comment">// 本地环境配置</span></span><br><span class="line">├── webpack.prod.js   <span class="comment">// 生产环境配置</span></span><br></pre></td></tr></table></figure><p><code>index.html</code> 和 <code>main.js</code> 的代码不多说，直接进入 webpack 配置环节。</p><h4 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h4><p>为了更好的优化打包，我们将 webpack 的配置分开开发环境和生产环境。</p><ul><li>webpack.base.js 公共配置文件</li><li>webpack.dev.js 开发环境的配置文件</li><li>webpack.prod.js 生产环境的配置文件</li></ul><p>在 <code>webpack.dev.js</code> 和 <code>webpack.prod.js</code>，我们可以利用 <code>webpack-merge</code> 进行配置的合并。</p><p>然后，我们在 package.json 定义不同环境的打包命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server  --config webpack.dev.js --mode development"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --config webpack.prod.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公共配置"><a href="#公共配置" class="headerlink" title="公共配置"></a>公共配置</h4><p>我们先来看一下 <code>webpack.base.js</code> 的公共配置，定义好入口文件和出口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: path.join(__dirname, <span class="string">'/src/main.js'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span>, <span class="comment">// 每次保存 hash 都变化</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 <code>node.js</code> 构建，所以在 <code>webpack.dev.js</code> 进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>) <span class="comment">// 引入webpack-merge功能模块</span></span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>) <span class="comment">// 引入webpack.common.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  <span class="comment">// 将webpack.common.js合并到当前文件</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8899'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>, <span class="comment">//不跳转</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 热更新</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'development'</span>, <span class="comment">// 设置mode</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h4><p><code>HtmlWebpackPlugin</code> 简化了 HTML 文件的创建，它可以根据 html 模板在打包后自动为你生产打包后的 html 文件。这对于在文件名中包含每次会随着编译而发生变化哈希的<code>bundle</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>), <span class="comment">// new一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>至此就搭建好一个乞丐版的 <code>webpack</code> 项目了，你可以随意编写代码，分别在开发环境和生产环境执行命令查看效果。</p><h4 id="loader-配置"><a href="#loader-配置" class="headerlink" title="loader 配置"></a>loader 配置</h4><p><code>loader</code> 可以让 <code>webpack</code> 能够去处理那些非 <code>javaScript</code> 文件（<code>webpack</code> 自身只理解 <code>javaScript</code>）。<code>loader</code> 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>对于 <code>loader</code> 的科普和配置，在这里不做一一说明，直接奉上代码，分别是处理样式，<code>js</code> 和文件的 <code>loader</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更方便的配置和优化 <code>babel-loader</code>，我们可以将其提取出来，在根目录下新建 <code>.babelrc</code> 文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a>CleanWebpackPlugin</h4><p>在每次构建前清理/dist 文件夹，生产最新的打包文件，这时候就用到 <code>CleanWebpackPlugin</code> 插件了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: path.join(__dirname, <span class="string">'/index.html'</span>), <span class="comment">// new一个这个插件的实例，并传入相关的参数</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 所要清理的文件夹名称</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h4><p><code>HotModuleReplacementPlugin</code>（HMR）是一个很实用的插件，可以在我们修改代码后自动刷新预览效果，在开发环境使用。</p><ol><li><p><code>devServer</code> 配置项中设置 <code>hot: true</code></p></li><li><p><code>HotModuleReplacementPlugin</code> 是 webpack 模块自带的，所以引入 webpack 后，在 <code>plugins</code> 配置项中直接使用即可。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// 热更新插件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="增加-css-前缀"><a href="#增加-css-前缀" class="headerlink" title="增加 css 前缀"></a>增加 css 前缀</h4><p>平时我们写 css 时，一些属性需要手动加上前缀，比如<code>-webkit-border-radius: 10px;</code>，在 webpack 中我们可以让他自动加上</p><ol><li>安装依赖</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="selector-tag">i</span> postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure><ol><li>在项目根目录下新建 <code>postcss.config.js</code> 文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>), <span class="comment">// 引用autoprefixer模块</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>修改样式 loader</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'less-loader'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>至此，一个 webpack 项目基本搭建而成，下面介绍 vue 的引用和项目优化。</p><h3 id="搭建-vue-SPA-模板"><a href="#搭建-vue-SPA-模板" class="headerlink" title="搭建 vue SPA 模板"></a>搭建 vue SPA 模板</h3><h4 id="vue-SPA"><a href="#vue-SPA" class="headerlink" title="vue SPA"></a>vue SPA</h4><p>1、搭建一个类似于 <code>vue-cli</code> 的脚手架，首先我们来依葫芦画瓢，在 <code>main.js</code> 写上一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、然后在 src 文件夹下新建 <code>APP.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>SPA项目<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、安装相关依赖</p><p>到这里，我们 <code>npm run dev</code> 试一下就报错了。因为我们没有安装相关依赖，下面我们下来安装一下依赖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> vue vue-loader vue-<span class="keyword">template</span>-compiler -D</span><br></pre></td></tr></table></figure><ul><li>vue: vue 的源码</li><li>vue-loader：解析.vue 文件</li><li>vue-template-compiler： 编译 vue</li></ul><p>4、在 webpack 配置 vue-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> VueLoaderPlugin()],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h4><p>1、安装依赖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> vue-router -D</span><br></pre></td></tr></table></figure><p>2、在 src 文件夹下新建 router/index</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/admin'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/admin.vue'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>3、在 main.js 引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就这样，一个类似于 <code>vue-cli</code> 的脚手架就搭建好了，你可以愉快地写 <code>.vue</code> 文件进行 SPA 开发。</p><h3 id="webpack-优化打包"><a href="#webpack-优化打包" class="headerlink" title="webpack 优化打包"></a>webpack 优化打包</h3><h4 id="分离-css"><a href="#分离-css" class="headerlink" title="分离 css"></a>分离 css</h4><p>虽然 webpack 的理念是把 css、js 全都打包到一个文件里，但要是我们想把 css 分离出来，这里我们用到 <code>mini-css-extract-plugin</code>。对比另一个插件 <code>extract-text-webpack-plugin</code>，它有以下优点:</p><ul><li>异步加载</li><li>不重复编译，性能更好</li><li>更容易使用</li><li>只针对 CSS</li></ul><p>但是<code>mini-css-extract-plugin</code> 不支持 <code>HMR</code>，所以我们只能在生产环境使用它。</p><p>1、安装依赖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> mini-css-<span class="keyword">extract</span>-<span class="keyword">plugin</span> -D</span><br></pre></td></tr></table></figure><p>2、在<code>webpack.prod.js</code> 配置 <code>loader</code> 和 <code>plugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: MiniCssExtractPlugin.loader,</span><br><span class="line">          options: &#123;</span><br><span class="line">            publicPath: <span class="string">'../'</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'css-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span>,</span><br><span class="line">        <span class="string">'less-loader'</span>,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">    filename: <span class="string">"css/[name].[contenthash:8].css"</span>,</span><br><span class="line">    chunkFilename: <span class="string">'css/[id].[contenthash:8].css'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>分离 css 需要将 <code>css loader</code> 中的 <code>style-loader</code> 替换为 <code>MiniCssExtractPlugin</code></p><h4 id="消除冗余-css"><a href="#消除冗余-css" class="headerlink" title="消除冗余 css"></a>消除冗余 css</h4><p>有时候我们 css 写得多了或者重复了，这就造成了多余的代码，我们希望在生产环境进行去除。</p><p>1、安装依赖</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i purifycss-webpack purify-css <span class="keyword">glob</span> -<span class="built_in">D</span></span><br></pre></td></tr></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> PurifyCssWebpack(&#123;</span><br><span class="line">      paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="压缩-css"><a href="#压缩-css" class="headerlink" title="压缩 css"></a>压缩 css</h4><p>我们希望减小 css 打包后的体积，可以用到 <code>optimize-css-assets-webpack-plugin</code>。<br>1、安装依赖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="keyword">optimize</span>-css-assets-webpack-<span class="keyword">plugin</span> -D</span><br></pre></td></tr></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">"optimize-css-assets-webpack-plugin"</span>) <span class="comment">// 压缩css代码</span></span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h4 id="压缩-js"><a href="#压缩-js" class="headerlink" title="压缩 js"></a>压缩 js</h4><p>Webpack4.0 默认是使用 <code>terser-webpack-plugin</code> 这个压缩插件，在此之前是使用 <code>uglifyjs-webpack-plugin</code>，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 <code>parallel</code> 参数，使用多进程压缩，加快压缩。</p><p>1、安装依赖</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> terser-webpack-<span class="keyword">plugin</span> -D</span><br></pre></td></tr></table></figure><p>2、webpack.prod.js 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">'terser-webpack-plugin'</span>) <span class="comment">// 压缩js代码</span></span><br><span class="line"></span><br><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">      parallel: <span class="number">4</span>, <span class="comment">// 开启几个进程来处理压缩，默认是 os.cpus().length - 1</span></span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 是否缓存</span></span><br><span class="line">      sourceMap: <span class="literal">false</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 压缩css</span></span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提取公共代码"><a href="#提取公共代码" class="headerlink" title="提取公共代码"></a>提取公共代码</h4><p>在用 webpack 打包的时候，对于一些不经常更新的第三方库，比如 vue 全家桶的一些东西， 我们希望能和自己的代码分离开。webpack4 使用 <code>splitChunks</code> 的方法进行配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  <span class="comment">// 分离chunks</span></span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: <span class="string">'all'</span>,</span><br><span class="line">    cacheGroups: &#123;</span><br><span class="line">      vendor: &#123;</span><br><span class="line">        name: <span class="string">"vendor"</span>,</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">10</span>,</span><br><span class="line">        chunks: <span class="string">"initial"</span> <span class="comment">// 只打包初始时依赖的第三方</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p>在项目中有些图片太大影响加载，我们用 <code>image-webpack-loader</code> 进行压缩。</p><p>1、安装依赖</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="built_in">image</span>-webpack-loader -D</span><br></pre></td></tr></table></figure><p>2、配置 loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpg|svg|gif)$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        esModule: <span class="literal">false</span>,</span><br><span class="line">        limit: <span class="number">1000</span>,  <span class="comment">// 限制只有小于1kb的图片才转为base64</span></span><br><span class="line">        outputPath: <span class="string">'images'</span>, <span class="comment">// 设置打包后图片存放的文件夹名称</span></span><br><span class="line">        name: <span class="string">'[name][hash:8].[ext]'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">        mozjpeg: &#123;</span><br><span class="line">          progressive: <span class="literal">true</span>,</span><br><span class="line">          quality: <span class="number">65</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 使用 imagemin**-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">        optipng: &#123;</span><br><span class="line">          enabled: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// // 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">        pngquant: &#123;</span><br><span class="line">          quality: [<span class="number">0.65</span>, <span class="number">0.90</span>],</span><br><span class="line">          speed: <span class="number">4</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">        gifsicle: &#123;</span><br><span class="line">          interlaced: <span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">        webp: &#123;</span><br><span class="line">          quality: <span class="number">75</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gZip-加速优化"><a href="#gZip-加速优化" class="headerlink" title="gZip 加速优化"></a>gZip 加速优化</h4><p>所有现代浏览器都支持 <code>gzip</code> 压缩，启用 <code>gzip</code> 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</p><p>gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    config.plugins.push(</span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">        <span class="comment">// gzip压缩配置</span></span><br><span class="line">        test: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">        threshold: <span class="number">10240</span>, <span class="comment">// 对超过10kb的数据进行压缩</span></span><br><span class="line">        deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除原文件</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tree-shaking（求助，生产环境打包生成不了样式）"><a href="#tree-shaking（求助，生产环境打包生成不了样式）" class="headerlink" title="tree-shaking（求助，生产环境打包生成不了样式）"></a>tree-shaking（求助，生产环境打包生成不了样式）</h3><p>按以上的方式构建项目，在开发环境一直都是顺顺利利的，然而一执行 <code>npm run build</code>，打开页面，发现样式全都缺失了。打开 <code>dist/css</code> 文件夹，发现三个 css 文件，只有 <code>index.css</code> 有部分文件（是 main.js 引入额初始化样式，但也是不全的），另外两个 css 文件则是空空如也，也就是.vue 里面的样式全都缺失了。</p><p>查看资源，初步判断为 webpack4 默认使用 <code>tree-shaking</code>，会把 <strong>在模块的层面上做到打包后的代码只包含被引用并被执行的模块，而不被引用或不被执行的模块被删除掉，以起到减包的效果</strong>。但是我已经按相关资源在 <code>package.json</code> 配置了 <code>sideEffects</code> 了，但是还是没用，实在苦恼！！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"*.less"</span>,</span><br><span class="line">    <span class="string">"*.css"</span>,</span><br><span class="line">    <span class="string">"*.vue"</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;想必大多数人在开发 vue 等 SPA 
      
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>从零构建一个wbpack项目</title>
    <link href="https://chongdee.github.io/2021/07/20/webpack/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAwbpack%E9%A1%B9%E7%9B%AE/"/>
    <id>https://chongdee.github.io/2021/07/20/webpack/从零构建一个wbpack项目/</id>
    <published>2021-07-20T07:46:45.687Z</published>
    <updated>2021-07-20T07:47:33.595Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="从零构建一个wbpack项目"><a href="#从零构建一个wbpack项目" class="headerlink" title="从零构建一个wbpack项目"></a>从零构建一个wbpack项目</h1><h3 id="1、新建项目"><a href="#1、新建项目" class="headerlink" title="1、新建项目"></a>1、新建项目</h3><p>新建一个空文件夹，用于创建项目，使用 npm init 命令创建一个 package.json 文件。<br>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，也可以使用 npm init -y 这个命令来一次生成 package.json 文件，这样终端不会询问你问题。</p><h3 id="2、安装-webpack"><a href="#2、安装-webpack" class="headerlink" title="2、安装 webpack"></a>2、安装 webpack</h3><p>安装 webapck 时把 webpack-cli 也装上是因为在 webpack4.x 版本后 webpack 模块把一些功能分到了 webpack-cli 模块，所以两者都需要安装，安装方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --global    <span class="comment">//这是安装全局webpack及webpack-cli模块</span></span><br><span class="line">npm install webpack webpack-cli --save-dev  <span class="comment">//这是安装本地项目模块</span></span><br></pre></td></tr></table></figure><h3 id="3、新建文件"><a href="#3、新建文件" class="headerlink" title="3、新建文件"></a>3、新建文件</h3><p>在根目录件夹中新建两个文件夹，分别为 src 文件夹和 dist 文件夹，接下来再创建三个文件:此时，项目结构如下</p><ul><li>index.html –放在 dist 文件夹中；</li><li>hello.js –放在 src 文件夹中；</li><li>index.js –放在 src 文件夹中；</li></ul><h4 id="3-1、-index-html-中写下-html-代码，它的作用是为了引入我们打包后的-js-文件："><a href="#3-1、-index-html-中写下-html-代码，它的作用是为了引入我们打包后的-js-文件：" class="headerlink" title="3.1、 index.html 中写下 html 代码，它的作用是为了引入我们打包后的 js 文件："></a>3.1、 index.html 中写下 html 代码，它的作用是为了引入我们打包后的 js 文件：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Project<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这是打包之后的js文件，我们暂时命名为bundle.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2、在-hello-js-中导出一个模块："><a href="#3-2、在-hello-js-中导出一个模块：" class="headerlink" title="3.2、在 hello.js 中导出一个模块："></a>3.2、在 hello.js 中导出一个模块：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  hello.innerHTML = <span class="string">'welcome to China!'</span></span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3、在-index-js-中引入这个模块（hello-js）"><a href="#3-3、在-index-js-中引入这个模块（hello-js）" class="headerlink" title="3.3、在 index.js 中引入这个模块（hello.js）:"></a>3.3、在 index.js 中引入这个模块（hello.js）:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">'./hello.js'</span>)</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>).appendChild(hello())</span><br></pre></td></tr></table></figure><p>上述操作就相当于我们把 hello.js 模块合并到了 index.js 模块，之后我们打包时就只需把 index.js 模块打包成 bundle.js 即可。</p><h4 id="3-4、进行最简单的-webpack-打包"><a href="#3-4、进行最简单的-webpack-打包" class="headerlink" title="3.4、进行最简单的 webpack 打包"></a>3.4、进行最简单的 webpack 打包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在终端中使用如下命令进行打包：</span></span><br><span class="line">webpack src/index.js --output dist/bundle.js</span><br></pre></td></tr></table></figure><p>上述就相当于把 src 文件夹下的 index.js 文件打包到 dist 文件下的 bundle.js，这时就生成了 bundle.js 供 index.html 文件引用。现在打开 index.html 就可以看到我们的页面了。</p><h3 id="4、配置-webpack-config-js"><a href="#4、配置-webpack-config-js" class="headerlink" title="4、配置 webpack.config.js"></a>4、配置 webpack.config.js</h3><p>上述打包方式太 low 了，我们可以在当前项目的根目录下新建一个配置文件 webpack.config.js 用来配置打包方式。<br>webpack.config.js 配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>) <span class="comment">// 处理绝对路径</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个配置文件，我们只需在终端中运行 webpack 命令就可进行打包，这条命令会自动引用 webpack.config.js 文件中的配置选项。</p><h3 id="5、构建本地服务器"><a href="#5、构建本地服务器" class="headerlink" title="5、构建本地服务器"></a>5、构建本地服务器</h3><p>现在我们是通过打开本地文件来查看页面的，感觉还是有点 low。例如 vue, react 等脚手架都是在本地服务器运行的。所以我们再做进一步优化。</p><h4 id="5-1-webpack-dev-server-配置本地服务器"><a href="#5-1-webpack-dev-server-配置本地服务器" class="headerlink" title="5.1 webpack-dev-server 配置本地服务器"></a>5.1 webpack-dev-server 配置本地服务器</h4><p>Webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的组件，在 webpack 中进行配置之前需要单独安装它作为项目依赖：npm i webpack-dev-server -D</p><p>以下是devServer 的一些配置选项:</p><ul><li>contentBase ：设置服务器所读取文件的目录，当前我们设置为”./dist”</li><li>port ：设置端口号，如果省略，默认为 8080</li><li>inline ：设置为 true，当源文件改变时会自动刷新页面</li><li>historyApiFallback ：设置为 true，所有的跳转将指向 index.html</li></ul><p>现在我们把这些配置加到 webpack.config.js 文件上，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8088'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span> <span class="comment">//不跳转</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2、package-json-文件中添加启动和打包命令"><a href="#5-2、package-json-文件中添加启动和打包命令" class="headerlink" title="5.2、package.json 文件中添加启动和打包命令"></a>5.2、package.json 文件中添加启动和打包命令</h4><p>package.json 文件修改如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"webpack-project"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^4.23.1"</span>,</span><br><span class="line">    <span class="string">"webpack-cli"</span>: <span class="string">"^3.1.2"</span>,</span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^3.1.10"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以用以下命令进行本地运行或者打包文件了</p><ul><li>npm run dev 启动本地服务器，webpack-dev-server 就是启动服务器的命令，–open 是用于启动完服务器后自动打开浏览器。</li><li>npm run build 执行打包命令</li></ul><p>此时，我们只要输入 npm run dev 就可以在<a href="http://localhost:8088/中查看页面了。" target="_blank" rel="noopener">http://localhost:8088/中查看页面了。</a></p><h3 id="6、配置常用-loader"><a href="#6、配置常用-loader" class="headerlink" title="6、配置常用 loader"></a>6、配置常用 loader</h3><p>loader 可以让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>Loaders 的配置包括以下几方面：</p><ul><li>test：一个用以匹配 loaders 所处理文件的拓展名的正则表达式（必须）</li><li>loader：loader 的名称（必须）</li><li>include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li><li>options：为 loaders 提供额外的设置选项（可选）</li></ul><h4 id="配置-css-loader-和-sass-loader"><a href="#配置-css-loader-和-sass-loader" class="headerlink" title="配置 css-loader 和 sass-loader"></a>配置 css-loader 和 sass-loader</h4><p>如果我们要加载一个 css 文件，需要安装配置 style-loader 和 css-loader。<br>如果我们要使用 sass，就要配置 sass-loader 和 node-sass。</p><ul><li>css-loader：加载.css 文件</li><li>style-loader：使用 style 标签将 css-loader 内部样式注入到我们的 HTML 页面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8088'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span> <span class="comment">//不跳转</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(scss|sass)$/</span>, <span class="comment">// 正则匹配以.scss和.sass结尾的文件</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-Babel-loader"><a href="#配置-Babel-loader" class="headerlink" title="配置 Babel-loader"></a>配置 Babel-loader</h4><p>Babel 其实是一个编译 JavaScript 的平台，它可以编译代码帮你达到以下目的：</p><ul><li>让你能使用最新的 JavaScript 代码（ES6，ES7…）；</li><li>让你能使用基于 JavaScript 进行了拓展的语言，比如 React 的 JSX；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  ...</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h4><p>处理图片资源时，我们常用的两种 loader 是 file-loader 或者 url-loader。<br>当使用 url-loader 加载图片，图片小于上限值，则将图片转 base64 字符串，否则使用 file-loader 加载图片。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  ...</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、配置常用插件"><a href="#7、配置常用插件" class="headerlink" title="7、配置常用插件"></a>7、配置常用插件</h3><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p><h4 id="7-1、自动生成-html-文件-HtmlWebpackPlugin"><a href="#7-1、自动生成-html-文件-HtmlWebpackPlugin" class="headerlink" title="7.1、自动生成 html 文件(HtmlWebpackPlugin)"></a>7.1、自动生成 html 文件(HtmlWebpackPlugin)</h4><p>现在我们都是使用一开始建好的 index.html 文件，然后手动引入 bundle.js，如果以后我们引入不止一个 js 文件，那就得更改 index.html 中的 js 文件名，所以能不能自动生成 index.html 且自动引用打包后的 js 呢？<br>HtmlWebpackPlugin 插件就是用来解决这个问题的：</p><ol><li>安装插件 npm i html-webpack-plugin -D</li><li>把 dist 文件夹清空</li><li>在根目录新建 index.html,内容和原来的 html 一致，只是不引入 js 文件。</li><li>webpack.config.js 中我们引入了 HtmlWebpackPlugin 插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>此时我们使用 npm run build 进行打包，你会发现，dist 文件夹和 html 文件都会自动生成。</p><h4 id="7-2、清理-dist-文件夹-CleanWebpackPlugin"><a href="#7-2、清理-dist-文件夹-CleanWebpackPlugin" class="headerlink" title="7.2、清理/dist 文件夹(CleanWebpackPlugin)"></a>7.2、清理/dist 文件夹(CleanWebpackPlugin)</h4><p>在每次构建前清理/dist 文件夹，生产最新的打包文件，这时候就用到 CleanWebpackPlugin 插件了。</p><ol><li>安装 npm i clean-webpack-plugin -D</li><li>配置 webpack.config.js</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="7-3、热更新-HotModuleReplacementPlugin"><a href="#7-3、热更新-HotModuleReplacementPlugin" class="headerlink" title="7.3、热更新(HotModuleReplacementPlugin)"></a>7.3、热更新(HotModuleReplacementPlugin)</h4><p>我们要在修改代码后自动更新页面，这就需要 HotModuleReplacementPlugin（HMR）插件</p><ol><li>devServer 配置项中添加 hot: true 参数。</li><li>因为 HotModuleReplacementPlugin 是 webpack 模块自带的，所以引入 webpack 后，在 plugins 配置项中直接使用即可。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>])</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="7-4、增加-css-前缀"><a href="#7-4、增加-css-前缀" class="headerlink" title="7.4、增加 css 前缀"></a>7.4、增加 css 前缀</h4><p>平时我们写 css 时，一些属性需要手动加上前缀，比如-webkit-border-radius: 10px;，在 webpack 中我们可以让他自动加上</p><ol><li>安装 npm i postcss-loader autoprefixer -D</li><li>在项目根目录下新建 postcss.config.js 文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>) <span class="comment">// 引用autoprefixer模块</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;, <span class="comment">// 这里采用的是对象配置loader的写法</span></span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'postcss-loader'</span> &#125; <span class="comment">// 使用postcss-loader</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">       ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5、css-分离-ExtractTextPlugin"><a href="#7-5、css-分离-ExtractTextPlugin" class="headerlink" title="7.5、css 分离 ExtractTextPlugin"></a>7.5、css 分离 ExtractTextPlugin</h4><p>将 css 成生文件，而非内联。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象。</p><ol><li>安装 npm i extract-text-webpack-plugin@next -D</li><li>在 webpack.common.js 文件中引入并使用该插件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>) <span class="comment">//引入分离插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          <span class="comment">// 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理</span></span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>) <span class="comment">// 将css分离到/dist文件夹下的css文件夹中的index.css</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行 npm run build 后会发现/dist 文件夹内多出了/css 文件夹及 index.css 文件。</p><h4 id="7-6、消除冗余-css"><a href="#7-6、消除冗余-css" class="headerlink" title="7.6、消除冗余 css"></a>7.6、消除冗余 css</h4><p>有时候我们 css 写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，以下方法可以优化</p><ol><li>安装 npm i purifycss-webpack purify-css glob -D</li><li>引入 clean-webpack-plugin 及 glob 插件并使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> PurifyCssWebpack(&#123;</span><br><span class="line">    paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)) <span class="comment">// 同步扫描所有html文件中所引用的css</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。"><a href="#至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。" class="headerlink" title="至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。"></a>至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;从零构建一个wbpack项目&quot;&gt;&lt;a href=&quot;#从零构建一个wbpack项目&quot; class=&quot;headerlink&quot; title=&quot;从零构建一个wbpack项目
      
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>从零构建一个wbpack项目</title>
    <link href="https://chongdee.github.io/2021/07/20/Webpack/%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAwbpack%E9%A1%B9%E7%9B%AE/"/>
    <id>https://chongdee.github.io/2021/07/20/Webpack/从零构建一个wbpack项目/</id>
    <published>2021-07-20T07:46:45.687Z</published>
    <updated>2021-07-20T07:47:33.595Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="从零构建一个wbpack项目"><a href="#从零构建一个wbpack项目" class="headerlink" title="从零构建一个wbpack项目"></a>从零构建一个wbpack项目</h1><h3 id="1、新建项目"><a href="#1、新建项目" class="headerlink" title="1、新建项目"></a>1、新建项目</h3><p>新建一个空文件夹，用于创建项目，使用 npm init 命令创建一个 package.json 文件。<br>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，也可以使用 npm init -y 这个命令来一次生成 package.json 文件，这样终端不会询问你问题。</p><h3 id="2、安装-webpack"><a href="#2、安装-webpack" class="headerlink" title="2、安装 webpack"></a>2、安装 webpack</h3><p>安装 webapck 时把 webpack-cli 也装上是因为在 webpack4.x 版本后 webpack 模块把一些功能分到了 webpack-cli 模块，所以两者都需要安装，安装方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --global    <span class="comment">//这是安装全局webpack及webpack-cli模块</span></span><br><span class="line">npm install webpack webpack-cli --save-dev  <span class="comment">//这是安装本地项目模块</span></span><br></pre></td></tr></table></figure><h3 id="3、新建文件"><a href="#3、新建文件" class="headerlink" title="3、新建文件"></a>3、新建文件</h3><p>在根目录件夹中新建两个文件夹，分别为 src 文件夹和 dist 文件夹，接下来再创建三个文件:此时，项目结构如下</p><ul><li>index.html –放在 dist 文件夹中；</li><li>hello.js –放在 src 文件夹中；</li><li>index.js –放在 src 文件夹中；</li></ul><h4 id="3-1、-index-html-中写下-html-代码，它的作用是为了引入我们打包后的-js-文件："><a href="#3-1、-index-html-中写下-html-代码，它的作用是为了引入我们打包后的-js-文件：" class="headerlink" title="3.1、 index.html 中写下 html 代码，它的作用是为了引入我们打包后的 js 文件："></a>3.1、 index.html 中写下 html 代码，它的作用是为了引入我们打包后的 js 文件：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack Project<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这是打包之后的js文件，我们暂时命名为bundle.js--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2、在-hello-js-中导出一个模块："><a href="#3-2、在-hello-js-中导出一个模块：" class="headerlink" title="3.2、在 hello.js 中导出一个模块："></a>3.2、在 hello.js 中导出一个模块：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hello = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  hello.innerHTML = <span class="string">'welcome to China!'</span></span><br><span class="line">  <span class="keyword">return</span> hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3、在-index-js-中引入这个模块（hello-js）"><a href="#3-3、在-index-js-中引入这个模块（hello-js）" class="headerlink" title="3.3、在 index.js 中引入这个模块（hello.js）:"></a>3.3、在 index.js 中引入这个模块（hello.js）:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">'./hello.js'</span>)</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#root'</span>).appendChild(hello())</span><br></pre></td></tr></table></figure><p>上述操作就相当于我们把 hello.js 模块合并到了 index.js 模块，之后我们打包时就只需把 index.js 模块打包成 bundle.js 即可。</p><h4 id="3-4、进行最简单的-webpack-打包"><a href="#3-4、进行最简单的-webpack-打包" class="headerlink" title="3.4、进行最简单的 webpack 打包"></a>3.4、进行最简单的 webpack 打包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在终端中使用如下命令进行打包：</span></span><br><span class="line">webpack src/index.js --output dist/bundle.js</span><br></pre></td></tr></table></figure><p>上述就相当于把 src 文件夹下的 index.js 文件打包到 dist 文件下的 bundle.js，这时就生成了 bundle.js 供 index.html 文件引用。现在打开 index.html 就可以看到我们的页面了。</p><h3 id="4、配置-webpack-config-js"><a href="#4、配置-webpack-config-js" class="headerlink" title="4、配置 webpack.config.js"></a>4、配置 webpack.config.js</h3><p>上述打包方式太 low 了，我们可以在当前项目的根目录下新建一个配置文件 webpack.config.js 用来配置打包方式。<br>webpack.config.js 配置如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>) <span class="comment">// 处理绝对路径</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个配置文件，我们只需在终端中运行 webpack 命令就可进行打包，这条命令会自动引用 webpack.config.js 文件中的配置选项。</p><h3 id="5、构建本地服务器"><a href="#5、构建本地服务器" class="headerlink" title="5、构建本地服务器"></a>5、构建本地服务器</h3><p>现在我们是通过打开本地文件来查看页面的，感觉还是有点 low。例如 vue, react 等脚手架都是在本地服务器运行的。所以我们再做进一步优化。</p><h4 id="5-1-webpack-dev-server-配置本地服务器"><a href="#5-1-webpack-dev-server-配置本地服务器" class="headerlink" title="5.1 webpack-dev-server 配置本地服务器"></a>5.1 webpack-dev-server 配置本地服务器</h4><p>Webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 构建，它是一个单独的组件，在 webpack 中进行配置之前需要单独安装它作为项目依赖：npm i webpack-dev-server -D</p><p>以下是devServer 的一些配置选项:</p><ul><li>contentBase ：设置服务器所读取文件的目录，当前我们设置为”./dist”</li><li>port ：设置端口号，如果省略，默认为 8080</li><li>inline ：设置为 true，当源文件改变时会自动刷新页面</li><li>historyApiFallback ：设置为 true，所有的跳转将指向 index.html</li></ul><p>现在我们把这些配置加到 webpack.config.js 文件上，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8088'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span> <span class="comment">//不跳转</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2、package-json-文件中添加启动和打包命令"><a href="#5-2、package-json-文件中添加启动和打包命令" class="headerlink" title="5.2、package.json 文件中添加启动和打包命令"></a>5.2、package.json 文件中添加启动和打包命令</h4><p>package.json 文件修改如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"webpack-project"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"keywords"</span>: [],</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^4.23.1"</span>,</span><br><span class="line">    <span class="string">"webpack-cli"</span>: <span class="string">"^3.1.2"</span>,</span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^3.1.10"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以用以下命令进行本地运行或者打包文件了</p><ul><li>npm run dev 启动本地服务器，webpack-dev-server 就是启动服务器的命令，–open 是用于启动完服务器后自动打开浏览器。</li><li>npm run build 执行打包命令</li></ul><p>此时，我们只要输入 npm run dev 就可以在<a href="http://localhost:8088/中查看页面了。" target="_blank" rel="noopener">http://localhost:8088/中查看页面了。</a></p><h3 id="6、配置常用-loader"><a href="#6、配置常用-loader" class="headerlink" title="6、配置常用 loader"></a>6、配置常用 loader</h3><p>loader 可以让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。</p><p>Loaders 的配置包括以下几方面：</p><ul><li>test：一个用以匹配 loaders 所处理文件的拓展名的正则表达式（必须）</li><li>loader：loader 的名称（必须）</li><li>include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li><li>options：为 loaders 提供额外的设置选项（可选）</li></ul><h4 id="配置-css-loader-和-sass-loader"><a href="#配置-css-loader-和-sass-loader" class="headerlink" title="配置 css-loader 和 sass-loader"></a>配置 css-loader 和 sass-loader</h4><p>如果我们要加载一个 css 文件，需要安装配置 style-loader 和 css-loader。<br>如果我们要使用 sass，就要配置 sass-loader 和 node-sass。</p><ul><li>css-loader：加载.css 文件</li><li>style-loader：使用 style 标签将 css-loader 内部样式注入到我们的 HTML 页面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, <span class="string">'/src/index.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'/dist'</span>), <span class="comment">//打包后的文件存放的地方</span></span><br><span class="line">    filename: <span class="string">'bundle.js'</span> <span class="comment">//打包后输出文件的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>, <span class="comment">// 本地服务器所加载文件的目录</span></span><br><span class="line">    port: <span class="string">'8088'</span>, <span class="comment">// 设置端口号为8088</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 文件修改后实时刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span> <span class="comment">//不跳转</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(scss|sass)$/</span>, <span class="comment">// 正则匹配以.scss和.sass结尾的文件</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-Babel-loader"><a href="#配置-Babel-loader" class="headerlink" title="配置 Babel-loader"></a>配置 Babel-loader</h4><p>Babel 其实是一个编译 JavaScript 的平台，它可以编译代码帮你达到以下目的：</p><ul><li>让你能使用最新的 JavaScript 代码（ES6，ES7…）；</li><li>让你能使用基于 JavaScript 进行了拓展的语言，比如 React 的 JSX；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  ...</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h4><p>处理图片资源时，我们常用的两种 loader 是 file-loader 或者 url-loader。<br>当使用 url-loader 加载图片，图片小于上限值，则将图片转 base64 字符串，否则使用 file-loader 加载图片。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  ...</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">10000</span>,</span><br><span class="line">        name: utils.assetsPath(<span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、配置常用插件"><a href="#7、配置常用插件" class="headerlink" title="7、配置常用插件"></a>7、配置常用插件</h3><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。</p><h4 id="7-1、自动生成-html-文件-HtmlWebpackPlugin"><a href="#7-1、自动生成-html-文件-HtmlWebpackPlugin" class="headerlink" title="7.1、自动生成 html 文件(HtmlWebpackPlugin)"></a>7.1、自动生成 html 文件(HtmlWebpackPlugin)</h4><p>现在我们都是使用一开始建好的 index.html 文件，然后手动引入 bundle.js，如果以后我们引入不止一个 js 文件，那就得更改 index.html 中的 js 文件名，所以能不能自动生成 index.html 且自动引用打包后的 js 呢？<br>HtmlWebpackPlugin 插件就是用来解决这个问题的：</p><ol><li>安装插件 npm i html-webpack-plugin -D</li><li>把 dist 文件夹清空</li><li>在根目录新建 index.html,内容和原来的 html 一致，只是不引入 js 文件。</li><li>webpack.config.js 中我们引入了 HtmlWebpackPlugin 插件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>此时我们使用 npm run build 进行打包，你会发现，dist 文件夹和 html 文件都会自动生成。</p><h4 id="7-2、清理-dist-文件夹-CleanWebpackPlugin"><a href="#7-2、清理-dist-文件夹-CleanWebpackPlugin" class="headerlink" title="7.2、清理/dist 文件夹(CleanWebpackPlugin)"></a>7.2、清理/dist 文件夹(CleanWebpackPlugin)</h4><p>在每次构建前清理/dist 文件夹，生产最新的打包文件，这时候就用到 CleanWebpackPlugin 插件了。</p><ol><li>安装 npm i clean-webpack-plugin -D</li><li>配置 webpack.config.js</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="7-3、热更新-HotModuleReplacementPlugin"><a href="#7-3、热更新-HotModuleReplacementPlugin" class="headerlink" title="7.3、热更新(HotModuleReplacementPlugin)"></a>7.3、热更新(HotModuleReplacementPlugin)</h4><p>我们要在修改代码后自动更新页面，这就需要 HotModuleReplacementPlugin（HMR）插件</p><ol><li>devServer 配置项中添加 hot: true 参数。</li><li>因为 HotModuleReplacementPlugin 是 webpack 模块自带的，所以引入 webpack 后，在 plugins 配置项中直接使用即可。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'index.html'</span>,</span><br><span class="line">    template: <span class="string">'index.html'</span>,</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    minify: &#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>])</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="7-4、增加-css-前缀"><a href="#7-4、增加-css-前缀" class="headerlink" title="7.4、增加 css 前缀"></a>7.4、增加 css 前缀</h4><p>平时我们写 css 时，一些属性需要手动加上前缀，比如-webkit-border-radius: 10px;，在 webpack 中我们可以让他自动加上</p><ol><li>安装 npm i postcss-loader autoprefixer -D</li><li>在项目根目录下新建 postcss.config.js 文件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>) <span class="comment">// 引用autoprefixer模块</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;, <span class="comment">// 这里采用的是对象配置loader的写法</span></span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">'postcss-loader'</span> &#125; <span class="comment">// 使用postcss-loader</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">       ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5、css-分离-ExtractTextPlugin"><a href="#7-5、css-分离-ExtractTextPlugin" class="headerlink" title="7.5、css 分离 ExtractTextPlugin"></a>7.5、css 分离 ExtractTextPlugin</h4><p>将 css 成生文件，而非内联。该插件的主要是为了抽离 css 样式,防止将样式打包在 js 中引起页面样式加载错乱的现象。</p><ol><li>安装 npm i extract-text-webpack-plugin@next -D</li><li>在 webpack.common.js 文件中引入并使用该插件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>) <span class="comment">//引入分离插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则匹配以.css结尾的文件</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          <span class="comment">// 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理</span></span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [<span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>) <span class="comment">// 将css分离到/dist文件夹下的css文件夹中的index.css</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行 npm run build 后会发现/dist 文件夹内多出了/css 文件夹及 index.css 文件。</p><h4 id="7-6、消除冗余-css"><a href="#7-6、消除冗余-css" class="headerlink" title="7.6、消除冗余 css"></a>7.6、消除冗余 css</h4><p>有时候我们 css 写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，以下方法可以优化</p><ol><li>安装 npm i purifycss-webpack purify-css glob -D</li><li>引入 clean-webpack-plugin 及 glob 插件并使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PurifyCssWebpack = <span class="built_in">require</span>(<span class="string">'purifycss-webpack'</span>) <span class="comment">// 引入PurifyCssWebpack插件</span></span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>) <span class="comment">// 引入glob模块,用于扫描全部html文件中所引用的css</span></span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> PurifyCssWebpack(&#123;</span><br><span class="line">    paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)) <span class="comment">// 同步扫描所有html文件中所引用的css</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。"><a href="#至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。" class="headerlink" title="至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。"></a>至此，一些常用的配置以及弄好了，现在就开始愉快地写代码了。</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;从零构建一个wbpack项目&quot;&gt;&lt;a href=&quot;#从零构建一个wbpack项目&quot; class=&quot;headerlink&quot; title=&quot;从零构建一个wbpack项目
      
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack中最易混淆的5个知识点</title>
    <link href="https://chongdee.github.io/2021/07/20/webpack/webpack%20%E4%B8%AD%E6%9C%80%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%205%20%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://chongdee.github.io/2021/07/20/webpack/webpack 中最易混淆的 5 个知识点/</id>
    <published>2021-07-20T07:39:47.785Z</published>
    <updated>2021-07-20T07:41:46.062Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="1-webpack-中，module，chunk-和-bundle-的区别是什么？"><a href="#1-webpack-中，module，chunk-和-bundle-的区别是什么？" class="headerlink" title="1.webpack 中，module，chunk 和 bundle 的区别是什么？"></a>1.webpack 中，module，chunk 和 bundle 的区别是什么？</h2><p>说实话我刚开始看 webpack 文档的时候，对这 3 个名词云里雾里的，感觉他们都在说打包文件，但是一会儿 chunk 一会儿 bundle 的，逐渐就迷失在细节里了，所以我们要跳出来，从宏观的角度来看这几个名词。</p><p>webpack 官网对 chunk 和 bundle 做出了解释[3]，说实话太抽象了，我这里举个例子，给大家形象化的解释一下。</p><p>首先我们在 src 目录下写我们的业务代码，引入 index.js、utils.js、common.js 和 index.css 这 4 个文件，目录结构如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── <span class="keyword">index</span>.css</span><br><span class="line">├── <span class="keyword">index</span>.html <span class="meta"># 这个是 HTML 模板代码</span></span><br><span class="line">├── <span class="keyword">index</span>.js</span><br><span class="line">├── <span class="keyword">common</span>.js</span><br><span class="line">└── utils.js</span><br></pre></td></tr></table></figure><p>index.css 写一点儿简单的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils.js 文件写个求平方的工具函数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">function</span> <span class="title">square</span>(x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">x</span> * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>common.js 文件写个 log 工具函数：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  log: <span class="function"><span class="params">(msg)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello '</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js 文件做一些简单的修改，引入 css 文件和 common.js：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line">const &#123; <span class="keyword">log</span> &#125; = <span class="keyword">require</span>(<span class="string">'./common'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">log</span>(<span class="string">'webpack'</span>);</span><br></pre></td></tr></table></figure><p>webpack 的配置如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span>,</span><br><span class="line">        utils: <span class="string">'../src/utils.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].bundle.js"</span>, <span class="comment">// 输出 index.js 和 utils.js</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader, <span class="comment">// 创建一个 link 标签</span></span><br><span class="line">                    <span class="string">'css-loader'</span>, <span class="comment">// css-loader 负责解析 CSS 代码, 处理 CSS 中的依赖</span></span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 用 MiniCssExtractPlugin 抽离出 css 文件，以 link 标签的形式引入样式文件</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'index.bundle.css'</span> <span class="comment">// 输出的 css 文件名为 index.css</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下 webpack，看一下打包的结果：</p><p>我们可以看出，index.css 和 common.js 在 index.js 中被引入，打包生成的 index.bundle.css 和 index.bundle.js 都属于 chunk 0，utils.js 因为是独立打包的，它生成的 utils.bundle.js 属于 chunk 1。<br>感觉还有些绕？我做了一张图，你肯定一看就懂：</p><p>看这个图就很明白了：</p><ol><li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module ；</li><li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作；</li><li>webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。</li></ol><p>一般来说一个 chunk 对应一个 bundle，比如上图中的 utils.js -&gt; chunks 1 -&gt; utils.bundle.js；但也有例外，比如说上图中，我就用 MiniCssExtractPlugin 从 chunks 0 中抽离出了 index.bundle.css 文件。</p><h3 id="一句话总结："><a href="#一句话总结：" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p>module，chunk 和 bundle 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：</p><p>我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。</p><h2 id="2-filename-和-chunkFilename-的区别"><a href="#2-filename-和-chunkFilename-的区别" class="headerlink" title="2.filename 和 chunkFilename 的区别"></a>2.filename 和 chunkFilename 的区别</h2><h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><p>filename 是一个很常见的配置，就是对应于 entry 里面的输入文件，经过webpack 打包后输出文件的文件名。比如说经过下面的配置，生成出来的文件名为 index.min.js。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">entry</span>: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">"[name].min.js"</span>, // index.min.js</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h3><p>chunkFilename 指未被列在 entry 中，却又需要被打包出来的 chunk 文件的名称。一般来说，这个 chunk 文件指的就是要懒加载的代码。</p><p>比如说我们业务代码中写了一份懒加载 lodash 的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 button</span></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span><br><span class="line">btn.innerHTML = <span class="string">"click me"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(btn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载代码</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAsyncComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">default</span>: _ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Hello!'</span>, <span class="string">'dynamic'</span>, <span class="string">'imports'</span>, <span class="string">'async'</span>], <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击 button 时，懒加载 lodash，在网页上显示 Hello! dynamic imports async</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    getAsyncComponent().then(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(component);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们的 webpack 不做任何配置，还是原来的配置代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">entry</span>: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">"[name].min.js"</span>, // index.min.js</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候的打包结果如下：</p><p>这个 1.min.js 就是异步加载的 chunk 文件。文档[4]里这么解释<br>：</p><blockquote><p>“output.chunkFilename 默认使用 [id].js 或从 output.filename 中推断出的值（[name] 会被预先替换为 [id] 或 [id].）</p></blockquote><p>文档写的太抽象，我们不如结合上面的例子来看：</p><p>output.filename 的输出文件名是 [name].min.js，[name] 根据 entry 的配置推断为 index，所以输出为 index.min.js；</p><p>由于 output.chunkFilename 没有显示指定，就会把 [name] 替换为 chunk 文件的 id 号，这里文件的 id 号是 1，所以文件名就是 1.min.js。</p><p>如果我们显式配置 chunkFilename，就会按配置的名字生成文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">entry</span>: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">"[name].min.js"</span>,  // index.min.js</span><br><span class="line">        chunkFilename: <span class="string">'bundle.js'</span>, // bundle.js</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一句话总结：-1"><a href="#一句话总结：-1" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p>filename 指列在 entry 中，打包后输出的文件的名称。</p><p>chunkFilename 指未列在 entry 中，却又需要被打包出来的文件的名称。</p><h2 id="3-webpackPrefetch、webpackPreload-和-webpackChunkName-到底是干什么的？"><a href="#3-webpackPrefetch、webpackPreload-和-webpackChunkName-到底是干什么的？" class="headerlink" title="3.webpackPrefetch、webpackPreload 和 webpackChunkName 到底是干什么的？"></a>3.webpackPrefetch、webpackPreload 和 webpackChunkName 到底是干什么的？</h2><p>这几个名词其实都是 webpack 魔法注释（magic comments）[5]里的，文档中说了 6 个配置，配置都可以组合起来用。我们说说最常用的三个配置。</p><h3 id="webpackChunkName"><a href="#webpackChunkName" class="headerlink" title="webpackChunkName"></a>webpackChunkName</h3><p>前面举了个异步加载 lodash 的例子，我们最后把 output.chunkFilename 写死成 bundle.js。在我们的业务代码中，不可能只异步加载一个文件，所以写死肯定是不行的，但是写成 [name].bundle.js 时，打包的文件又是意义不明、辨识度不高的 chunk id。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">entry</span>: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">"[name].min.js"</span>,  // index.min.js</span><br><span class="line">        chunkFilename: <span class="string">'[name].bundle.js'</span>, // <span class="number">1</span>.bundle.js，chunk id 为 <span class="number">1</span>，辨识度不高</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候 webpackChunkName 就可以派上用场了。我们可以在 import 文件时，在 import 里以注释的形式为 chunk 文件取别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAsyncComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在 import 的括号里 加注释 /* webpackChunkName: "lodash" */ ，为引入的文件取别名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">default</span>: _ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Hello!'</span>, <span class="string">'dynamic'</span>, <span class="string">'imports'</span>, <span class="string">'async'</span>], <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候打包生成的文件是这样的：</p><p>现在问题来了，lodash 是我们取的名字，按道理来说应该生成 lodash.bundle.js 啊，前面的 vendors~ 是什么玩意？<br>其实 webpack 懒加载是用内置的一个插件 SplitChunksPlugin[6] 实现的，这个插件里面有些默认配置项[7]，比如说 automaticNameDelimiter，默认的分割符就是 ~，所以最后的文件名才会出现这个符号，这块儿内容我就不引申了，感兴趣的同学可以自己研究一下。</p><h3 id="webpackPrefetch-和-webpackPreload"><a href="#webpackPrefetch-和-webpackPreload" class="headerlink" title="webpackPrefetch 和 webpackPreload"></a>webpackPrefetch 和 webpackPreload</h3><p>这两个配置一个叫预拉取（Prefetch），一个叫预加载（Preload），两者有些细微的不同，我们先说说 webpackPreload。</p><p>在上面的懒加载代码里，我们是点击按钮时，才会触发异步加载 lodash 的动作，这时候会动态的生成一个 script 标签，加载到 head 头里：</p><p>如果我们 import 的时候添加 webpackPrefetch：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">default</span>: _ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="comment">/* webpackPrefetch: true */</span> <span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就会以 <link rel="prefetch" as="script"> 的形式预拉取 lodash 代码：</p><p>这个异步加载的代码不需要手动点击 button 触发，webpack 会在父 chunk 完成加载后，闲时加载 lodash 文件。<br>webpackPreload 是预加载当前导航下可能需要资源，他和 webpackPrefetch 的主要区别是：</p><ul><li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li><li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li><li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻</li></ul><h3 id="一句话总结：-2"><a href="#一句话总结：-2" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p>webpackChunkName 是为预加载的文件取别名，webpackPrefetch 会在浏览器闲置下载文件，webpackPreload 会在父 chunk 加载时并行下载文件。</p><h2 id="4-hash、chunkhash、contenthash-有什么不同？"><a href="#4-hash、chunkhash、contenthash-有什么不同？" class="headerlink" title="4.hash、chunkhash、contenthash 有什么不同？"></a>4.hash、chunkhash、contenthash 有什么不同？</h2><p>首先来个背景介绍，哈希一般是结合 CDN 缓存来使用的。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的 HTML 引用的 URL 地址也会改变，触发 CDN 服务器从源服务器上拉取对应数据，进而更新本地缓存。</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash 计算是跟整个项目的构建相关，我们做一个简单的 demo。<br>沿用案例 1 的 demo 代码，文件目录如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── index.css</span><br><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">└── utils.js</span><br></pre></td></tr></table></figure><p>webpack 的核心配置如下（省略了一些 module 配置信息）：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span>,</span><br><span class="line">        utils: <span class="string">'../src/utils.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].[hash].js"</span>,  <span class="comment">// 改为 hash</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'index.[hash].css'</span> <span class="comment">// 改为 hash</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的文件名如下：</p><p>我们可以发现，生成文件的 hash 和项目的构建 hash 都是一模一样的。</p><h3 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h3><p>因为 hash 是项目构建的哈希值，项目中如果有些变动，hash 一定会变，比如说我改动了 utils.js 的代码，index.js 里的代码虽然没有改变，但是大家都是用的同一份 hash。hash 一变，缓存一定失效了，这样子是没办法实现 CDN 和浏览器缓存的。</p><p>chunkhash 就是解决这个问题的，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。</p><p>我们再举个例子，我们对 utils.js 里文件进行改动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 cube() 求立方函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 webpack 里的所有 hash 改为 chunkhash：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span>,</span><br><span class="line">        utils: <span class="string">'../src/utils.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].[chunkhash].js"</span>, <span class="comment">// 改为 chunkhash</span></span><br><span class="line">    &#125;,</span><br><span class="line">          </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'index.[chunkhash].css'</span> <span class="comment">// // 改为 chunkhash</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建结果如下：</p><p>我们可以看出，chunk 0 的 hash 都是一样的，chunk 1 的 hash 和上面的不一样。<br>假设我又把 utils.js 里的 cube() 函数去掉，再打包：</p><p>对比可以发现，只有 chunk 1 的 hash 发生变化，chunk 0 的 hash 还是原来的。</p><h3 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h3><p>我们更近一步，index.js 和 index.css 同为一个 chunk，如果 index.js 内容发生变化，但是 index.css 没有变化，打包后他们的 hash 都发生变化，这对 css 文件来说是一种浪费。如何解决这个问题呢？</p><p>contenthash 将根据资源内容创建出唯一 hash，也就是说文件内容不变，hash 就不变。</p><p>我们修改一下 webpack 的配置：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span>,</span><br><span class="line">        utils: '../src/utils.js',</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].[chunkhash].js"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">      </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: 'index.[contenthash].css' // 这里改为 contenthash</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对 index.js 文件做了 3  次修改（就是改了改 log 函数的输出内容，过于简单就先不写了），然后分别构建，结果截图如下：</p><p>我们可以发现，css 文件的 hash 都没有发生改变。</p><h3 id="一句话总结：-3"><a href="#一句话总结：-3" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p>hash 计算与整个项目的构建相关；</p><p>chunkhash 计算与同一 chunk 内容相关；</p><p>contenthash 计算与文件内容本身相关。</p><h2 id="5-sourse-map-中-eval、cheap、inline-和-module-各是什么意思？"><a href="#5-sourse-map-中-eval、cheap、inline-和-module-各是什么意思？" class="headerlink" title="5.sourse-map 中 eval、cheap、inline 和 module 各是什么意思？"></a>5.sourse-map 中 eval、cheap、inline 和 module 各是什么意思？</h2><p>sourse-map ，里面都有个 map 了，肯定是映射的意思。sourse-map 就是一份源码和转换后代码的映射文件。具体的原理内容较多，感兴趣的同学可以自行搜索，我这里就不多言了。</p><p>我们先从官网上看看 sourse-map 有多少种类型：</p><p>emmmm，13 种，告辞。<br>如果再仔细看一下，就发现这 13 种大部分都是 eval、cheap、inline 和 module这 4 个词排列组合的，我做了个简单的表格，比官网上直白多了：</p><table><thead><tr><th>参数</th><th>参数解释</th></tr></thead><tbody><tr><td>eval</td><td>打包后的模块都使用 eval() 执行，行映射可能不准；不产生独立的 map 文件</td></tr><tr><td>cheap</td><td>map 映射只显示行不显示列，忽略源自 loader 的 source map</td></tr><tr><td>inline</td><td>映射文件以 base64 格式编码，加在 bundle 文件最后，不产生独立的 map 文件</td></tr><tr><td>module</td><td>增加对 loader source map 和第三方模块的映射</td></tr></tbody></table><p>还不明白？可以看看 demo。<br>我们对 webpack 做一些配置，devtool 是专门配置 source-map 的。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    devtool: 'source-map',</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>index.js 文件为了简便，我们只写一行代码，为了得出报错信息，我们故意拼错：<br>console.lg(‘hello source-map !’) // log 写成 lg<br>下面我们试一试常见的几个配置：</p><h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>source-map 是最大而全的，会生成独立 map 文件：</p><p>注意下图光标的位置，source-map 会显示报错的行列信息：</p><h3 id="cheap-sourse-map"><a href="#cheap-sourse-map" class="headerlink" title="cheap-sourse-map"></a>cheap-sourse-map</h3><p>cheap，就是廉价的意思，它不会产生列映射，相应的体积会小很多，我们和 sourse-map 的打包结果比一下，只有原来的 1/4 。</p><h3 id="eval-source-map"><a href="#eval-source-map" class="headerlink" title="eval-source-map"></a>eval-source-map</h3><p>eval-source-map 会以 eval() 函数打包运行模块，不产生独立的 map 文件，会显示报错的行列信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.bundle.js 文件</span></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 省略不重要的代码</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;([<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">"console.lg('hello source-map !');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2luZGV4Mi5qcz9mNmJjIl0sIm5hbWVzIjpbImNvbnNvbGUiLCJsZyJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU8sQ0FBQ0MsRUFBUixDQUFXLG9CQUFYIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxnKCdoZWxsbyBzb3VyY2UtbWFwICEnKSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="inline-source-map"><a href="#inline-source-map" class="headerlink" title="inline-source-map"></a>inline-source-map</h3><p>映射文件以 base64 格式编码，加在 bundle 文件最后，不产生独立的 map 文件。加入 map 文件后，我们可以明显的看到包体积变大了；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.bundle.js 文件</span></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;([<span class="function"><span class="keyword">function</span>(<span class="params">e, t</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.lg(<span class="string">"hello source-map !"</span>)</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleDIuanMiXSwibmFtZXMiOlsiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// base64 太长了，我删了一部分，领会精神</span></span><br></pre></td></tr></table></figure><h2 id="常用配置："><a href="#常用配置：" class="headerlink" title="常用配置："></a>常用配置：</h2><p>上面的几个例子都是演示，结合<a href="https://webpack.docschina.org/configuration/devtool/#%E5%AF%B9%E4%BA%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83[8]" target="_blank" rel="noopener">官网推荐</a>和实际经验，常用的配置其实是这几个：</p><h4 id="1-source-map"><a href="#1-source-map" class="headerlink" title="1.source-map"></a>1.source-map</h4><p>大而全，啥都有，就因为啥都有可能会让 webpack 构建时间变长，看情况使用。</p><h4 id="2-cheap-module-eval-source-map"><a href="#2-cheap-module-eval-source-map" class="headerlink" title="2.cheap-module-eval-source-map"></a>2.cheap-module-eval-source-map</h4><p>这个一般是开发环境（dev）推荐使用，在构建速度报错提醒上做了比较好的均衡。</p><h4 id="3-cheap-module-source-map"><a href="#3-cheap-module-source-map" class="headerlink" title="3.cheap-module-source-map"></a>3.cheap-module-source-map</h4><p>一般来说，生产环境是不配 source-map 的，如果想捕捉线上的代码报错，我们可以用这个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;1-webpack-中，module，chunk-和-bundle-的区别是什么？&quot;&gt;&lt;a href=&quot;#1-webpack-中，module，chunk-和-bu
      
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack中最易混淆的5个知识点</title>
    <link href="https://chongdee.github.io/2021/07/20/Webpack/webpack%20%E4%B8%AD%E6%9C%80%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%205%20%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://chongdee.github.io/2021/07/20/Webpack/webpack 中最易混淆的 5 个知识点/</id>
    <published>2021-07-20T07:39:47.785Z</published>
    <updated>2021-07-20T07:41:46.062Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="1-webpack-中，module，chunk-和-bundle-的区别是什么？"><a href="#1-webpack-中，module，chunk-和-bundle-的区别是什么？" class="headerlink" title="1.webpack 中，module，chunk 和 bundle 的区别是什么？"></a>1.webpack 中，module，chunk 和 bundle 的区别是什么？</h2><p>说实话我刚开始看 webpack 文档的时候，对这 3 个名词云里雾里的，感觉他们都在说打包文件，但是一会儿 chunk 一会儿 bundle 的，逐渐就迷失在细节里了，所以我们要跳出来，从宏观的角度来看这几个名词。</p><p>webpack 官网对 chunk 和 bundle 做出了解释[3]，说实话太抽象了，我这里举个例子，给大家形象化的解释一下。</p><p>首先我们在 src 目录下写我们的业务代码，引入 index.js、utils.js、common.js 和 index.css 这 4 个文件，目录结构如下：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── <span class="keyword">index</span>.css</span><br><span class="line">├── <span class="keyword">index</span>.html <span class="meta"># 这个是 HTML 模板代码</span></span><br><span class="line">├── <span class="keyword">index</span>.js</span><br><span class="line">├── <span class="keyword">common</span>.js</span><br><span class="line">└── utils.js</span><br></pre></td></tr></table></figure><p>index.css 写一点儿简单的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils.js 文件写个求平方的工具函数：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">function</span> <span class="title">square</span>(x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">x</span> * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>common.js 文件写个 log 工具函数：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  log: <span class="function"><span class="params">(msg)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello '</span>, msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js 文件做一些简单的修改，引入 css 文件和 common.js：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span>;</span><br><span class="line">const &#123; <span class="keyword">log</span> &#125; = <span class="keyword">require</span>(<span class="string">'./common'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">log</span>(<span class="string">'webpack'</span>);</span><br></pre></td></tr></table></figure><p>webpack 的配置如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span>,</span><br><span class="line">        utils: <span class="string">'../src/utils.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].bundle.js"</span>, <span class="comment">// 输出 index.js 和 utils.js</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    MiniCssExtractPlugin.loader, <span class="comment">// 创建一个 link 标签</span></span><br><span class="line">                    <span class="string">'css-loader'</span>, <span class="comment">// css-loader 负责解析 CSS 代码, 处理 CSS 中的依赖</span></span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 用 MiniCssExtractPlugin 抽离出 css 文件，以 link 标签的形式引入样式文件</span></span><br><span class="line">        <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'index.bundle.css'</span> <span class="comment">// 输出的 css 文件名为 index.css</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行一下 webpack，看一下打包的结果：</p><p>我们可以看出，index.css 和 common.js 在 index.js 中被引入，打包生成的 index.bundle.css 和 index.bundle.js 都属于 chunk 0，utils.js 因为是独立打包的，它生成的 utils.bundle.js 属于 chunk 1。<br>感觉还有些绕？我做了一张图，你肯定一看就懂：</p><p>看这个图就很明白了：</p><ol><li>对于一份同逻辑的代码，当我们手写下一个一个的文件，它们无论是 ESM 还是 commonJS 或是 AMD，他们都是 module ；</li><li>当我们写的 module 源文件传到 webpack 进行打包时，webpack 会根据文件引用关系生成 chunk 文件，webpack 会对这个 chunk 文件进行一些操作；</li><li>webpack 处理好 chunk 文件后，最后会输出 bundle 文件，这个 bundle 文件包含了经过加载和编译的最终源文件，所以它可以直接在浏览器中运行。</li></ol><p>一般来说一个 chunk 对应一个 bundle，比如上图中的 utils.js -&gt; chunks 1 -&gt; utils.bundle.js；但也有例外，比如说上图中，我就用 MiniCssExtractPlugin 从 chunks 0 中抽离出了 index.bundle.css 文件。</p><h3 id="一句话总结："><a href="#一句话总结：" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p>module，chunk 和 bundle 其实就是同一份逻辑代码在不同转换场景下的取了三个名字：</p><p>我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。</p><h2 id="2-filename-和-chunkFilename-的区别"><a href="#2-filename-和-chunkFilename-的区别" class="headerlink" title="2.filename 和 chunkFilename 的区别"></a>2.filename 和 chunkFilename 的区别</h2><h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><p>filename 是一个很常见的配置，就是对应于 entry 里面的输入文件，经过webpack 打包后输出文件的文件名。比如说经过下面的配置，生成出来的文件名为 index.min.js。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">entry</span>: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">"[name].min.js"</span>, // index.min.js</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h3><p>chunkFilename 指未被列在 entry 中，却又需要被打包出来的 chunk 文件的名称。一般来说，这个 chunk 文件指的就是要懒加载的代码。</p><p>比如说我们业务代码中写了一份懒加载 lodash 的代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件：index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 button</span></span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.createElement(<span class="string">"button"</span>);</span><br><span class="line">btn.innerHTML = <span class="string">"click me"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(btn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步加载代码</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAsyncComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">default</span>: _ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Hello!'</span>, <span class="string">'dynamic'</span>, <span class="string">'imports'</span>, <span class="string">'async'</span>], <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击 button 时，懒加载 lodash，在网页上显示 Hello! dynamic imports async</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    getAsyncComponent().then(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(component);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们的 webpack 不做任何配置，还是原来的配置代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">entry</span>: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">"[name].min.js"</span>, // index.min.js</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候的打包结果如下：</p><p>这个 1.min.js 就是异步加载的 chunk 文件。文档[4]里这么解释<br>：</p><blockquote><p>“output.chunkFilename 默认使用 [id].js 或从 output.filename 中推断出的值（[name] 会被预先替换为 [id] 或 [id].）</p></blockquote><p>文档写的太抽象，我们不如结合上面的例子来看：</p><p>output.filename 的输出文件名是 [name].min.js，[name] 根据 entry 的配置推断为 index，所以输出为 index.min.js；</p><p>由于 output.chunkFilename 没有显示指定，就会把 [name] 替换为 chunk 文件的 id 号，这里文件的 id 号是 1，所以文件名就是 1.min.js。</p><p>如果我们显式配置 chunkFilename，就会按配置的名字生成文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">entry</span>: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">"[name].min.js"</span>,  // index.min.js</span><br><span class="line">        chunkFilename: <span class="string">'bundle.js'</span>, // bundle.js</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一句话总结：-1"><a href="#一句话总结：-1" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p>filename 指列在 entry 中，打包后输出的文件的名称。</p><p>chunkFilename 指未列在 entry 中，却又需要被打包出来的文件的名称。</p><h2 id="3-webpackPrefetch、webpackPreload-和-webpackChunkName-到底是干什么的？"><a href="#3-webpackPrefetch、webpackPreload-和-webpackChunkName-到底是干什么的？" class="headerlink" title="3.webpackPrefetch、webpackPreload 和 webpackChunkName 到底是干什么的？"></a>3.webpackPrefetch、webpackPreload 和 webpackChunkName 到底是干什么的？</h2><p>这几个名词其实都是 webpack 魔法注释（magic comments）[5]里的，文档中说了 6 个配置，配置都可以组合起来用。我们说说最常用的三个配置。</p><h3 id="webpackChunkName"><a href="#webpackChunkName" class="headerlink" title="webpackChunkName"></a>webpackChunkName</h3><p>前面举了个异步加载 lodash 的例子，我们最后把 output.chunkFilename 写死成 bundle.js。在我们的业务代码中，不可能只异步加载一个文件，所以写死肯定是不行的，但是写成 [name].bundle.js 时，打包的文件又是意义不明、辨识度不高的 chunk id。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">entry</span>: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">"[name].min.js"</span>,  // index.min.js</span><br><span class="line">        chunkFilename: <span class="string">'[name].bundle.js'</span>, // <span class="number">1</span>.bundle.js，chunk id 为 <span class="number">1</span>，辨识度不高</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候 webpackChunkName 就可以派上用场了。我们可以在 import 文件时，在 import 里以注释的形式为 chunk 文件取别名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getAsyncComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在 import 的括号里 加注释 /* webpackChunkName: "lodash" */ ，为引入的文件取别名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">default</span>: _ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Hello!'</span>, <span class="string">'dynamic'</span>, <span class="string">'imports'</span>, <span class="string">'async'</span>], <span class="string">' '</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候打包生成的文件是这样的：</p><p>现在问题来了，lodash 是我们取的名字，按道理来说应该生成 lodash.bundle.js 啊，前面的 vendors~ 是什么玩意？<br>其实 webpack 懒加载是用内置的一个插件 SplitChunksPlugin[6] 实现的，这个插件里面有些默认配置项[7]，比如说 automaticNameDelimiter，默认的分割符就是 ~，所以最后的文件名才会出现这个符号，这块儿内容我就不引申了，感兴趣的同学可以自己研究一下。</p><h3 id="webpackPrefetch-和-webpackPreload"><a href="#webpackPrefetch-和-webpackPreload" class="headerlink" title="webpackPrefetch 和 webpackPreload"></a>webpackPrefetch 和 webpackPreload</h3><p>这两个配置一个叫预拉取（Prefetch），一个叫预加载（Preload），两者有些细微的不同，我们先说说 webpackPreload。</p><p>在上面的懒加载代码里，我们是点击按钮时，才会触发异步加载 lodash 的动作，这时候会动态的生成一个 script 标签，加载到 head 头里：</p><p>如果我们 import 的时候添加 webpackPrefetch：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="keyword">default</span>: _ &#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="comment">/* webpackPrefetch: true */</span> <span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就会以 <link rel="prefetch" as="script"> 的形式预拉取 lodash 代码：</p><p>这个异步加载的代码不需要手动点击 button 触发，webpack 会在父 chunk 完成加载后，闲时加载 lodash 文件。<br>webpackPreload 是预加载当前导航下可能需要资源，他和 webpackPrefetch 的主要区别是：</p><ul><li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li><li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li><li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻</li></ul><h3 id="一句话总结：-2"><a href="#一句话总结：-2" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p>webpackChunkName 是为预加载的文件取别名，webpackPrefetch 会在浏览器闲置下载文件，webpackPreload 会在父 chunk 加载时并行下载文件。</p><h2 id="4-hash、chunkhash、contenthash-有什么不同？"><a href="#4-hash、chunkhash、contenthash-有什么不同？" class="headerlink" title="4.hash、chunkhash、contenthash 有什么不同？"></a>4.hash、chunkhash、contenthash 有什么不同？</h2><p>首先来个背景介绍，哈希一般是结合 CDN 缓存来使用的。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的 HTML 引用的 URL 地址也会改变，触发 CDN 服务器从源服务器上拉取对应数据，进而更新本地缓存。</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash 计算是跟整个项目的构建相关，我们做一个简单的 demo。<br>沿用案例 1 的 demo 代码，文件目录如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">├── index.css</span><br><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">└── utils.js</span><br></pre></td></tr></table></figure><p>webpack 的核心配置如下（省略了一些 module 配置信息）：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span>,</span><br><span class="line">        utils: <span class="string">'../src/utils.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].[hash].js"</span>,  <span class="comment">// 改为 hash</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'index.[hash].css'</span> <span class="comment">// 改为 hash</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的文件名如下：</p><p>我们可以发现，生成文件的 hash 和项目的构建 hash 都是一模一样的。</p><h3 id="chunkhash"><a href="#chunkhash" class="headerlink" title="chunkhash"></a>chunkhash</h3><p>因为 hash 是项目构建的哈希值，项目中如果有些变动，hash 一定会变，比如说我改动了 utils.js 的代码，index.js 里的代码虽然没有改变，但是大家都是用的同一份 hash。hash 一变，缓存一定失效了，这样子是没办法实现 CDN 和浏览器缓存的。</p><p>chunkhash 就是解决这个问题的，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。</p><p>我们再举个例子，我们对 utils.js 里文件进行改动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 cube() 求立方函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 webpack 里的所有 hash 改为 chunkhash：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span>,</span><br><span class="line">        utils: <span class="string">'../src/utils.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].[chunkhash].js"</span>, <span class="comment">// 改为 chunkhash</span></span><br><span class="line">    &#125;,</span><br><span class="line">          </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'index.[chunkhash].css'</span> <span class="comment">// // 改为 chunkhash</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建结果如下：</p><p>我们可以看出，chunk 0 的 hash 都是一样的，chunk 1 的 hash 和上面的不一样。<br>假设我又把 utils.js 里的 cube() 函数去掉，再打包：</p><p>对比可以发现，只有 chunk 1 的 hash 发生变化，chunk 0 的 hash 还是原来的。</p><h3 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h3><p>我们更近一步，index.js 和 index.css 同为一个 chunk，如果 index.js 内容发生变化，但是 index.css 没有变化，打包后他们的 hash 都发生变化，这对 css 文件来说是一种浪费。如何解决这个问题呢？</p><p>contenthash 将根据资源内容创建出唯一 hash，也就是说文件内容不变，hash 就不变。</p><p>我们修改一下 webpack 的配置：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">"../src/index.js"</span>,</span><br><span class="line">        utils: '../src/utils.js',</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"[name].[chunkhash].js"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">      </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new MiniCssExtractPlugin(&#123;</span><br><span class="line">            filename: 'index.[contenthash].css' // 这里改为 contenthash</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对 index.js 文件做了 3  次修改（就是改了改 log 函数的输出内容，过于简单就先不写了），然后分别构建，结果截图如下：</p><p>我们可以发现，css 文件的 hash 都没有发生改变。</p><h3 id="一句话总结：-3"><a href="#一句话总结：-3" class="headerlink" title="一句话总结："></a>一句话总结：</h3><p>hash 计算与整个项目的构建相关；</p><p>chunkhash 计算与同一 chunk 内容相关；</p><p>contenthash 计算与文件内容本身相关。</p><h2 id="5-sourse-map-中-eval、cheap、inline-和-module-各是什么意思？"><a href="#5-sourse-map-中-eval、cheap、inline-和-module-各是什么意思？" class="headerlink" title="5.sourse-map 中 eval、cheap、inline 和 module 各是什么意思？"></a>5.sourse-map 中 eval、cheap、inline 和 module 各是什么意思？</h2><p>sourse-map ，里面都有个 map 了，肯定是映射的意思。sourse-map 就是一份源码和转换后代码的映射文件。具体的原理内容较多，感兴趣的同学可以自行搜索，我这里就不多言了。</p><p>我们先从官网上看看 sourse-map 有多少种类型：</p><p>emmmm，13 种，告辞。<br>如果再仔细看一下，就发现这 13 种大部分都是 eval、cheap、inline 和 module这 4 个词排列组合的，我做了个简单的表格，比官网上直白多了：</p><table><thead><tr><th>参数</th><th>参数解释</th></tr></thead><tbody><tr><td>eval</td><td>打包后的模块都使用 eval() 执行，行映射可能不准；不产生独立的 map 文件</td></tr><tr><td>cheap</td><td>map 映射只显示行不显示列，忽略源自 loader 的 source map</td></tr><tr><td>inline</td><td>映射文件以 base64 格式编码，加在 bundle 文件最后，不产生独立的 map 文件</td></tr><tr><td>module</td><td>增加对 loader source map 和第三方模块的映射</td></tr></tbody></table><p>还不明白？可以看看 demo。<br>我们对 webpack 做一些配置，devtool 是专门配置 source-map 的。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    devtool: 'source-map',</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>index.js 文件为了简便，我们只写一行代码，为了得出报错信息，我们故意拼错：<br>console.lg(‘hello source-map !’) // log 写成 lg<br>下面我们试一试常见的几个配置：</p><h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>source-map 是最大而全的，会生成独立 map 文件：</p><p>注意下图光标的位置，source-map 会显示报错的行列信息：</p><h3 id="cheap-sourse-map"><a href="#cheap-sourse-map" class="headerlink" title="cheap-sourse-map"></a>cheap-sourse-map</h3><p>cheap，就是廉价的意思，它不会产生列映射，相应的体积会小很多，我们和 sourse-map 的打包结果比一下，只有原来的 1/4 。</p><h3 id="eval-source-map"><a href="#eval-source-map" class="headerlink" title="eval-source-map"></a>eval-source-map</h3><p>eval-source-map 会以 eval() 函数打包运行模块，不产生独立的 map 文件，会显示报错的行列信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.bundle.js 文件</span></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 省略不重要的代码</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;([<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">"console.lg('hello source-map !');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL2luZGV4Mi5qcz9mNmJjIl0sIm5hbWVzIjpbImNvbnNvbGUiLCJsZyJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU8sQ0FBQ0MsRUFBUixDQUFXLG9CQUFYIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxnKCdoZWxsbyBzb3VyY2UtbWFwICEnKSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="inline-source-map"><a href="#inline-source-map" class="headerlink" title="inline-source-map"></a>inline-source-map</h3><p>映射文件以 base64 格式编码，加在 bundle 文件最后，不产生独立的 map 文件。加入 map 文件后，我们可以明显的看到包体积变大了；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.bundle.js 文件</span></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;([<span class="function"><span class="keyword">function</span>(<span class="params">e, t</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.lg(<span class="string">"hello source-map !"</span>)</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line"><span class="comment">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleDIuanMiXSwibmFtZXMiOlsiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// base64 太长了，我删了一部分，领会精神</span></span><br></pre></td></tr></table></figure><h2 id="常用配置："><a href="#常用配置：" class="headerlink" title="常用配置："></a>常用配置：</h2><p>上面的几个例子都是演示，结合<a href="https://webpack.docschina.org/configuration/devtool/#%E5%AF%B9%E4%BA%8E%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83[8]" target="_blank" rel="noopener">官网推荐</a>和实际经验，常用的配置其实是这几个：</p><h4 id="1-source-map"><a href="#1-source-map" class="headerlink" title="1.source-map"></a>1.source-map</h4><p>大而全，啥都有，就因为啥都有可能会让 webpack 构建时间变长，看情况使用。</p><h4 id="2-cheap-module-eval-source-map"><a href="#2-cheap-module-eval-source-map" class="headerlink" title="2.cheap-module-eval-source-map"></a>2.cheap-module-eval-source-map</h4><p>这个一般是开发环境（dev）推荐使用，在构建速度报错提醒上做了比较好的均衡。</p><h4 id="3-cheap-module-source-map"><a href="#3-cheap-module-source-map" class="headerlink" title="3.cheap-module-source-map"></a>3.cheap-module-source-map</h4><p>一般来说，生产环境是不配 source-map 的，如果想捕捉线上的代码报错，我们可以用这个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;1-webpack-中，module，chunk-和-bundle-的区别是什么？&quot;&gt;&lt;a href=&quot;#1-webpack-中，module，chunk-和-bu
      
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>条件语句优雅写法</title>
    <link href="https://chongdee.github.io/2021/05/09/JavaScript/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95/"/>
    <id>https://chongdee.github.io/2021/05/09/JavaScript/条件语句优雅写法/</id>
    <published>2021-05-08T19:32:15.040Z</published>
    <updated>2021-05-08T19:35:17.294Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在任何编程语言中，代码需要根据不同的条件在给定的输入中做不同的决定和执行相应的动作。</p><p>例如，在一个游戏中，如果玩家生命点为0，游戏结束。在天气应用中，如果在早上被查看，显示一个日出图片，如果是晚上，则显示星星和月亮。在这篇文章中，我们将探索JavaScript中所谓的条件语句如何工作。<br><a id="more"></a><br>如果你使用JavaScript工作，你将写很多包含条件调用的代码。条件调用可能初学很简单，但是还有比写一对对if/else更多的东西。这里有些编写更好更清晰的条件代码的有用提示。</p><ol><li>数组方法 Array.includes</li><li>提前退出 / 提前返回</li><li>用对象字面量或Map替代Switch语句</li><li>默认参数和解构</li><li>用 Array.every &amp; Array.some 匹配全部/部分内容</li><li>使用可选链和空值（null）合并</li></ol><h2 id="1-数组方法-Array-includes"><a href="#1-数组方法-Array-includes" class="headerlink" title="1. 数组方法 Array.includes"></a>1. 数组方法 Array.includes</h2><p>使用 Array.includes 进行多条件选择<br>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAnimals</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animal === <span class="string">'dog'</span> || animal === <span class="string">'cat'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(I have a $&#123;animal&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printAnimals(<span class="string">'dog'</span>)); <span class="comment">// I have a dog</span></span><br></pre></td></tr></table></figure><p>上面的代码看起来很好因为我们只检查了两个动物。然而，我们不确定用户输入。如果我们要检查任何其他动物呢？如果我们通过添加更多“或”语句来扩展，代码将变得难以维护和不清晰。</p><p><strong>解决方案:</strong></p><p>我们可以通过使用 Array.includes 来重写上面的条件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAnimals</span>(<span class="params">animal</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> animals = [<span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'hamster'</span>, <span class="string">'turtle'</span>]; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (animals.includes(animal)) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(I have a $&#123;animal&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printAnimals(<span class="string">'hamster'</span>)); <span class="comment">// I have a hamster</span></span><br></pre></td></tr></table></figure><p>这里，我们创建来一个动物数组，所以条件语句可以和代码的其余部分抽象分离出来。现在，如果我们想要检查任何其他动物，我们只需要添加一个新的数组项。<br>我们也能在这个函数作用域外部使用这个动物数组变量来在代码中的其他任意地方重用它。这是一个编写更清晰、易理解和维护的代码的方法，不是吗？</p><h2 id="2-提前退出-提前返回"><a href="#2-提前退出-提前返回" class="headerlink" title="2. 提前退出 / 提前返回"></a>2. 提前退出 / 提前返回</h2><p>这是一个精简你的代码的非常酷的技巧。我记得当我开始专业工作时，我在第一天学习使用提前退出来编写条件。</p><p>让我们在之前的例子上添加更多的条件。用包含确定属性的对象替代简单字符串的动物。</p><p>现在的需求是：</p><ul><li>如果没有动物，抛出一个异常</li><li>打印动物类型</li><li>打印动物名字</li><li>打印动物性别</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printAnimalDetails = animal =&gt; &#123;</span><br><span class="line">  let result; <span class="comment">// declare a variable to store the final value</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// condition 1: check if animal has a value</span></span><br><span class="line">  <span class="keyword">if</span> (animal) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// condition 2: check if animal has a type property</span></span><br><span class="line">    <span class="keyword">if</span> (animal.<span class="keyword">type</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// condition 3: check if animal has a name property</span></span><br><span class="line">      <span class="keyword">if</span> (animal.name) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// condition 4: check if animal has a gender property</span></span><br><span class="line">        <span class="keyword">if</span> (animal.gender) &#123;</span><br><span class="line">          result = <span class="variable">$&#123;animal</span>.name&#125; is a <span class="variable">$&#123;animal</span>.gender&#125; <span class="variable">$&#123;animal</span>.<span class="keyword">type</span>&#125;;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result = <span class="string">"No animal gender"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = <span class="string">"No animal name"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = <span class="string">"No animal type"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="string">"No animal"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(printAnimalDetails()); <span class="comment">// 'No animal'</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(printAnimalDetails(&#123; <span class="keyword">type</span>: <span class="string">"dog"</span>, gender: <span class="string">"female"</span> &#125;)); <span class="comment">// 'No animal name'</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(printAnimalDetails(&#123; <span class="keyword">type</span>: <span class="string">"dog"</span>, name: <span class="string">"Lucy"</span> &#125;)); <span class="comment">// 'No animal gender'</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(</span><br><span class="line">  printAnimalDetails(&#123; <span class="keyword">type</span>: <span class="string">"dog"</span>, name: <span class="string">"Lucy"</span>, gender: <span class="string">"female"</span> &#125;)</span><br><span class="line">); <span class="comment">// 'Lucy is a female dog'</span></span><br></pre></td></tr></table></figure><p>你觉得上面的代码怎么样？</p><p>它工作得很好，但是代码很长并且维护困难。如果不使用lint工具，找出闭合花括号在哪都会浪费很多时间。😄 想象如果代码有更复杂的逻辑会怎么样？大量的if..else语句。</p><p>我们能用三元运算符、&amp;&amp;条件等语法重构上面的功能，但让我们用多个返回语句编写更清晰的代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> printAnimalDetails = <span class="function">(<span class="params">&#123;<span class="keyword">type</span>, name, gender &#125; = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">type</span>) <span class="keyword">return</span> <span class="string">'No animal type'</span>;</span><br><span class="line">  <span class="keyword">if</span>(!name) <span class="keyword">return</span> <span class="string">'No animal name'</span>;</span><br><span class="line">  <span class="keyword">if</span>(!gender) <span class="keyword">return</span> <span class="string">'No animal gender'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now in this line of code, we're sure that we have an animal with all //the three properties here.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> $&#123;name&#125; is a $&#123;gender&#125; $&#123;<span class="keyword">type</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printAnimalDetails()); <span class="comment">// 'No animal type'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printAnimalDetails(&#123; <span class="keyword">type</span>: dog &#125;)); <span class="comment">// 'No animal name'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printAnimalDetails(&#123; <span class="keyword">type</span>: dog, gender: female &#125;)); <span class="comment">// 'No animal name'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(printAnimalDetails(&#123; <span class="keyword">type</span>: dog, name: <span class="string">'Lucy'</span>, gender: <span class="string">'female'</span> &#125;)); <span class="comment">// 'Lucy is a female dog'</span></span><br></pre></td></tr></table></figure><p>在这个重构过的版本中，也包含了解构和默认参数。默认参数确保如果我们传递undefined作为一个方法的参数，我们仍然有值可以解构，在这里它是一个空对象{}。</p><p>通常，在专业领域，代码被写在这两种方法之间。</p><p>另一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printVegetablesWithQuantity</span>(<span class="params">vegetable, quantity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vegetables = [<span class="string">'potato'</span>, <span class="string">'cabbage'</span>, <span class="string">'cauliflower'</span>, <span class="string">'asparagus'</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// condition 1: vegetable should be present</span></span><br><span class="line">   <span class="keyword">if</span> (vegetable) &#123;</span><br><span class="line">     <span class="comment">// condition 2: must be one of the item from the list</span></span><br><span class="line">     <span class="keyword">if</span> (vegetables.includes(vegetable)) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(I like $&#123;vegetable&#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// condition 3: must be large quantity</span></span><br><span class="line">       <span class="keyword">if</span> (quantity &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'I have bought a large quantity'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No vegetable from the list!'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printVegetablesWithQuantity(<span class="literal">null</span>); <span class="comment">//  No vegetable from the list!</span></span><br><span class="line">printVegetablesWithQuantity(<span class="string">'cabbage'</span>); <span class="comment">// I like cabbage</span></span><br><span class="line">printVegetablesWithQuantity(<span class="string">'cabbage'</span>, <span class="number">20</span>); </span><br><span class="line"><span class="comment">// 'I like cabbage</span></span><br><span class="line"><span class="comment">// 'I have bought a large quantity'</span></span><br></pre></td></tr></table></figure><p>现在，我们有：</p><ul><li>1 if/else 语句过滤非法条件</li><li>3 级嵌套if语句 (条件 1, 2, &amp; 3)</li></ul><p>一个普遍遵循的规则是：在非法条件匹配时提前退出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printVegetablesWithQuantity</span>(<span class="params">vegetable, quantity</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> vegetables = [<span class="string">'potato'</span>, <span class="string">'cabbage'</span>, <span class="string">'cauliflower'</span>, <span class="string">'asparagus'</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// condition 1: throw error early</span></span><br><span class="line">   <span class="keyword">if</span> (!vegetable) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No vegetable from the list!'</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// condition 2: must be in the list</span></span><br><span class="line">   <span class="keyword">if</span> (vegetables.includes(vegetable)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(I like $&#123;vegetable&#125;);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// condition 3: must be a large quantity</span></span><br><span class="line">      <span class="keyword">if</span> (quantity &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I have bought a large quantity'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这么做，我们少了一个嵌套层级。当你有一个长的if语句时，这种代码风格特别好。</p><p>我们能通过条件倒置和提前返回，进一步减少嵌套的if语句。查看下面的条件2，观察我们是怎么做的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printVegetablesWithQuantity</span>(<span class="params">vegetable, quantity</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> vegetables = [<span class="string">'potato'</span>, <span class="string">'cabbage'</span>, <span class="string">'cauliflower'</span>, <span class="string">'asparagus'</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!vegetable) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No vegetable from the list!'</span>); </span><br><span class="line">   <span class="comment">// condition 1: throw error early</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!vegetables.includes(vegetable)) <span class="keyword">return</span>; </span><br><span class="line">   <span class="comment">// condition 2: return from the function is the vegetable is not in </span></span><br><span class="line">  <span class="comment">//  the list </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(I like $&#123;vegetable&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// condition 3: must be a large quantity</span></span><br><span class="line">  <span class="keyword">if</span> (quantity &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'I have bought a large quantity'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过倒置条件2，代码没有嵌套语句了。这种技术在我们有很多条件并且当任何特定条件不匹配时，我们想停止进一步处理的时候特别有用。<br>所以，总是关注更少的嵌套和提前返回，但也不要过度地使用。</p><h2 id="3-用对象字面量或Map替代Switch语句"><a href="#3-用对象字面量或Map替代Switch语句" class="headerlink" title="3. 用对象字面量或Map替代Switch语句"></a>3. 用对象字面量或Map替代Switch语句</h2><p>让我们来看看下面的例子，我们想要基于颜色打印水果：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFruits</span><span class="params">(color)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// use switch case to find fruits by color</span></span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'red'</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'yellow'</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>];</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'purple'</span>:</span><br><span class="line">      <span class="keyword">return</span> [<span class="string">'grape'</span>, <span class="string">'plum'</span>];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printFruits(<span class="literal">null</span>); <span class="comment">// []</span></span><br><span class="line">printFruits(<span class="string">'yellow'</span>); <span class="comment">// ['banana', 'pineapple']</span></span><br></pre></td></tr></table></figure><p>上面的代码没有错误，但是它仍然有些冗长。相同的功能能用对象字面量以更清晰的语法实现：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use object literal to find fruits by color</span></span><br><span class="line">  <span class="keyword">const</span> fruitColor = &#123;</span><br><span class="line">    <span class="attribute">red</span>: [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>],</span><br><span class="line">    <span class="attribute">yellow</span>: [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>],</span><br><span class="line">    <span class="attribute">purple</span>: [<span class="string">'grape'</span>, <span class="string">'plum'</span>]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFruits</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fruitColor[<span class="built_in">color</span>] || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，你也能用 Map 来实现相同的功能：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use Map to find fruits by color</span></span><br><span class="line">  const fruitColor = <span class="keyword">new</span> <span class="type">Map</span>()</span><br><span class="line">    .<span class="keyword">set</span>(<span class="string">'red'</span>, [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>])</span><br><span class="line">    .<span class="keyword">set</span>(<span class="string">'yellow'</span>, [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>])</span><br><span class="line">    .<span class="keyword">set</span>(<span class="string">'purple'</span>, [<span class="string">'grape'</span>, <span class="string">'plum'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFruits</span></span>(color) &#123;</span><br><span class="line">  <span class="keyword">return</span> fruitColor.<span class="keyword">get</span>(color) || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map 允许保存键值对，是自从ES2015以来可以使用的对象类型。<br>对于上面的例子，相同的功能也能用数组方法Array.filter 来实现。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const fruits = [</span><br><span class="line">    &#123; <span class="keyword">name</span>: <span class="string">'apple'</span>, <span class="built_in">color</span>: <span class="string">'red'</span> &#125;, </span><br><span class="line">    &#123; <span class="keyword">name</span>: <span class="string">'strawberry'</span>, <span class="built_in">color</span>: <span class="string">'red'</span> &#125;, </span><br><span class="line">    &#123; <span class="keyword">name</span>: <span class="string">'banana'</span>, <span class="built_in">color</span>: <span class="string">'yellow'</span> &#125;, </span><br><span class="line">    &#123; <span class="keyword">name</span>: <span class="string">'pineapple'</span>, <span class="built_in">color</span>: <span class="string">'yellow'</span> &#125;, </span><br><span class="line">    &#123; <span class="keyword">name</span>: <span class="string">'grape'</span>, <span class="built_in">color</span>: <span class="string">'purple'</span> &#125;, </span><br><span class="line">    &#123; <span class="keyword">name</span>: <span class="string">'plum'</span>, <span class="built_in">color</span>: <span class="string">'purple'</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function printFruits(<span class="built_in">color</span>) &#123;</span><br><span class="line">  return fruits.filter(fruit =&gt; fruit.<span class="built_in">color</span> === <span class="built_in">color</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-默认参数和解构"><a href="#4-默认参数和解构" class="headerlink" title="4. 默认参数和解构"></a>4. 默认参数和解构</h2><p>当使用 JavaScript 工作时，我们总是需要检查 null/undefined 值并赋默认值，否则可能编译失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printVegetablesWithQuantity</span>(<span class="params">vegetable, quantity = <span class="number">1</span></span>) </span>&#123; </span><br><span class="line"><span class="comment">// if quantity has no value, assign 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!vegetable) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(We have $&#123;quantity&#125; $&#123;vegetable&#125;!);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//results</span></span><br><span class="line">printVegetablesWithQuantity(<span class="string">'cabbage'</span>); <span class="comment">// We have 1 cabbage!</span></span><br><span class="line">printVegetablesWithQuantity(<span class="string">'potato'</span>, <span class="number">2</span>); <span class="comment">// We have 2 potato!</span></span><br></pre></td></tr></table></figure><p>如果 vegetable 是一个对象呢？我们能赋一个默认参数吗？</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">printVegetableName</span>(vegetable) &#123; </span><br><span class="line">    <span class="selector-tag">if</span> (vegetable &amp;&amp; vegetable.name) &#123;</span><br><span class="line">     <span class="selector-tag">console</span><span class="selector-class">.log</span> (vegetable.name);</span><br><span class="line">   &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">    <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="string">'unknown'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">printVegetableName</span>(undefined); <span class="comment">// unknown</span></span><br><span class="line"><span class="selector-tag">printVegetableName</span>(&#123;&#125;); <span class="comment">// unknown</span></span><br><span class="line"><span class="selector-tag">printVegetableName</span>(&#123; <span class="attribute">name</span>: <span class="string">'cabbage'</span>, <span class="attribute">quantity</span>: <span class="number">2</span> &#125;); <span class="comment">// cabbage</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，如果vegetable 存在，我们想要打印 vegetable name, 否则打印”unknown”。</p><p>我们能通过使用默认参数和解构来避免条件语句 if (vegetable &amp;&amp; vegetable.name) {} 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// destructing - get name property only</span></span><br><span class="line"><span class="comment">// assign default empty object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printVegetableName</span>(<span class="params">&#123;name&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log (name || <span class="string">'unknown'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printVegetableName(<span class="literal">undefined</span>); <span class="comment">// unknown</span></span><br><span class="line">printVegetableName(&#123; &#125;); <span class="comment">// unknown</span></span><br><span class="line">printVegetableName(&#123; <span class="attr">name</span>: <span class="string">'cabbage'</span>, <span class="attr">quantity</span>: <span class="number">2</span> &#125;); <span class="comment">// cabbage</span></span><br></pre></td></tr></table></figure><p>因为我们只需要 name 属性，所以我们可以使用 { name } 解构参数，然后我们就能在代码中使用 name 作为变量，而不是 vegetable.name 。</p><p>我们还赋了一个空对象 {} 作为默认值，因为当执行 printVegetableName(undefined) 时会得到一个错误：不能从 undefined 或 null 解构属性 name ，因为在 undefined 中没有 name 属性。</p><h2 id="5-用-Array-every-amp-Array-some-匹配全部-部分内容"><a href="#5-用-Array-every-amp-Array-some-匹配全部-部分内容" class="headerlink" title="5. 用 Array.every &amp; Array.some 匹配全部/部分内容"></a>5. 用 Array.every &amp; Array.some 匹配全部/部分内容</h2><p>我们能使用数组方法减少代码行。查看下面的代码，我们想要检查是否所有的水果都是红色的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'apple'</span>, <span class="attr">color</span>: <span class="string">'red'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'banana'</span>, <span class="attr">color</span>: <span class="string">'yellow'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'grape'</span>, <span class="attr">color</span>: <span class="string">'purple'</span> &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isAllRed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// condition: all fruits must be red</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> f <span class="keyword">of</span> fruits) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAllRed) <span class="keyword">break</span>;</span><br><span class="line">    isAllRed = (f.color == <span class="string">'red'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(isAllRed); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码太长了！我们能用 Array.every 来减少代码行数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'apple'</span>, <span class="attr">color</span>: <span class="string">'red'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'banana'</span>, <span class="attr">color</span>: <span class="string">'yellow'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'grape'</span>, <span class="attr">color</span>: <span class="string">'purple'</span> &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// condition: short way, all fruits must be red</span></span><br><span class="line">  <span class="keyword">const</span> isAllRed = fruits.every(<span class="function"><span class="params">f</span> =&gt;</span> f.color == <span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(isAllRed); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似地，如果我们想测试是否有任何红色的水果，我们能用一行 Array.some 来实现它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'apple'</span>, <span class="attr">color</span>: <span class="string">'red'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'banana'</span>, <span class="attr">color</span>: <span class="string">'yellow'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'grape'</span>, <span class="attr">color</span>: <span class="string">'purple'</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// condition: if any fruit is red</span></span><br><span class="line">  <span class="keyword">const</span> isAnyRed = fruits.some(<span class="function"><span class="params">f</span> =&gt;</span> f.color == <span class="string">'red'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(isAnyRed); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-使用可选链和空值合并"><a href="#6-使用可选链和空值合并" class="headerlink" title="6. 使用可选链和空值合并"></a>6. 使用可选链和空值合并</h2><p>这有两个为编写更清晰的条件语句而即将成为 JavaScript 增强的功能。当写这篇文章时，它们还没有被完全支持，你需要使用 Babel 来编译。</p><p>可选链允许我们没有明确检查中间节点是否存在地处理 tree-like 结构，空值合并和可选链组合起来工作得很好，以确保为不存在的值赋一个默认值。</p><p>这有一个例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">    model: <span class="string">'Fiesta'</span>,</span><br><span class="line">    manufacturer: &#123;</span><br><span class="line">    name: <span class="string">'Ford'</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        street: <span class="string">'Some Street Name'</span>,</span><br><span class="line">        <span class="built_in">number</span>: <span class="string">'5555'</span>,</span><br><span class="line">        state: <span class="string">'USA'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// to get the car model</span></span><br><span class="line"><span class="keyword">const</span> model = car &amp;&amp; car.model || <span class="string">'default model'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to get the manufacturer street</span></span><br><span class="line"><span class="keyword">const</span> street = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; </span><br><span class="line">car.manufacturer.address.street || <span class="string">'default street'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// request an un-existing property</span></span><br><span class="line"><span class="keyword">const</span> phoneNumber = car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address </span><br><span class="line">&amp;&amp; car.manufacturer.phoneNumber;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(model) <span class="comment">// 'Fiesta'</span></span><br><span class="line"><span class="built_in">console</span>.log(street) <span class="comment">// 'Some Street Name'</span></span><br><span class="line"><span class="built_in">console</span>.log(phoneNumber) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>所以，如果我们想要打印是否车辆生产商来自美国，代码将看起来像这样：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const isManufacturerFromUSA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(car &amp;&amp; car.manufacturer &amp;&amp; car.manufacturer.address &amp;&amp; </span><br><span class="line"> car.manufacturer.address.state === <span class="string">'USA'</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">checkCarManufacturerState() <span class="regexp">//</span> <span class="string">'true'</span></span><br></pre></td></tr></table></figure><p>你能清晰地看到当有一个更复杂的对象结构时，这能变得多乱。有一些第三方的库有它们自己的函数，像 lodash 或 idx。例如 lodash 有 _.get 方法。然而，JavaScript 语言本身被引入这个特性是非常酷的。</p><p>这展示了这些新特性如何工作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to get the car model</span></span><br><span class="line"><span class="keyword">const</span> model = car?.model ?? <span class="string">'default model'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to get the manufacturer street</span></span><br><span class="line"><span class="keyword">const</span> street = car?.manufacturer?.address?.street ?? <span class="string">'default street'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to check if the car manufacturer is from the USA</span></span><br><span class="line"><span class="keyword">const</span> isManufacturerFromUSA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(car?.manufacturer?.address?.state === <span class="string">'USA'</span>) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'true'</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来很美观并容易维护。它已经到 TC39 stage 3 阶段，让我们等待它获得批准，然后我们就能无处不在地看到这难以置信的语法的使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>让我们为了编写更清晰、易维护的代码，学习并尝试新的技巧和技术，因为在几个月后，长长的条件看起来像搬石头砸自己的脚。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在任何编程语言中，代码需要根据不同的条件在给定的输入中做不同的决定和执行相应的动作。&lt;/p&gt;
&lt;p&gt;例如，在一个游戏中，如果玩家生命点为0，游戏结束。在天气应用中，如果在早上被查看，显示一个日出图片，如果是晚上，则显示星星和月亮。在这篇文章中，我们将探索JavaScript中所谓的条件语句如何工作。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://chongdee.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://chongdee.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise讲解</title>
    <link href="https://chongdee.github.io/2021/05/09/promise/%E6%89%8B%E5%86%99Promise%E8%AE%B2%E8%A7%A3/"/>
    <id>https://chongdee.github.io/2021/05/09/promise/手写Promise讲解/</id>
    <published>2021-05-08T19:24:00.003Z</published>
    <updated>2021-07-20T07:36:16.756Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">MyPromise</span> &#123;</span></span><br><span class="line"><span class="class">    constructor(<span class="title">fn</span>)&#123;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    resolve()&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    then()&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    reject()&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    catch()&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="实现构造函数"><a href="#实现构造函数" class="headerlink" title="实现构造函数"></a>实现构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`MyPromise fn <span class="subst">$&#123;fn&#125;</span> is not a function`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数接收一个参数fn，且这个参数必须是一个函数，因为我们一般这样使用new Promise((resolve,reject)=&gt;{});<br>然后初始化一下promise的状态，默认开始为pending，初始化value的值。<br>fn接收两个参数，resolve、reject</p></blockquote><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new TypeError(`MyPromise fn $&#123;fn&#125; <span class="keyword">is</span> not a function`)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = void <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当resolve执行，接收到一个值之后；状态就由 pending -&gt; fulfilled；当前的值为接收的值</p><h2 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h2></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new TypeError(`MyPromise fn $&#123;fn&#125; <span class="keyword">is</span> not a function`)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = void <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = reason</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当reject执行，接收到一个值之后；状态就由 pending -&gt; rejected；当前的值为接收的值</p></blockquote><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new TypeError(`MyPromise fn $&#123;fn&#125; <span class="keyword">is</span> not a function`)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = void <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = reason</span><br><span class="line">    &#125;</span><br><span class="line">    then(fulfilled,rejected)&#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof fulfilled !== <span class="string">'function'</span> &amp;&amp; typeof rejected !== <span class="string">'function'</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (typeof fulfilled !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'fulfilled'</span> ||</span><br><span class="line">            typeof rejected !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new MyPromise((resolve,reject)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(fulfilled &amp;&amp; typeof fulfilled === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">                let result = fulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">if</span>(result &amp;&amp; typeof result.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> result.then(resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rejected &amp;&amp; typeof rejected === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">                let result = rejected(<span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">if</span>(result &amp;&amp; typeof result.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> result.then(resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>then的实现比较关键，首先有两个判断，第一个判断传的两个参数是否都是函数，如果都不是return this执行下一步操作。<br>第二个判断的作用是，比如，现在状态从pending -&gt; rejected;但是中间代码中有许多个.then的操作，我们需要跳过这些操作执行.catch的代码。如下面的代码，执行结果只会打印1</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve,reject)</span>=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(e)</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>下面有两个判断，作用是判断是rejected还是fulfilled,首先看fulfilled，如果是fulfilled的话，首先执行fulfilled函数，并把当前的value值传过去，也就是下面这步操作,res就是传过去的value值，并执行了(res)=&gt;{console.log(res)}这段代码;执行完成之后我们得到了result；也就是2这个结果，下面就是判断当前结果是否是一个promise实例了，也就是下面注释了的情况，现在我们直接执行resolve(result);</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve,reject)</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(res)</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="regexp">//</span><span class="keyword">return</span> <span class="keyword">new</span> Promise(resolve=&gt;&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">catch</span>(rejected)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,rejected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完成代码"><a href="#完成代码" class="headerlink" title="完成代码"></a>完成代码</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new TypeError(`MyPromise fn $&#123;fn&#125; <span class="keyword">is</span> not a function`)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = void <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = reason</span><br><span class="line">    &#125;</span><br><span class="line">    then(fulfilled,rejected)&#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof fulfilled !== <span class="string">'function'</span> &amp;&amp; typeof rejected !== <span class="string">'function'</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (typeof fulfilled !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'fulfilled'</span> ||</span><br><span class="line">            typeof rejected !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new MyPromise((resolve,reject)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(fulfilled &amp;&amp; typeof fulfilled === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">                let result = fulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">if</span>(result &amp;&amp; typeof result.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> result.then(resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rejected &amp;&amp; typeof rejected === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">                let result = rejected(<span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">if</span>(result &amp;&amp; typeof result.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> result.then(resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(rejected)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,rejected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整体结构&quot;&gt;&lt;a href=&quot;#整体结构&quot; class=&quot;headerlink&quot; title=&quot;整体结构&quot;&gt;&lt;/a&gt;整体结构&lt;/h2&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyPromise&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    constructor(&lt;span class=&quot;title&quot;&gt;fn&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    resolve()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    then()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    reject()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    catch()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://chongdee.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://chongdee.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise讲解</title>
    <link href="https://chongdee.github.io/2021/05/09/Promise/%E6%89%8B%E5%86%99Promise%E8%AE%B2%E8%A7%A3/"/>
    <id>https://chongdee.github.io/2021/05/09/Promise/手写Promise讲解/</id>
    <published>2021-05-08T19:24:00.003Z</published>
    <updated>2021-07-20T07:36:16.756Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">MyPromise</span> &#123;</span></span><br><span class="line"><span class="class">    constructor(<span class="title">fn</span>)&#123;</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    resolve()&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    then()&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    reject()&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    catch()&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="实现构造函数"><a href="#实现构造函数" class="headerlink" title="实现构造函数"></a>实现构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`MyPromise fn <span class="subst">$&#123;fn&#125;</span> is not a function`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数接收一个参数fn，且这个参数必须是一个函数，因为我们一般这样使用new Promise((resolve,reject)=&gt;{});<br>然后初始化一下promise的状态，默认开始为pending，初始化value的值。<br>fn接收两个参数，resolve、reject</p></blockquote><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new TypeError(`MyPromise fn $&#123;fn&#125; <span class="keyword">is</span> not a function`)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = void <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当resolve执行，接收到一个值之后；状态就由 pending -&gt; fulfilled；当前的值为接收的值</p><h2 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h2></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new TypeError(`MyPromise fn $&#123;fn&#125; <span class="keyword">is</span> not a function`)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = void <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = reason</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当reject执行，接收到一个值之后；状态就由 pending -&gt; rejected；当前的值为接收的值</p></blockquote><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new TypeError(`MyPromise fn $&#123;fn&#125; <span class="keyword">is</span> not a function`)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = void <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = reason</span><br><span class="line">    &#125;</span><br><span class="line">    then(fulfilled,rejected)&#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof fulfilled !== <span class="string">'function'</span> &amp;&amp; typeof rejected !== <span class="string">'function'</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (typeof fulfilled !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'fulfilled'</span> ||</span><br><span class="line">            typeof rejected !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new MyPromise((resolve,reject)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(fulfilled &amp;&amp; typeof fulfilled === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">                let result = fulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">if</span>(result &amp;&amp; typeof result.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> result.then(resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rejected &amp;&amp; typeof rejected === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">                let result = rejected(<span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">if</span>(result &amp;&amp; typeof result.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> result.then(resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>then的实现比较关键，首先有两个判断，第一个判断传的两个参数是否都是函数，如果都不是return this执行下一步操作。<br>第二个判断的作用是，比如，现在状态从pending -&gt; rejected;但是中间代码中有许多个.then的操作，我们需要跳过这些操作执行.catch的代码。如下面的代码，执行结果只会打印1</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve,reject)</span>=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(e)</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>下面有两个判断，作用是判断是rejected还是fulfilled,首先看fulfilled，如果是fulfilled的话，首先执行fulfilled函数，并把当前的value值传过去，也就是下面这步操作,res就是传过去的value值，并执行了(res)=&gt;{console.log(res)}这段代码;执行完成之后我们得到了result；也就是2这个结果，下面就是判断当前结果是否是一个promise实例了，也就是下面注释了的情况，现在我们直接执行resolve(result);</p></blockquote><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve,reject)</span>=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(res)</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="regexp">//</span><span class="keyword">return</span> <span class="keyword">new</span> Promise(resolve=&gt;&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">catch</span>(rejected)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,rejected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完成代码"><a href="#完成代码" class="headerlink" title="完成代码"></a>完成代码</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typeof fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new TypeError(`MyPromise fn $&#123;fn&#125; <span class="keyword">is</span> not a function`)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'pending'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = void <span class="number">0</span>;</span><br><span class="line">        fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>),<span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    reject(reason)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state !== <span class="string">'pending'</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = reason</span><br><span class="line">    &#125;</span><br><span class="line">    then(fulfilled,rejected)&#123;</span><br><span class="line">        <span class="keyword">if</span> (typeof fulfilled !== <span class="string">'function'</span> &amp;&amp; typeof rejected !== <span class="string">'function'</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (typeof fulfilled !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'fulfilled'</span> ||</span><br><span class="line">            typeof rejected !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> new MyPromise((resolve,reject)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(fulfilled &amp;&amp; typeof fulfilled === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'fulfilled'</span>)&#123;</span><br><span class="line">                let result = fulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">if</span>(result &amp;&amp; typeof result.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> result.then(resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rejected &amp;&amp; typeof rejected === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.state === <span class="string">'rejected'</span>)&#123;</span><br><span class="line">                let result = rejected(<span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">if</span>(result &amp;&amp; typeof result.then === <span class="string">'function'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> result.then(resolve,reject)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(rejected)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>,rejected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整体结构&quot;&gt;&lt;a href=&quot;#整体结构&quot; class=&quot;headerlink&quot; title=&quot;整体结构&quot;&gt;&lt;/a&gt;整体结构&lt;/h2&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;MyPromise&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    constructor(&lt;span class=&quot;title&quot;&gt;fn&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    resolve()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    then()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    reject()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    catch()&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://chongdee.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://chongdee.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>路由权限,大文件下载等问题</title>
    <link href="https://chongdee.github.io/2021/05/09/Vue/%E8%B7%AF%E7%94%B1%E6%9D%83%E9%99%90,%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%AD%89%E9%97%AE%E9%A2%98/"/>
    <id>https://chongdee.github.io/2021/05/09/Vue/路由权限,大文件下载等问题/</id>
    <published>2021-05-08T19:13:18.469Z</published>
    <updated>2021-05-08T19:16:25.784Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>有一些问题不限于 Vue，还适应于其他类型的 SPA 项目。</p><h2 id="1-页面权限控制和登陆验证"><a href="#1-页面权限控制和登陆验证" class="headerlink" title="1. 页面权限控制和登陆验证"></a>1. 页面权限控制和登陆验证</h2><h3 id="页面权限控制"><a href="#页面权限控制" class="headerlink" title="页面权限控制"></a>页面权限控制</h3><p>页面权限控制是什么意思呢？</p><p>就是一个网站有不同的角色，比如管理员和普通用户，要求不同的角色能访问的页面是不一样的。如果一个页面，有角色越权访问，这时就得做出限制了。<br><a id="more"></a><br>一种方法是通过动态添加路由和菜单来做控制，不能访问的页面不添加到路由表里，这是其中一种办法。具体细节请看下一节的《动态菜单》。</p><p>另一种办法就是所有的页面都在路由表里，只是在访问的时候要判断一下角色权限。如果有权限就允许访问，没有权限就拒绝，跳转到 404 页面。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在每一个路由的 meta 属性里，将能访问该路由的角色添加到 roles 里。用户每次登陆后，将用户的角色返回。然后在访问页面时，把路由的 meta 属性和用户的角色进行对比，如果用户的角色在路由的 roles 里，那就是能访问，如果不在就拒绝访问。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>路由信息</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        name: <span class="string">'login'</span>,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            roles: [<span class="string">'admin'</span>, <span class="string">'user'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Login.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'home'</span>,</span><br><span class="line">        name: <span class="string">'home'</span>,</span><br><span class="line">        meta: &#123;</span><br><span class="line">            roles: [<span class="string">'admin'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>页面控制</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设角色有两种：admin 和 user</span></span><br><span class="line"><span class="comment">// 这里是从后台获取的用户角色</span></span><br><span class="line">const role = <span class="string">'user'</span></span><br><span class="line"><span class="comment">// 在进入一个页面前会触发 router.beforeEach 事件</span></span><br><span class="line">router.beforeEach((to, <span class="keyword">from</span>, <span class="keyword">next</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.meta.roles.<span class="keyword">includes</span>(role)) &#123;</span><br><span class="line">        <span class="keyword">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">next</span>(&#123;path: <span class="string">'/404'</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>登陆验证<br>网站一般只要登陆过一次后，接下来该网站的其他页面都是可以直接访问的，不用再次登陆。我们可以通过 token 或 cookie 来实现，下面用代码来展示一下如何用 token 控制登陆验证。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, <span class="built_in">next</span>) =&gt; &#123;</span><br><span class="line">    // 如果有token 说明该用户已登陆</span><br><span class="line">    <span class="keyword">if</span> (localStorage.getItem(<span class="string">'token'</span>)) &#123;</span><br><span class="line">        // 在已登陆的情况下访问登陆页会重定向到首页</span><br><span class="line">        <span class="keyword">if</span> (to.<span class="built_in">path</span> === <span class="string">'/login'</span>) &#123;</span><br><span class="line">            <span class="built_in">next</span>(&#123;<span class="built_in">path</span>: <span class="string">'/'</span>&#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">next</span>(&#123;<span class="built_in">path</span>: to.<span class="built_in">path</span> || <span class="string">'/'</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // 没有登陆则访问任何页面都重定向到登陆页</span><br><span class="line">        <span class="keyword">if</span> (to.<span class="built_in">path</span> === <span class="string">'/login'</span>) &#123;</span><br><span class="line">            <span class="built_in">next</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">next</span>(`/login?redirect=$&#123;to.<span class="built_in">path</span>&#125;`)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-动态菜单"><a href="#2-动态菜单" class="headerlink" title="2. 动态菜单"></a>2. 动态菜单</h2><p>写后台管理系统，估计有不少人遇过这样的需求：根据后台数据动态添加路由和菜单。为什么这么做呢？因为不同的用户有不同的权限，能访问的页面是不一样的。</p><h3 id="动态添加路由"><a href="#动态添加路由" class="headerlink" title="动态添加路由"></a>动态添加路由</h3><p>利用 vue-router 的 addRoutes 方法可以动态添加路由。</p><p>先看一下官方介绍：</p><p><strong>router.addRoutes</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">router</span><span class="selector-class">.addRoutes</span>(<span class="attribute">routes</span>: Array&lt;RouteConfig&gt;)</span><br></pre></td></tr></table></figure><p>动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。</p><p>举个例子：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/login'</span>,</span><br><span class="line">            name: <span class="string">'login'</span>,</span><br><span class="line">            component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Login.vue'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;path: <span class="string">'/'</span>, redirect: <span class="string">'/home'</span>&#125;,</span><br><span class="line">    ]   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码和下面的代码效果是一样的</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;path: <span class="string">'/'</span>, redirect: <span class="string">'/home'</span>&#125;,</span><br><span class="line">    ]   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.addRoutes([</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        name: <span class="string">'login'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Login.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>在动态添加路由的过程中，如果有 404 页面，一定要放在最后添加，否则在登陆的时候添加完页面会重定向到 404 页面。</p><p>类似于这样，这种规则一定要最后添加。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attribute">path</span>: <span class="string">'*'</span>, redirect: <span class="string">'/404'</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="动态生成菜单"><a href="#动态生成菜单" class="headerlink" title="动态生成菜单"></a>动态生成菜单</h3><p>假设后台返回来的数据长这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左侧菜单栏数据</span></span><br><span class="line"><span class="attribute">menuItems</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">name</span>: <span class="string">'home'</span>, <span class="comment">// 要跳转的路由名称 不是路径</span></span><br><span class="line">        <span class="attribute">size</span>: <span class="number">18</span>, <span class="comment">// icon大小</span></span><br><span class="line">        <span class="attribute">type</span>: <span class="string">'md-home'</span>, <span class="comment">// icon类型</span></span><br><span class="line">        <span class="attribute">text</span>: <span class="string">'主页'</span> <span class="comment">// 文本内容</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">text</span>: <span class="string">'二级菜单'</span>,</span><br><span class="line">        <span class="attribute">type</span>: <span class="string">'ios-paper'</span>,</span><br><span class="line">        <span class="attribute">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attribute">type</span>: <span class="string">'ios-grid'</span>,</span><br><span class="line">                <span class="attribute">name</span>: <span class="string">'t1'</span>,</span><br><span class="line">                <span class="attribute">text</span>: <span class="string">'表格'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attribute">text</span>: <span class="string">'三级菜单'</span>,</span><br><span class="line">                <span class="attribute">type</span>: <span class="string">'ios-paper'</span>,</span><br><span class="line">                <span class="attribute">children</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attribute">type</span>: <span class="string">'ios-notifications-outline'</span>,</span><br><span class="line">                        <span class="attribute">name</span>: <span class="string">'msg'</span>,</span><br><span class="line">                        <span class="attribute">text</span>: <span class="string">'查看消息'</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>来看看怎么将它转化为菜单栏，我在这里使用了 iview 的组件，不用重复造轮子。</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 菜单栏 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Menu</span> <span class="attr">ref</span>=<span class="string">"asideMenu"</span> <span class="attr">theme</span>=<span class="string">"dark"</span> <span class="attr">width</span>=<span class="string">"100%"</span> @<span class="attr">on-select</span>=<span class="string">"gotoPage"</span> </span></span></span><br><span class="line"><span class="xml">accordion :open-names="openMenus" :active-name="currentPage" @on-open-change="menuChange"&gt;</span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 动态菜单 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in menuItems"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Submenu</span> <span class="attr">v-if</span>=<span class="string">"item.children"</span> <span class="attr">:name</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"item.size"</span> <span class="attr">:type</span>=<span class="string">"item.type"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(subItem, i) in item.children"</span> <span class="attr">:key</span>=<span class="string">"index + i"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">Submenu</span> <span class="attr">v-if</span>=<span class="string">"subItem.children"</span> <span class="attr">:name</span>=<span class="string">"index + '-' + i"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"subItem.size"</span> <span class="attr">:type</span>=<span class="string">"subItem.type"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;subItem.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">class</span>=<span class="string">"menu-level-3"</span> <span class="attr">v-for</span>=<span class="string">"(threeItem, k) in subItem.children"</span> <span class="attr">:name</span>=<span class="string">"threeItem.name"</span> <span class="attr">:key</span>=<span class="string">"index + i + k"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"threeItem.size"</span> <span class="attr">:type</span>=<span class="string">"threeItem.type"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;threeItem.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">Submenu</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">v-else</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span> <span class="attr">:name</span>=<span class="string">"subItem.name"</span>&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"subItem.size"</span> <span class="attr">:type</span>=<span class="string">"subItem.type"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;subItem.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Submenu</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">MenuItem</span> <span class="attr">v-else</span> <span class="attr">:name</span>=<span class="string">"item.name"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">Icon</span> <span class="attr">:size</span>=<span class="string">"item.size"</span> <span class="attr">:type</span>=<span class="string">"item.type"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">"isShowAsideTitle"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.text&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">MenuItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>代码不用看得太仔细，理解原理即可，其实就是通过三次 v-for 不停的对子数组进行循环，生成三级菜单。</p><p>不过这个动态菜单有缺陷，就是只支持三级菜单。一个更好的做法是把生成菜单的过程封装成组件，然后递归调用，这样就能支持无限级的菜单。在生菜菜单时，需要判断一下是否还有子菜单，如果有就递归调用组件。</p><p><strong>动态路由</strong>因为上面已经说过了用 addRoutes 来实现，现在看看具体怎么做。</p><p>首先，要把项目所有的页面路由都列出来，再用后台返回来的数据动态匹配，能匹配上的就把路由加上，不能匹配上的就不加。最后把这个新生成的路由数据用 addRoutes 添加到路由表里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncRoutes = &#123;</span><br><span class="line">    <span class="string">'home'</span>: &#123;</span><br><span class="line">        path: <span class="string">'home'</span>,</span><br><span class="line">        name: <span class="string">'home'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'t1'</span>: &#123;</span><br><span class="line">        path: <span class="string">'t1'</span>,</span><br><span class="line">        name: <span class="string">'t1'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/T1.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'password'</span>: &#123;</span><br><span class="line">        path: <span class="string">'password'</span>,</span><br><span class="line">        name: <span class="string">'password'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Password.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'msg'</span>: &#123;</span><br><span class="line">        path: <span class="string">'msg'</span>,</span><br><span class="line">        name: <span class="string">'msg'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Msg.vue'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'userinfo'</span>: &#123;</span><br><span class="line">        path: <span class="string">'userinfo'</span>,</span><br><span class="line">        name: <span class="string">'userinfo'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/UserInfo.vue'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入后台数据 生成路由表</span></span><br><span class="line">menusToRoutes(menusData)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将菜单信息转成对应的路由信息 动态添加</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">menusToRoutes</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">const</span> children = []</span><br><span class="line"></span><br><span class="line">    result.push(&#123;</span><br><span class="line">        path: <span class="string">'/'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Index.vue'</span>),</span><br><span class="line">        children,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        generateRoutes(children, item)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    children.push(&#123;</span><br><span class="line">        path: <span class="string">'error'</span>,</span><br><span class="line">        name: <span class="string">'error'</span>,</span><br><span class="line">        component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/Error.vue'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后添加404页面 否则会在登陆成功后跳到404页面</span></span><br><span class="line">    result.push(</span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">'*'</span>, <span class="attr">redirect</span>: <span class="string">'/error'</span>&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRoutes</span>(<span class="params">children, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.name) &#123;</span><br><span class="line">        children.push(asyncRoutes[item.name])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.children) &#123;</span><br><span class="line">        item.children.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            generateRoutes(children, e)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态菜单的代码实现放在 github 上，分别放在这个项目的 src/components/Index.vue、src/permission.js 和 src/utils/index.js 文件里。</p><h2 id="3-前进刷新后退不刷新"><a href="#3-前进刷新后退不刷新" class="headerlink" title="3. 前进刷新后退不刷新"></a>3. 前进刷新后退不刷新</h2><h3 id="需求一："><a href="#需求一：" class="headerlink" title="需求一："></a>需求一：</h3><p>在一个列表页中，第一次进入的时候，请求获取数据。</p><p>点击某个列表项，跳到详情页，再从详情页后退回到列表页时，不刷新。</p><p>也就是说从其他页面进到列表页，需要刷新获取数据，从详情页返回到列表页时不要刷新。</p><p><strong>解决方案</strong></p><p>在 App.vue设置：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">keep</span>-alive <span class="keyword">include</span>=<span class="string">"list"</span>&gt;</span><br><span class="line">    &lt;router-<span class="keyword">view</span>/&gt;</span><br><span class="line">&lt;/<span class="keyword">keep</span>-alive&gt;</span><br></pre></td></tr></table></figure><p>假设列表页为 <strong>list.vue</strong>，详情页为<strong>detail.vue</strong>，这两个都是子组件。</p><p>我们在 keep-alive 添加列表页的名字，缓存列表页。</p><p>然后在列表页的 created 函数里添加 ajax 请求，这样只有第一次进入到列表页的时候才会请求数据，当从列表页跳到详情页，再从详情页回来的时候，列表页就不会刷新。这样就可以解决问题了。</p><h3 id="需求二："><a href="#需求二：" class="headerlink" title="需求二："></a>需求二：</h3><p>在需求一的基础上，再加一个要求：可以在详情页中删除对应的列表项，这时返回到列表页时需要刷新重新获取数据。</p><p>我们可以在路由配置文件上对 detail.vue 增加一个 meta 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attribute">path</span>: <span class="string">'/detail'</span>,</span><br><span class="line">   name: <span class="string">'detail'</span>,</span><br><span class="line">   component: () =&gt; <span class="built_in">import</span>(<span class="string">'../view/detail.vue'</span>),</span><br><span class="line">   meta: &#123;isRefresh: true&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个 meta 属性，可以在详情页中通过 this.$route.meta.isRefresh 来读取和设置。</p><p>设置完这个属性，还要在 App.vue 文件里设置 watch 一下 $route 属性。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">       $route(<span class="keyword">to</span>, <span class="keyword">from</span>) &#123;</span><br><span class="line">           const fname = <span class="keyword">from</span>.<span class="built_in">name</span></span><br><span class="line">           const tname = <span class="keyword">to</span>.<span class="built_in">name</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">from</span>.meta.isRefresh || (fname != <span class="string">'detail'</span> &amp;&amp; tname == <span class="string">'list'</span>)) &#123;</span><br><span class="line">               <span class="keyword">from</span>.meta.isRefresh = <span class="literal">false</span></span><br><span class="line">       <span class="comment">// 在这里重新请求数据</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>这样就不需要在列表页的 created 函数里用 ajax 来请求数据了，统一放在 App.vue 里来处理。</p><p>触发请求数据有两个条件：</p><ol><li>从其他页面（除了详情页）进来列表时，需要请求数据。</li><li>从详情页返回到列表页时，如果详情页 meta 属性中的 isRefresh 为 true，也需要重新请求数据。</li></ol><p>当我们在详情页中删除了对应的列表项时，就可以将详情页 meta 属性中的 isRefresh 设为 true。这时再返回到列表页，页面会重新刷新。</p><h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>对于需求二其实还有一个更简洁的方案，那就是使用 router-view 的 key 属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:key</span>=<span class="string">"$route.fullPath"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先 keep-alive 让所有页面都缓存，当你不想缓存某个路由页面，要重新加载它时，可以在跳转时传一个随机字符串，这样它就能重新加载了。例如从列表页进入了详情页，然后在详情页中删除了列表页中的某个选项，此时从详情页退回列表页时就要刷新，我们可以这样跳转：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123;</span><br><span class="line">    path: <span class="string">'/list'</span>,</span><br><span class="line">    query: &#123; <span class="string">'randomID'</span>: <span class="string">'id'</span> + Math.random() &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样的方案相对来说还是更简洁的。</p><h2 id="4-多个请求下-loading-的展示与关闭"><a href="#4-多个请求下-loading-的展示与关闭" class="headerlink" title="4. 多个请求下 loading 的展示与关闭"></a>4. 多个请求下 loading 的展示与关闭</h2><p>一般情况下，在 vue 中结合 axios 的拦截器控制 loading 展示和关闭，是这样的：</p><p>在 App.vue 配置一个全局 loading。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;keep-alive :include=<span class="string">"keepAliveData"</span>&gt;</span><br><span class="line">        &lt;router-view/&gt;</span><br><span class="line">    &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="loading" v-show="isShowLoading"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Spin size="large"&gt;&lt;/</span>Spin&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>同时设置 axios 拦截器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line"> <span class="keyword">this</span>.$axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">     <span class="keyword">this</span>.isShowLoading = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">return</span> config</span><br><span class="line"> &#125;, error =&gt; &#123;</span><br><span class="line">     <span class="keyword">this</span>.isShowLoading = <span class="literal">false</span></span><br><span class="line">     <span class="keyword">return</span> Promise.reject(error)</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 添加响应拦截器</span></span><br><span class="line"> <span class="keyword">this</span>.$axios.interceptors.response.use(response =&gt; &#123;</span><br><span class="line">     <span class="keyword">this</span>.isShowLoading = <span class="literal">false</span></span><br><span class="line">     <span class="keyword">return</span> response</span><br><span class="line"> &#125;, error =&gt; &#123;</span><br><span class="line">     <span class="keyword">this</span>.isShowLoading = <span class="literal">false</span></span><br><span class="line">     <span class="keyword">return</span> Promise.reject(error)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>这个拦截器的功能是在请求前打开 loading，请求结束或出错时关闭 loading。</p><p>如果每次只有一个请求，这样运行是没问题的。但同时有多个请求并发，就会有问题了。</p><p><strong>举例：</strong></p><p>假如现在同时发起两个请求，在请求前，拦截器 this.isShowLoading = true 将 loading 打开。</p><p>现在有一个请求结束了。this.isShowLoading = false 拦截器关闭 loading，但是另一个请求由于某些原因并没有结束。</p><p>造成的后果就是页面请求还没完成，loading 却关闭了，用户会以为页面加载完成了，结果页面不能正常运行，导致用户体验不好。</p><p><strong>解决方案</strong></p><p>增加一个 loadingCount 变量，用来计算请求的次数。</p><p>loadingCount: 0<br>再增加两个方法，来对 loadingCount  进行增减操作。</p><pre><code>methods: {    addLoading() {        this.isShowLoading = true        this.loadingCount++    },    isCloseLoading() {        this.loadingCount--        if (this.loadingCount == 0) {            this.isShowLoading = false        }    }}</code></pre><p>现在拦截器变成这样：</p><pre><code>// 添加请求拦截器this.$axios.interceptors.request.use(config =&gt; {    this.addLoading()    return config}, error =&gt; {    this.isShowLoading = false    this.loadingCount = 0    this.$Message.error(&apos;网络异常，请稍后再试&apos;)    return Promise.reject(error)})// 添加响应拦截器this.$axios.interceptors.response.use(response =&gt; {    this.isCloseLoading()    return response}, error =&gt; {    this.isShowLoading = false    this.loadingCount = 0    this.$Message.error(&apos;网络异常，请稍后再试&apos;)    return Promise.reject(error)})</code></pre><p>这个拦截器的功能是：</p><p>每当发起一个请求，打开 loading，同时 loadingCount 加1。</p><p>每当一个请求结束， loadingCount 减1，并判断  loadingCount 是否为 0，如果为 0，则关闭 loading。</p><p>这样即可解决，多个请求下有某个请求提前结束，导致 loading 关闭的问题。</p><h2 id="5-表格打印"><a href="#5-表格打印" class="headerlink" title="5. 表格打印"></a>5. 表格打印</h2><p>打印需要用到的组件为 print-js</p><p>普通表格打印<br>一般的表格打印直接仿照组件提供的例子就可以了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">printJS</span>(&#123;</span><br><span class="line">    <span class="attribute">printable</span>: id, // DOM id</span><br><span class="line">    type: <span class="string">'html'</span>,</span><br><span class="line">    scanStyles: false,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>element-ui 表格打印（其他组件库的表格同理）<br>element-ui 的表格，表面上看起来是一个表格，实际上是由两个表格组成的。</p><p>表头为一个表格，表体又是个表格，这就导致了一个问题：打印的时候表体和表头错位。</p><p>图片</p><p>另外，在表格出现滚动条的时候，也会造成错位。</p><p>图片</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>我的思路是将两个表格合成一个表格，print-js 组件打印的时候，实际上是把 id 对应的 DOM 里的内容提取出来打印。所以，在传入 id 之前，可以先把表头所在的表格内容提取出来，插入到第二个表格里，从而将两个表格合并，这时候打印就不会有错位的问题了。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function printHTML(id) &#123;</span><br><span class="line">    <span class="keyword">const</span> html = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'#'</span> + id).innerHTML</span><br><span class="line">    <span class="comment">// 新建一个 DOM</span></span><br><span class="line">    <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="keyword">const</span> printDOMID = <span class="string">'printDOMElement'</span></span><br><span class="line">    div.id = printDOMID</span><br><span class="line">    div.innerHTML = html</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取第一个表格的内容 即表头</span></span><br><span class="line">    <span class="keyword">const</span> ths = div.<span class="built_in">querySelectorAll</span>(<span class="string">'.el-table__header-wrapper th'</span>)</span><br><span class="line">    <span class="keyword">const</span> ThsTextArry = []</span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>, len = ths.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ths[i].innerText !== <span class="string">''</span>) ThsTextArry.push(ths[i].innerText)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除多余的表头</span></span><br><span class="line">    div.<span class="built_in">querySelector</span>(<span class="string">'.hidden-columns'</span>).remove()</span><br><span class="line">    <span class="comment">// 第一个表格的内容提取出来后已经没用了 删掉</span></span><br><span class="line">    div.<span class="built_in">querySelector</span>(<span class="string">'.el-table__header-wrapper'</span>).remove()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第一个表格的内容插入到第二个表格</span></span><br><span class="line">    let newHTML = <span class="string">'&lt;tr&gt;'</span></span><br><span class="line">    <span class="keyword">for</span> (let i = <span class="number">0</span>, len = ThsTextArry.length; i &lt; len; i++) &#123;</span><br><span class="line">        newHTML += <span class="string">'&lt;td style="text-align: center; font-weight: bold"&gt;'</span> + ThsTextArry[i] + <span class="string">'&lt;/td&gt;'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newHTML += <span class="string">'&lt;/tr&gt;'</span></span><br><span class="line">    div.<span class="built_in">querySelector</span>(<span class="string">'.el-table__body-wrapper table'</span>).insertAdjacentHTML(<span class="string">'afterbegin'</span>, newHTML)</span><br><span class="line">    <span class="comment">// 将新的 DIV 添加到页面 打印后再删掉</span></span><br><span class="line">    <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'body'</span>).appendChild(div)</span><br><span class="line">    </span><br><span class="line">    printJS(&#123;</span><br><span class="line">        printable: printDOMID,</span><br><span class="line">        type: <span class="string">'html'</span>,</span><br><span class="line">        scanStyles: <span class="keyword">false</span>,</span><br><span class="line">        style: <span class="string">'table &#123; border-collapse: collapse &#125;'</span> <span class="comment">// 表格样式</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    div.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-下载二进制文件"><a href="#6-下载二进制文件" class="headerlink" title="6. 下载二进制文件"></a>6. 下载二进制文件</h2><p>平时在前端下载文件有两种方式，</p><ol><li>一种是后台提供一个 URL，然后用 window.open(URL) 下载，另一种就是后台直接返回文件的二进制内容，然后前端转化一下再下载。</li></ol><p>由于第一种方式比较简单，在此不做探讨。本文主要讲解一下第二种方式怎么实现。</p><ol><li>第二种方式需要用到 Blob 对象， mdn 文档上是这样介绍的：</li></ol><blockquote><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是JavaScript原生格式的数据<br>具体使用方法</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/export'</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设 data 是返回来的二进制数据</span></span><br><span class="line">  const data = res.data</span><br><span class="line">  const url = window<span class="selector-class">.URL</span><span class="selector-class">.createObjectURL</span>(new Blob([data], &#123;type: <span class="string">"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"</span>&#125;))</span><br><span class="line">  const link = document.createElement(<span class="string">'a'</span>)</span><br><span class="line">  link<span class="selector-class">.style</span><span class="selector-class">.display</span> = <span class="string">'none'</span></span><br><span class="line">  link<span class="selector-class">.href</span> = url</span><br><span class="line">  link.setAttribute(<span class="string">'download'</span>, <span class="string">'excel.xlsx'</span>)</span><br><span class="line">  document<span class="selector-class">.body</span><span class="selector-class">.appendChild</span>(link)</span><br><span class="line">  link.click()</span><br><span class="line">  document<span class="selector-class">.body</span><span class="selector-class">.removeChild</span>(link)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打开下载的文件，看看结果是否正确。</p><p>图片</p><p>在这里插入图片描述<br>一堆乱码…</p><p>一定有哪里不对。</p><p>最后发现是参数 responseType 的问题，responseType 它表示服务器响应的数据类型。由于后台返回来的是二进制数据，所以我们要把它设为 arraybuffer， 接下来再看看结果是否正确。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/export'</span>,</span><br><span class="line">  responseType: <span class="string">'arraybuffer'</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(res =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设 data 是返回来的二进制数据</span></span><br><span class="line">  const data = res.data</span><br><span class="line">  const url = window<span class="selector-class">.URL</span><span class="selector-class">.createObjectURL</span>(new Blob([data], &#123;type: <span class="string">"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"</span>&#125;))</span><br><span class="line">  const link = document.createElement(<span class="string">'a'</span>)</span><br><span class="line">  link<span class="selector-class">.style</span><span class="selector-class">.display</span> = <span class="string">'none'</span></span><br><span class="line">  link<span class="selector-class">.href</span> = url</span><br><span class="line">  link.setAttribute(<span class="string">'download'</span>, <span class="string">'excel.xlsx'</span>)</span><br><span class="line">  document<span class="selector-class">.body</span><span class="selector-class">.appendChild</span>(link)</span><br><span class="line">  link.click()</span><br><span class="line">  document<span class="selector-class">.body</span><span class="selector-class">.removeChild</span>(link)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>图片<br>这次没有问题，文件能正常打开，内容也是正常的，不再是乱码。</p><h3 id="根据后台接口内容决定是否下载文件"><a href="#根据后台接口内容决定是否下载文件" class="headerlink" title="根据后台接口内容决定是否下载文件"></a>根据后台接口内容决定是否下载文件</h3><p>作者的项目有大量的页面都有下载文件的需求，而且这个需求还有点变态。</p><p>具体需求如下</p><ol><li>如果下载文件的数据量条数符合要求，正常下载（每个页面限制下载数据量是不一样的，所以不能在前端写死）。</li><li>如果文件过大，后台返回 { code: 199999, msg: ‘文件过大，请重新设置查询项’, data: null }，然后前端再进行报错提示。<br>先来分析一下，首先根据上文，我们都知道下载文件的接口响应数据类型为 arraybuffer。返回的数据无论是二进制文件，还是 JSON 字符串，前端接收到的其实都是 arraybuffer。所以我们要对 arraybuffer 的内容作个判断，在接收到数据时将它转换为字符串，判断是否有 code: 199999。如果有，则报错提示，如果没有，则是正常文件，下载即可。具体实现如下：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = response.data</span><br><span class="line">    <span class="comment">// 判断响应数据类型是否 ArrayBuffer，true 则是下载文件接口，false 则是正常接口</span></span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> utf8decoder = <span class="keyword">new</span> TextDecoder()</span><br><span class="line">        <span class="keyword">const</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(res)</span><br><span class="line">        <span class="comment">// 将二进制数据转为字符串</span></span><br><span class="line">        <span class="keyword">const</span> temp = utf8decoder.decode(u8arr)</span><br><span class="line">        <span class="keyword">if</span> (temp.includes(<span class="string">'&#123;code:199999'</span>)) &#123;</span><br><span class="line">            Message(&#123;</span><br><span class="line">             <span class="comment">// 字符串转为 JSON 对象</span></span><br><span class="line">                message: <span class="built_in">JSON</span>.parse(temp).msg,</span><br><span class="line">                <span class="keyword">type</span>: <span class="string">'error'</span>,</span><br><span class="line">                duration: <span class="number">5000</span>,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常类型接口，省略代码...</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="7-自动忽略-console-log-语句"><a href="#7-自动忽略-console-log-语句" class="headerlink" title="7. 自动忽略 console.log 语句"></a>7. 自动忽略 console.log 语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">rewirteLog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log = (<span class="function"><span class="keyword">function</span> (<span class="params">log</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process.env.NODE_ENV == <span class="string">'development'</span>? log : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;(<span class="built_in">console</span>.log))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main.js 引入这个函数并执行一次，就可以实现忽略 console.log 语句的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些问题不限于 Vue，还适应于其他类型的 SPA 项目。&lt;/p&gt;
&lt;h2 id=&quot;1-页面权限控制和登陆验证&quot;&gt;&lt;a href=&quot;#1-页面权限控制和登陆验证&quot; class=&quot;headerlink&quot; title=&quot;1. 页面权限控制和登陆验证&quot;&gt;&lt;/a&gt;1. 页面权限控制和登陆验证&lt;/h2&gt;&lt;h3 id=&quot;页面权限控制&quot;&gt;&lt;a href=&quot;#页面权限控制&quot; class=&quot;headerlink&quot; title=&quot;页面权限控制&quot;&gt;&lt;/a&gt;页面权限控制&lt;/h3&gt;&lt;p&gt;页面权限控制是什么意思呢？&lt;/p&gt;
&lt;p&gt;就是一个网站有不同的角色，比如管理员和普通用户，要求不同的角色能访问的页面是不一样的。如果一个页面，有角色越权访问，这时就得做出限制了。&lt;br&gt;
    
    </summary>
    
      <category term="vue" scheme="https://chongdee.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://chongdee.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.x脱坑-解决方法总结</title>
    <link href="https://chongdee.github.io/2021/05/09/Vue/Vue2.x%E8%84%B1%E5%9D%91-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://chongdee.github.io/2021/05/09/Vue/Vue2.x脱坑-解决方法总结/</id>
    <published>2021-05-08T18:57:03.769Z</published>
    <updated>2021-05-08T19:11:37.518Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章内容覆盖范围,芝麻绿豆的破问题都有,不止于vue;<br>给出的是方案,而非手把手一字一句的给你说十万个为什么!</p><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="Q-安装超时-install-timeout"><a href="#Q-安装超时-install-timeout" class="headerlink" title="Q:安装超时(install timeout)"></a>Q:安装超时(install timeout)</h3><p>方案有这么些:</p><ul><li><p>cnpm : 国内对npm的镜像版本</p><a id="more"></a><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cnpm website: https://npm.taobao.org/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry=<span class="string">https:</span><span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cnpm 的大多命令跟 npm 的是一致的,比如安装,卸载这些</span></span><br></pre></td></tr></table></figure></li><li><p>yarn 和 npm 改源大法</p></li></ul><ul><li>使用 nrm 模块 : www.npmjs.com/package/nrm</li></ul><ul><li>npm config : npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li></ul><ul><li>yarn config : yarn config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></li></ul><h3 id="Q-想学习Vue-要先学习脚手架的搭建么"><a href="#Q-想学习Vue-要先学习脚手架的搭建么" class="headerlink" title="Q: 想学习Vue,要先学习脚手架的搭建么"></a>Q: 想学习Vue,要先学习脚手架的搭建么</h3><p>若是你想快速上手，用官方的脚手架即可(Vue-Cli 3)<br>因为不管是webpack还是parcel，gulp，都是一些构建工作流的东东；<br>学习脚手架的搭建，更多的是要针对项目业务进行定制，调优；<br>一般入门级的无需太早考虑这方面的，只要专心学好Vue的使用姿势便可。</p><h3 id="Q-安装一些需要编译的包-提示没有安装python、build失败等"><a href="#Q-安装一些需要编译的包-提示没有安装python、build失败等" class="headerlink" title="Q:安装一些需要编译的包:提示没有安装python、build失败等"></a>Q:安装一些需要编译的包:提示没有安装python、build失败等</h3><p>因为一些 npm 的包安装需要编译的环境,mac 和 linux 都还好,</p><p>而window 用户依赖 visual studio 的一些库和python 2+,<br>windows的小伙伴都装上:</p><ul><li><a href="https://github.com/felixrieseberg/windows-build-tools" target="_blank" rel="noopener">windows-build-tools</a></li><li><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">python 2.x</a></li></ul><h3 id="Q-can’t-not-find-‘xxModule’-找不到某些依赖或者模块"><a href="#Q-can’t-not-find-‘xxModule’-找不到某些依赖或者模块" class="headerlink" title="Q:can’t not find ‘xxModule’ - 找不到某些依赖或者模块"></a>Q:can’t not find ‘xxModule’ - 找不到某些依赖或者模块</h3><p>这种情况一般报错信息可以看到是哪个包抛出的信息，一般卸载这个模块,安装重新安装下即可。</p><h3 id="Q-data-functions-should-return-an-object"><a href="#Q-data-functions-should-return-an-object" class="headerlink" title="Q:data functions should return an object"></a>Q:data functions should return an object</h3><p>这个问题是 Vue 实例内,单组件的data必须返回一个对象;如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span> &#123;</span><br><span class="line">  <span class="attribute">name</span>: <span class="string">'page-router-view'</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        tabs: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: <span class="string">'财务信息'</span>,</span><br><span class="line">            url: <span class="string">'/userinfo'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attribute">title</span>: <span class="string">'帐号信息'</span>,</span><br><span class="line">            url: <span class="string">'/userinfo/base'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要 return 一个数据对象呢?</strong><br>官方解释如下:  data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。</p><p>如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！</p><p>简言之,组件复用下,不会造成数据同时指向一处,造出牵一发而动全身的破问题,</p><h3 id="Q-我给组件内的原生控件添加事件-怎么不生效了"><a href="#Q-我给组件内的原生控件添加事件-怎么不生效了" class="headerlink" title="Q:我给组件内的原生控件添加事件,怎么不生效了!"></a>Q:我给组件内的原生控件添加事件,怎么不生效了!</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!--比如用了第三方框架,或者一些封装的内置组件; 然后想绑定事件--&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--// 错误例子1--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入特定消费金额 "</span> @<span class="attr">mouseover</span>=<span class="string">"test()"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--// 错误例子2--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"item.menuUrl"</span> @<span class="attr">click</span>=<span class="string">"toggleName=''"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">:class</span>=<span class="string">"['fzicon',item.menuIcon]"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.menuName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--上面的两个例子都没法触发事件!--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--究其原因,少了一个修饰符 .native--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"item.menuUrl"</span> @<span class="attr">click.native</span>=<span class="string">"toggleName=''"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">:class</span>=<span class="string">"['fzicon',item.menuIcon]"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123;item.menuName&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--明明官方文档有的,一堆人不愿意去看,,Fuck--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--https://cn.vuejs.org/v2/guide/components.html#给组件绑定原生事件--&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="Q-provide和inject是什么"><a href="#Q-provide和inject是什么" class="headerlink" title="Q: provide和inject是什么"></a>Q: provide和inject是什么</h3><p>Vue 在2.2的时候,也提供了该概念。类比ng provider和react context;</p><h3 id="Q-我用了-axios-为什么-IE-浏览器不识别-IE9"><a href="#Q-我用了-axios-为什么-IE-浏览器不识别-IE9" class="headerlink" title="Q:我用了 axios , 为什么 IE 浏览器不识别(IE9+)"></a>Q:我用了 axios , 为什么 IE 浏览器不识别(IE9+)</h3><p>那是因为 IE 整个家族都不支持 promise, 解决方案:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">es6-promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 main.js 引入即可</span></span><br><span class="line"><span class="comment">// ES6的polyfill</span></span><br><span class="line"><span class="selector-tag">require</span>(<span class="string">"es6-promise"</span>)<span class="selector-class">.polyfill</span>();</span><br></pre></td></tr></table></figure><h3 id="Q-我在函数内用了this-xxx-为什么抛出Cannot-set-property-‘xxx’-of-undefined"><a href="#Q-我在函数内用了this-xxx-为什么抛出Cannot-set-property-‘xxx’-of-undefined" class="headerlink" title="Q:我在函数内用了this.xxx=,为什么抛出Cannot set property ‘xxx’ of undefined;"></a>Q:我在函数内用了this.xxx=,为什么抛出Cannot set property ‘xxx’ of undefined;</h3><p>这又是this的套路了,this是和当前运行的上下文绑定的,</p><p>一般你在axios或者其他 promise , 或者setInterval<br>这些默认都是指向最外层的全局钩子.</p><p>简单点说:”最外层的上下文就是 window,vue内则是 Vue 对象而不是实例!”;<br>解决方案:</p><ul><li>暂存法: 函数内先缓存 this , let that = this;(let是 es6, es5用 var)</li><li>箭头函数: 会强行关联当前运行区域为 this 的上下文;</li></ul><p>this的知识, 读”&lt;&lt;你不知道的 JS 系列&gt;&gt;”最为合适了,里面讲的很清楚</p><h3 id="Q-我看一些Vue教程有这么些写法-是什么意思-click-prevent-v-demo-a-b"><a href="#Q-我看一些Vue教程有这么些写法-是什么意思-click-prevent-v-demo-a-b" class="headerlink" title="Q:我看一些Vue教程有这么些写法,是什么意思@click.prevent,v-demo.a.b;"></a>Q:我看一些Vue教程有这么些写法,是什么意思@click.prevent,v-demo.a.b;</h3><p>@click.prevent : 事件+修饰符 , 作用就是点击但又阻止默认行为</p><p>v-demo.a.b: 自定义指令+修饰符.<br>具体看你什么指令了,修饰符的作用大多是给事件增加一些确切的拓展功能</p><p>比如阻止事件冒泡,阻止默认行为,访问到原生控件,结合键盘快捷键等等</p><p>传送门:<a href="https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6" target="_blank" rel="noopener">事件修饰符</a>;</p><p>可以自定义修饰符么?也是可以的,</p><p>可以通过全局 config.keyCodes 对象自定义键值修饰符别名：</p><h3 id="Q-为什么我的引入的小图片渲染出来却是-data-image-png-base64xxxxxxxx"><a href="#Q-为什么我的引入的小图片渲染出来却是-data-image-png-base64xxxxxxxx" class="headerlink" title="Q:为什么我的引入的小图片渲染出来却是 data:image/png;base64xxxxxxxx"></a>Q:为什么我的引入的小图片渲染出来却是 data:image/png;base64xxxxxxxx</h3><p>这个是 webpack 里面的对应插件处理的.</p><p>对于小于多少 K 以下的图片(规定的格式)直接转为 base64格式渲染;</p><p>具体配置在webpack.base.conf.js里面的 rules里面的 url-loader</p><p>这样做的好处:在网速不好的时候先于内容加载和减少http的请求次数来减少网站服务器的负担。</p><h3 id="Q-Component-template-shold-contain-exactly-one-root-element-If-you-are-useing-v-if-on-multiple-elements-xxxxx"><a href="#Q-Component-template-shold-contain-exactly-one-root-element-If-you-are-useing-v-if-on-multiple-elements-xxxxx" class="headerlink" title="Q:Component template shold contain exactly one root element.If you are useing v-if on multiple elements , xxxxx"></a>Q:Component template shold contain exactly one root element.If you are useing v-if on multiple elements , xxxxx</h3><p>大体就是说,单组件渲染 DOM 区域必须要有一个根元素,最外层添加<div></div></p><p>可以用v-if和v-else-if指令来控制其他元素达到并存的状态</p><h3 id="Q-跨域问题怎么破"><a href="#Q-跨域问题怎么破" class="headerlink" title="Q:跨域问题怎么破!"></a>Q:跨域问题怎么破!</h3><p>比如No ‘Access-Control-Allow-Origin’ header is present on the requested resource.<br>这种问题老生常谈了,我就不细说了,大体说一下;</p><ul><li><p>1: CORS , 前后端都要对应去配置,IE10+</p></li><li><p>2: nginx 反向代理,一劳永逸，线上环境可以用这个</p></li></ul><p>线下开发模式,比如你用了vue-cli, 里面的 webpack 有引入了proxyTable这么个玩意,<br>也可以做接口反向代理</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 config 目录下的index.js</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">proxyTable:</span> &#123;</span><br><span class="line">  <span class="string">"/bp-api"</span>: &#123;</span><br><span class="line"><span class="symbol">    target:</span> <span class="string">"http://new.d.st.cn"</span>,</span><br><span class="line"><span class="symbol">    changeOrigin:</span> true,</span><br><span class="line">    <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">    <span class="comment">//   "^/bp-api": "/"</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// target : 就是 api 的代理的实际路径</span></span><br><span class="line"><span class="comment">// changeOrigin: 就是是变源,必须是,</span></span><br><span class="line"><span class="comment">// pathRewrite : 就是路径重定向,一看就知道</span></span><br></pre></td></tr></table></figure><p>当然还有依旧坚挺的jsonp大法!不过局限性比较多,比较适合一些特殊的信息获取!</p><h3 id="Q-我需要遍历的数组值更新了-值也赋值了-为什么视图不更新"><a href="#Q-我需要遍历的数组值更新了-值也赋值了-为什么视图不更新" class="headerlink" title="Q:我需要遍历的数组值更新了,值也赋值了,为什么视图不更新!"></a>Q:我需要遍历的数组值更新了,值也赋值了,为什么视图不更新!</h3><p>那是因为有局限性啊,官方文档也说的很清楚,</p><p>只有一些魔改的之后的方法提供跟原生一样的使用姿势(可以触发视图更新);</p><p>一般我们更常用(除了魔改方法)的手段是使用:this.$set(obj,item,value);</p><p>传送门:<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">数组更新检测(触发视图更新)</a></p><h3 id="Q-为什么我的组件间的样式不能继承或者覆写啊"><a href="#Q-为什么我的组件间的样式不能继承或者覆写啊" class="headerlink" title="Q:为什么我的组件间的样式不能继承或者覆写啊!"></a>Q:为什么我的组件间的样式不能继承或者覆写啊!</h3><p>单组件开发模式下,请确认是否开启了 CSS模块化功能!!</p><p>也就是scoped(vue-cli 里面配置了,只要加入这个属性就自动启用)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"scss"</span> <span class="attr">scoped</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么不能简单的继承或者覆写呢,是因为每个类或者 id 乃至标签都会给自动在css后面添加自定义属性hash!<br>比如</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 写的时候是这个</span><br><span class="line"><span class="string">.trangle</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 编译过后,加上了 hash</span><br><span class="line"><span class="string">.trangle</span>[data-v-1ec35ffc]&#123;&#125;</span><br></pre></td></tr></table></figure><p>这些都是在 css-loader 里面配置!</p><h3 id="Q-路由模式改为history后-除了首次启动首页没报错-刷新访问路由都报错"><a href="#Q-路由模式改为history后-除了首次启动首页没报错-刷新访问路由都报错" class="headerlink" title="Q:路由模式改为history后,除了首次启动首页没报错,刷新访问路由都报错!"></a>Q:路由模式改为history后,除了首次启动首页没报错,刷新访问路由都报错!</h3><p>必须给对应的服务端配置查询的主页面,也可以认为是主路由入口的引导</p><p>官方文档也有,为毛总有人不喜欢去看文档,总喜欢做伸手党,FUCK<br>传送门 : <a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">Vue-Router history Mode</a></p><h3 id="Q-我想拦截页面-或者在页面进来之前做一些事情-可以么"><a href="#Q-我想拦截页面-或者在页面进来之前做一些事情-可以么" class="headerlink" title="Q:我想拦截页面,或者在页面进来之前做一些事情,可以么?"></a>Q:我想拦截页面,或者在页面进来之前做一些事情,可以么?</h3><p>Of course !!<br>各种路由器的钩子!! 传送门: <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">导航守卫</a>;</p><p>当然,记忆滚动的位置也可以做到,详情翻翻里面的文档</p><h3 id="Q-TypeError-xxx-is-not-a-function"><a href="#Q-TypeError-xxx-is-not-a-function" class="headerlink" title="Q:TypeError: xxx is not a function"></a>Q:TypeError: xxx is not a function</h3><p>这种问题明显就是写法有问题,能不能动点脑子!!</p><h3 id="Q-能不能跨级拿到props"><a href="#Q-能不能跨级拿到props" class="headerlink" title="Q: 能不能跨级拿到props"></a>Q: 能不能跨级拿到props</h3><p>这种情况是面向嵌套层次很深的组件，又要拿到上层的父传递的东东，</p><p>可以用$attrs 或者inject + provide来实现</p><h3 id="Q-Uncaught-ReferenceError-xxx-is-not-define"><a href="#Q-Uncaught-ReferenceError-xxx-is-not-define" class="headerlink" title="Q:Uncaught ReferenceError: xxx is not define"></a>Q:Uncaught ReferenceError: xxx is not define</h3><ul><li>实例内的 data 对应的变量没有声明</li><li>你导入模块报这个错误,那绝逼是导出没写好</li></ul><h3 id="Q-Error-in-render-function-”Type-Error-Cannot-read-property-‘xxx’-of-undefined”"><a href="#Q-Error-in-render-function-”Type-Error-Cannot-read-property-‘xxx’-of-undefined”" class="headerlink" title="Q:Error in render function:”Type Error: Cannot read property ‘xxx’ of undefined”"></a>Q:Error in render function:”Type Error: Cannot read property ‘xxx’ of undefined”</h3><p>这种问题大多都是初始化的姿势不对;</p><p>比如引入echart这些,仔细去了解下生命周期,再来具体初始化;</p><p>vue 组件有时候也会(嵌套组件或者 props传递初始化),也是基本这个问题</p><h3 id="Q-Unexpected-token-operator-xxxxx"><a href="#Q-Unexpected-token-operator-xxxxx" class="headerlink" title="Q:Unexpected token: operator xxxxx"></a>Q:Unexpected token: operator xxxxx</h3><p>大佬,这个一看就是语法错误啊.<br>基本都是符号问题.<br>一般报错会给出哪一行或者哪个组件</p><h3 id="Q-npm-run-build之后不能直接访问"><a href="#Q-npm-run-build之后不能直接访问" class="headerlink" title="Q:npm run build之后不能直接访问"></a>Q:npm run build之后不能直接访问</h3><p>大佬!你最起码得在本地搭个服务器才能访问好么!!</p><h3 id="Q-操作Vue的原型链好么"><a href="#Q-操作Vue的原型链好么" class="headerlink" title="Q: 操作Vue的原型链好么"></a>Q: 操作Vue的原型链好么</h3><p>这个问题需要具体情况具体分析；</p><p>我看很多人喜欢把axios挂载到Vue.prototype上；</p><p>这样做有一定的弊端，相当耦合，若是多人维护或者替换其他库的时候有一定困难；</p><p>比较好的做法是不挂载，而是单独有服务请求的文件，用函数来封装你所需要的接口聚合；</p><p>这样统一暴露函数名，而内部实现可以随便改动</p><h3 id="Q-CSSbackground引入图片打包后-访问路径错误"><a href="#Q-CSSbackground引入图片打包后-访问路径错误" class="headerlink" title="Q:CSSbackground引入图片打包后,访问路径错误"></a>Q:CSSbackground引入图片打包后,访问路径错误</h3><p>因为打包后图片是在根目录下,你用相对路径肯定报错啊,</p><p>你可以魔改 webpack 的配置文件里面的static为./static,但是不建议</p><p>你若是把图片什么丢到assets目录下,然后相对路径,打包后是正常的</p><h3 id="Q-安装模块时命令窗口输出unsupported-platform-xxx"><a href="#Q-安装模块时命令窗口输出unsupported-platform-xxx" class="headerlink" title="Q:安装模块时命令窗口输出unsupported platform xxx"></a>Q:安装模块时命令窗口输出unsupported platform xxx</h3><p>一般两种情况,node版本不兼容,系统不兼容;</p><p>解决方案: 要么不装,要么满足安装要求;</p><h3 id="Q-Unexpected-tab-charater这些"><a href="#Q-Unexpected-tab-charater这些" class="headerlink" title="Q:Unexpected tab charater这些"></a>Q:Unexpected tab charater这些</h3><p>一般是你用脚手架初始化的时候开了 eslint ;</p><p>要么遵循规则,要么改变规则;</p><p>要么直接把 webpack 里面的 eslint 检测给关闭了</p><h3 id="Q-Failed-to-mount-component-template-or-render-function-not-defined"><a href="#Q-Failed-to-mount-component-template-or-render-function-not-defined" class="headerlink" title="Q:Failed to mount component: template or render function not defined"></a>Q:Failed to mount component: template or render function not defined</h3><p>组件挂载失败,问题只有这么几个，组件没有正确引入或挂载点顺序错了。</p><h3 id="Q-Unknown-custom-element-did-you-register-the-component-correctly"><a href="#Q-Unknown-custom-element-did-you-register-the-component-correctly" class="headerlink" title="Q:Unknown custom element:  - did you register the component correctly?"></a>Q:Unknown custom element: <xxx> - did you register the component correctly?</xxx></h3><p>组件没有正确引入或者正确使用,依次确认</p><ol><li>导入对应的组件</li><li>在 components 内声明</li><li>在 dom 区域声明标签</li></ol><p>Q: 如何让自定义组件支持Vue.use使用呢<br>只要暴露一个install函数即可，大体可以看下以下代码；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BtnPopconfirm <span class="keyword">from</span> <span class="string">'./BtnPopconfirm.vue'</span>;</span><br><span class="line">BtnPopconfirm.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.component(BtnPopconfirm.name, BtnPopconfirm);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BtnPopconfirm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后就支持Vue.use了</span></span><br></pre></td></tr></table></figure><h3 id="Q-axios的-post-请求后台接受不到"><a href="#Q-axios的-post-请求后台接受不到" class="headerlink" title="Q: axios的 post 请求后台接受不到!"></a>Q: axios的 post 请求后台接受不到!</h3><p>axios默认是 json 格式提交,确认后台是否做了对应的支持;<br>若是只能接受传统的表单序列化,就需要自己写一个转义的方法,<br>当然还有一个更加省事的方案,装一个小模块qs</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install qs -S</span></span><br><span class="line"><span class="comment">// 然后在对应的地方转就行了,单一请求也行,拦截器也行,我是写在拦截器的.</span></span><br><span class="line"><span class="comment">// 具体可以看看我 axios 封装那篇文章</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//POST传参序列化(添加请求拦截器)</span></span><br><span class="line">Axios.interceptors.request.<span class="keyword">use</span>(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做某件事</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      config.method === <span class="string">"post"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 序列化</span></span><br><span class="line">      config.data = qs.stringify(config.data); <span class="comment">// ***** 这里转义</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若是有做鉴权token , 就给头部带上token</span></span><br><span class="line">    <span class="keyword">if</span> (localStorage.<span class="built_in">token</span>) &#123;</span><br><span class="line">      config.headers.Authorization = localStorage.<span class="built_in">token</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">error</span> =&gt; &#123;</span><br><span class="line">    Message(&#123;</span><br><span class="line">      <span class="comment">//  饿了么的消息弹窗组件,类似toast</span></span><br><span class="line">      showClose: true,</span><br><span class="line">      message: <span class="built_in">error</span>,</span><br><span class="line">      <span class="built_in">type</span>: <span class="string">"error.data.error.message"</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> Promise.reject(<span class="built_in">error</span>.data.<span class="built_in">error</span>.message);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Q-Vue支持jsx的写法么"><a href="#Q-Vue支持jsx的写法么" class="headerlink" title="Q: Vue支持jsx的写法么"></a>Q: Vue支持jsx的写法么</h3><p>可以很确定的告诉你，是支持的；</p><p>但是和React是有所差异的，而非完全等同的，具体可以看官方的支持库(<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">github.com/vuejs/jsx</a>)</p><h3 id="Q-Invalid-prop-type-check-failed-for-prop-“xxx”-Expected-Boolean-got-String"><a href="#Q-Invalid-prop-type-check-failed-for-prop-“xxx”-Expected-Boolean-got-String" class="headerlink" title="Q: Invalid prop: type check failed for prop “xxx”. Expected Boolean, got String."></a>Q: Invalid prop: type check failed for prop “xxx”. Expected Boolean, got String.</h3><p>这种问题一般就是组件内的 props 类型已经设置了接受的范围类型,</p><p>而你传递的值却又不是它需要的类型,写代码严谨些 OK?</p><h3 id="Q-过滤器可以用于DOM区域结合指令么"><a href="#Q-过滤器可以用于DOM区域结合指令么" class="headerlink" title="Q: 过滤器可以用于DOM区域结合指令么?"></a>Q: 过滤器可以用于DOM区域结合指令么?</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">// 不行,看下面的错误例子</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) in range | sortByDesc | spliceText"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// `vue2+`的指令只能用语 mustache`</span><span class="template-variable">&#123;&#123;&#125;&#125;</span><span class="xml">` , 正确姿势如下:</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="template-variable">&#123;&#123; message | capitalize &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="Q-Array-mapState-SOME-MUTATION-state-increment-commit-这种写法是什么鬼"><a href="#Q-Array-mapState-SOME-MUTATION-state-increment-commit-这种写法是什么鬼" class="headerlink" title="Q: [,Array],,mapState,[SOME_MUTATION] (state) {},increment ({ commit }) {}这种写法是什么鬼!"></a>Q: [,Array],,mapState,[SOME_MUTATION] (state) {},increment ({ commit }) {}这种写法是什么鬼!</h3><p>出门左拐,ES6+(ES2015+)的基础去过一遍,</p><p>上面依次:数组解构,对象解构,对象风格函数,对象解构赋值传递</p><h3 id="Q-我的-Vue-网站为什么-UC-访问一片空白亦或者flex布局错乱"><a href="#Q-我的-Vue-网站为什么-UC-访问一片空白亦或者flex布局错乱" class="headerlink" title="Q: 我的 Vue 网站为什么 UC 访问一片空白亦或者flex布局错乱!!"></a>Q: 我的 Vue 网站为什么 UC 访问一片空白亦或者flex布局错乱!!</h3><p>来来来,墙角走起,. UC 号称移动界的 IE 这称号不是白叫的</p><ul><li>flexbox 布局错乱,一般是你没有把兼容方案写上,就是带各种前缀,复合属性拆分，引入 autoprefixer, 写上兼容范围就好了.</li><li>UC访问空白, 有一种情况绝对会造成,那就是 ES6的代码降级不够彻底. 其他情况可能就是路由配置问题(自己去排除)</li><li>现在的开发都推荐按需引入,靠babel-preset-env 来控制,以达到打包体积减小.</li><li>但是这样做的后果,有些内核比较老的,嘿嘿,拜拜,</li><li>所以最好把代码完全 ES5话!!记住有些特性不能乱使用,没有对应的 polyfill,比如 ES6 的proxy</li></ul><h3 id="Q-this-set-this-xxx-这个-是个什么意思-是-jQuery的么-会冲突么"><a href="#Q-this-set-this-xxx-这个-是个什么意思-是-jQuery的么-会冲突么" class="headerlink" title="Q:this.$set | this.$xxx 这个 $ 是个什么意思?是 jQuery的么,会冲突么?"></a>Q:this.$set | this.$xxx 这个 $ 是个什么意思?是 jQuery的么,会冲突么?</h3><p>且看我细细道来.</p><p>Vue 的$和 jQuery 的$并没有半毛钱的关系,就跟javascript和java一样.</p><p>Vue 的$是封装了一些 vue 的内建函数,然后导出以$开头,这显然并不是 jQuery的专利;</p><p>jQuery 的$是选择器!!取得 DOM区域,两者的作用完全不一致!</p><h3 id="Q-Module-not-found-Error-Can’t-resolve-‘xxx-loader’-in-xxxx"><a href="#Q-Module-not-found-Error-Can’t-resolve-‘xxx-loader’-in-xxxx" class="headerlink" title="Q:Module not found: Error : Can’t resolve ‘xxx-loader’ in xxxx"></a>Q:Module not found: Error : Can’t resolve ‘xxx-loader’ in xxxx</h3><p>这里问题一般就是webpack的配置文件你改动了或对应的loader 没有装上</p><h3 id="Q-父组件可以直接调用子组件的方法么"><a href="#Q-父组件可以直接调用子组件的方法么" class="headerlink" title="Q: 父组件可以直接调用子组件的方法么!"></a>Q: 父组件可以直接调用子组件的方法么!</h3><p>可以,通过$refs或者$chilren来拿到对应的实例,从而操作</p><h3 id="Q-Error-in-event-handler-for-“click”-”xxx”"><a href="#Q-Error-in-event-handler-for-“click”-”xxx”" class="headerlink" title="Q:Error in event handler for “click”:”xxx”"></a>Q:Error in event handler for “click”:”xxx”</h3><p>这个问题大多都是你写的代码有问题.你的事件触发了.</p><p>但是组件内部缺少对应的实现或者变量,所以抛出事件错误.</p><p>解决方案:看着报错慢慢排查</p><h3 id="Q-组件的通讯有哪几种啊"><a href="#Q-组件的通讯有哪几种啊" class="headerlink" title="Q: 组件的通讯有哪几种啊!"></a>Q: 组件的通讯有哪几种啊!</h3><p>基本最常用的是这三种;</p><ol><li>父传子: props</li><li>子传父: emit</li><li>兄弟通讯:<ul><li>event bus: 就是找一个中间组件来作为信息传递中介</li><li>vuex: 信息树</li></ul></li></ol><p>传送门:</p><p>基本通讯<br><a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">Vuex</a></p><h3 id="Q-既然localStorage和sessionStorage能做到数据维护-为什么还要引入vuex"><a href="#Q-既然localStorage和sessionStorage能做到数据维护-为什么还要引入vuex" class="headerlink" title="Q:既然localStorage和sessionStorage能做到数据维护,为什么还要引入vuex!"></a>Q:既然localStorage和sessionStorage能做到数据维护,为什么还要引入vuex!</h3><p>这个问题问得好,Vuex的目的用来维护同级组件间的数据通讯,拥有一个共同的状态树;</p><p>仅仅活在SPA的里面的<strong>伪多页(路由)</strong>内,<br>这种东东明明然localStorage和sessionStorage</p><p>也可以做到,还能做到跨页面数据维护,还不会被浏览器刷新干掉,</p><p>为什么还要引入 vuex, 我个人觉得原因只有这么一个,”可维护性”和”易用性”及</p><p>怎么理解呢?</p><ul><li>可维护性: 因为是单向数据流,所有状态是有迹可循的,数据的传递也可以及时分发响应</li><li>易用性: 它使得我们组件间的通讯变得更强大,而不用借助中间件这类来实现不同组件间的通讯</li></ul><p>而且代码量不多,若是你要用 ls或者ss,你必须手动去跟踪维护你的状态表,<br>虽说可行,但是代码量会多很多,而且可读性很差,</p><p>是不是每个项目都需要用到vuex?</p><p>答案是否定的,小型项目上这个反而是累赘,这东西一般是用在中型项目+的,</p><p>因为里面涉及需要维护的数据比较多,同级组件间的通讯比较频繁</p><p>若是用到vuex的项目记得结合ss或者ls来达到某些状态持久化!为什么看下面!</p><h3 id="Q-vuex的用户信息为什么还要存一遍在浏览器里-sessionStorage或localStorage"><a href="#Q-vuex的用户信息为什么还要存一遍在浏览器里-sessionStorage或localStorage" class="headerlink" title="Q:vuex的用户信息为什么还要存一遍在浏览器里(sessionStorage或localStorage)"></a>Q:vuex的用户信息为什么还要存一遍在浏览器里(sessionStorage或localStorage)</h3><p><strong>因为 vuex的 store 刷新就没有.</strong><br>保存在浏览器的缓存内,若用户刷新的话,值再取一遍呗;</p><h3 id="Q-”有-Vue-Vue-Router-Vuex”或什么”express-vue-mongodb”的项目学习么"><a href="#Q-”有-Vue-Vue-Router-Vuex”或什么”express-vue-mongodb”的项目学习么" class="headerlink" title="Q:”有 Vue + Vue Router + Vuex”或什么”express + vue + mongodb”的项目学习么"></a>Q:”有 Vue + Vue Router + Vuex”或什么”express + vue + mongodb”的项目学习么</h3><p>Github 一搜一大堆,提这些问题的人动动脑子!.传送门:<a href="http://github.com/" target="_blank" rel="noopener">Github</a></p><h3 id="Q-我会-Vue-我还需要学习-jQuery-或者原生-JS-么"><a href="#Q-我会-Vue-我还需要学习-jQuery-或者原生-JS-么" class="headerlink" title="Q:我会 Vue 我还需要学习 jQuery 或者原生 JS 么"></a>Q:我会 Vue 我还需要学习 jQuery 或者原生 JS 么</h3><p>jQuery还有很多公司在用,源码可以学习的地方很多，框架只是加快开发,提高效率,但不是你在这一行长期立足的根本;</p><p>大佬们都是各种设计模式和算法玩的好，才能写出这么优秀的框架。</p><p>前端的人不仅需要宽度,也要深度,这样才能走的更远</p><h3 id="Q-npm-run-dev-报端口错误-Error-listen-EADDRINUSE-8080"><a href="#Q-npm-run-dev-报端口错误-Error-listen-EADDRINUSE-8080" class="headerlink" title="Q: npm run dev 报端口错误!Error: listen EADDRINUSE :::8080"></a>Q: npm run dev 报端口错误!Error: listen EADDRINUSE :::8080</h3><p>自己用 webpack搭脚手架的都不用我说了;<br>Vue-cli 里面的 webpack 配置: config/index.js</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dev:</span> &#123;</span><br><span class="line"><span class="symbol">    env:</span> require(<span class="string">"./dev.env"</span>),</span><br><span class="line"><span class="symbol">    port:</span> <span class="number">8080</span>, <span class="comment">//  这里这里,若是这个端口已经给系统的其他程序占用了.改我改我!!</span></span><br><span class="line"><span class="symbol">    autoOpenBrowser:</span> true,</span><br><span class="line"><span class="symbol">    assetsSubDirectory:</span> <span class="string">"static"</span>,</span><br><span class="line"><span class="symbol">    assetsPublicPath:</span> <span class="string">"/"</span>,</span><br><span class="line"><span class="symbol">    proxyTable:</span> &#123;</span><br><span class="line">      <span class="string">"/bp-api"</span>: &#123;</span><br><span class="line"><span class="symbol">        target:</span> <span class="string">"http://new.d.st.cn"</span>,</span><br><span class="line"><span class="symbol">        changeOrigin:</span> true,</span><br><span class="line">        <span class="comment">// pathRewrite: &#123;</span></span><br><span class="line">        <span class="comment">//   "^/bp-api": "/"</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Q-什么时候用v-if-什么用-v-show"><a href="#Q-什么时候用v-if-什么用-v-show" class="headerlink" title="Q: 什么时候用v-if,什么用 v-show!"></a>Q: 什么时候用v-if,什么用 v-show!</h3><p>我们先来说说两者的核心差异;</p><ul><li><p>v-if :  DOM 区域没有生成,没有插入文档,等条件成立的时候才动态插入到页面!</p><ul><li>有些需要遍历的数组对象或者值,最好用这货控制,等到拿到值才处理遍历,不然一些操作过快的情况会报错,比如数据还没请求到!</li></ul></li></ul><ul><li><p>v-show: DOM 区域在组件渲染的时候同时渲染了,只是单纯用 css 隐藏了</p><ul><li>对于下拉菜单,折叠菜单这些数据基本不怎么变动.用这个最合适了,而且可以改善用户体验,因为它不会导致页面的重绘,DOM 操作会!</li></ul></li></ul><p>简言之: DOM结构不怎么变化的用v-show, 数据需要改动很大或者布局改动的用v-if</p><h3 id="Q-是什么-html5的标签么"><a href="#Q-是什么-html5的标签么" class="headerlink" title="Q: 是什么,html5的标签么?"></a>Q: <template>是什么,html5的标签么?</template></h3><p>你猜对了,html5的标签还真有这么一个.传送门Can I Use:template</p><p>不过 Vue 的 template 有点不一样,不是去给浏览器解析的,</p><p>你可以理解为一个临时标签,用来方便你写循环,判断的,</p><p>因为最终 template 不会解析到浏览器的页面,他只是在 Vue 解析的过程充当一个包裹层!</p><p>最终我们看到的是内部处理后的组合的 DOM 结构!</p><h3 id="Q-Vue支持类似React的-props-吗"><a href="#Q-Vue支持类似React的-props-吗" class="headerlink" title="Q: Vue支持类似React的{,props}吗"></a>Q: Vue支持类似React的{,props}吗</h3><p>jsx的写法肯定是支持的，常规的写法也支持，用v-bind=”propsObject”会自动展开</p><h3 id="Q-Uncaught-ReferenceError-Vue-is-not-defined"><a href="#Q-Uncaught-ReferenceError-Vue-is-not-defined" class="headerlink" title="Q: Uncaught ReferenceError : Vue is not defined!"></a>Q: Uncaught ReferenceError : Vue is not defined!</h3><p>依次排除:</p><ul><li>Vue是否正确引入!</li><li>Vue是否正确实例化!</li><li>Vue 用的姿势是否正确(比如你直接一个 Vue 的变量!刚好又没定义,,具体问题具体分析吧)</li></ul><h3 id="Q-ERROR-in-static-js-xxxxxxx-js-from-UglifyJs"><a href="#Q-ERROR-in-static-js-xxxxxxx-js-from-UglifyJs" class="headerlink" title="Q: ERROR in static/js/xxxxxxx.js from UglifyJs"></a>Q: ERROR in static/js/xxxxxxx.js from UglifyJs</h3><p>我知道其中一种情况会报这种情况,就是你引入的 js,是直接引入压缩版本后的 js(xxx.min.js);</p><p>然后 webpack 内又启用了 UglifyJs(压缩 JS的), 二重压缩大多都会报错!!</p><p><strong>解决方案:引入标准未压缩的 JS</strong></p><h3 id="Q-props不使用-v-bind-可以传递值么"><a href="#Q-props不使用-v-bind-可以传递值么" class="headerlink" title="Q:props不使用:(v-bind)可以传递值么!"></a>Q:props不使用:(v-bind)可以传递值么!</h3><p>可以,只是默认传递的类型会被解析成字符串!</p><p>若是要传递其他类型,该绑定还是绑定!!</p><h3 id="Q-Uncaught-TypeError-Cannot-set-property-xxx-which-has-only-a-getter"><a href="#Q-Uncaught-TypeError-Cannot-set-property-xxx-which-has-only-a-getter" class="headerlink" title="Q: Uncaught TypeError : Cannot set property xxx which has only a getter"></a>Q: Uncaught TypeError : Cannot set property xxx which has only a getter</h3><p>这个问题就是你要操作的属性只允许 getter,不允许 setter;</p><p>解决方案? 用了别人的东西就要遵循别人的套路来,不然就只能自己动手丰衣足食了!!</p><h3 id="Q-单组件中里面的-import-xxx-from-‘-components-layout-xxx’中的-是什么鬼"><a href="#Q-单组件中里面的-import-xxx-from-‘-components-layout-xxx’中的-是什么鬼" class="headerlink" title="Q: 单组件中里面的 import xxx from ‘@/components/layout/xxx’中的@是什么鬼!"></a>Q: 单组件中里面的 import xxx from ‘@/components/layout/xxx’中的@是什么鬼!</h3><p>这是 webpack 方面的知识,看到了也说下吧,</p><p>webpack可以配置alias(也就是路径别名),玩过 linux 或者 mac 都知道</p><p>依旧如上,会自己搭脚手架的不用我说了,看看 vue-cli 里面的;</p><p>文件名: build -&gt; webpack.base.conf.js</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">resolve</span>: &#123;</span><br><span class="line">    <span class="attribute">extensions</span>: [<span class="string">".js"</span>, <span class="string">".vue"</span>, <span class="string">".json"</span>], // 可以导入的时候忽略的拓展名范围</span><br><span class="line">    alias: &#123;</span><br><span class="line">      vue$: <span class="string">"vue/dist/vue.esm.js"</span>,  </span><br><span class="line">      <span class="string">"@"</span>: <span class="built_in">resolve</span>(<span class="string">"src"</span>),  // 这里就是别名了,比如@就代表直接从/src 下开始找起!</span><br><span class="line">      <span class="string">"~"</span>: <span class="built_in">resolve</span>(<span class="string">"src/components"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Q-SCSS-SASS-还是-less-stylus-好"><a href="#Q-SCSS-SASS-还是-less-stylus-好" class="headerlink" title="Q: SCSS(SASS) 还是 less,stylus 好!!"></a>Q: SCSS(SASS) 还是 less,stylus 好!!</h3><p>三者都是预处理器;<br>scss 出现最久,能做的功能比较多,但是若是普通的嵌套写法,继承,mixin 啊</p><p>这三个都差不多,会其中一个其他两个的粗浅用法基本也会了.不过!!</p><p>写法有些差异:</p><ul><li>scss: 写法上是向 css 靠齐</li><li>sass : 其实也就是 scss , 只是写法不一样,靠的是缩进</li><li>less : 跟 css 基本靠齐</li><li>stylus : 一样,靠缩进,跟pug(Jade)一样</li></ul><p>使用环境的差异:</p><ul><li>scss 可以借助 ruby 或者 node-sass或者dart-sass 编译</li><li>less 可以用 less.js 或者对应的 loader 解析</li><li>stylus 只能借助 loader 解析,它的出现就是基于 node 的</li></ul><p>也有一个后起之秀,主打解耦,插件化的! 那就是PostCSS,这个是后处理器!<br>有兴趣的可以自行去了解,上面的写法都能借助插件实现!</p><h3 id="Q-Failed-to-compile-with-x-errors-This-dependency-was-not-found"><a href="#Q-Failed-to-compile-with-x-errors-This-dependency-was-not-found" class="headerlink" title="Q:Failed to compile with x errors : This dependency was not found !"></a>Q:Failed to compile with x errors : This dependency was not found !</h3><p>编译错误,对应的依赖没找到!</p><p>解决如下:</p><ul><li>知道缺少对应的模块,直接装进去</li><li>若是一个你已经安装的大模块(比如 axios)里面的子模块(依赖包)出了问题,卸载重装整个大模块.因为你补全不一定有用!</li></ul><h3 id="Q-SyntaxError-Unexpected-identifier"><a href="#Q-SyntaxError-Unexpected-identifier" class="headerlink" title="Q:SyntaxError: Unexpected identifier"></a>Q:SyntaxError: Unexpected identifier</h3><p>语法错误,看错误信息去找到对应的页面排查!</p><h3 id="Q-为什么我的-npm-或者-yarn-安装依赖会生成-lock文件-有什么用"><a href="#Q-为什么我的-npm-或者-yarn-安装依赖会生成-lock文件-有什么用" class="headerlink" title="Q: 为什么我的 npm 或者 yarn 安装依赖会生成 lock文件,有什么用!"></a>Q: 为什么我的 npm 或者 yarn 安装依赖会生成 lock文件,有什么用!</h3><p>lock 文件的作用是统一版本号,这对团队协作有很大的作用;</p><p>若是没有 lock 锁定,根据package.json里面的^,~这些,</p><p>不同人,不同时间安装出来的版本号不一定一致;</p><p>有些包甚至有一些breaking change(破坏性的更新),造成开发很难顺利进行!</p><h3 id="Q-组件可以缓存么"><a href="#Q-组件可以缓存么" class="headerlink" title="Q: 组件可以缓存么?"></a>Q: 组件可以缓存么?</h3><p><strong>可以,用keep-alive;</strong></p><p>不过是有代价的,占有内存会多了,所以无脑的缓存所有组件!别说性能好了,切换几次,<br>有些硬件 hold不住的,浏览器直接崩溃或者卡死,</p><p>所以keep-alive一般缓存都是一些列表页,不会有太多的操作,更多的只是结果集的更换,</p><p>给路由的组件meta增加一个标志位,结合v-if就可以按需加上缓存了!</p><h3 id="Q-package-json里面的dependencies-和devDependencies的差异"><a href="#Q-package-json里面的dependencies-和devDependencies的差异" class="headerlink" title="Q:package.json里面的dependencies 和devDependencies的差异!"></a>Q:package.json里面的dependencies 和devDependencies的差异!</h3><p>其实不严格的话,没有特别的差异;<br>若是严格,遵循官方的理解;</p><ul><li>dependencies : 存放线上或者业务能访问的核心代码模块,比如 vue,vue-router;</li><li>devDependencies: 处于开发模式下所依赖的开发模块,也许只是用来解析代码,转义代码,但是不产生额外的代码到生产环境, 比如什么babel-core这些</li></ul><p>如何把包安装到对应的依赖下呢?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> <span class="comment">--save xxxx // dependencies</span></span><br><span class="line">npm <span class="keyword">install</span> <span class="comment">--save-dev xxxx // devDependencies</span></span><br><span class="line"></span><br><span class="line">//也能用简易的写法(i:<span class="keyword">install</span>,-S:<span class="keyword">save</span>,-D:<span class="keyword">save</span>-dev)</span><br><span class="line"></span><br><span class="line">npm i -S xxxx // npm <span class="keyword">install</span> <span class="comment">--save xxxx</span></span><br><span class="line">npm i -D xxxx // npm <span class="keyword">install</span> <span class="comment">--save-dev xxxx</span></span><br></pre></td></tr></table></figure><h3 id="Q-安装chromedriver报错-姿势没错啊npm-i-D-chromedriver"><a href="#Q-安装chromedriver报错-姿势没错啊npm-i-D-chromedriver" class="headerlink" title="Q: 安装chromedriver报错!!姿势没错啊npm i -D chromedriver"></a>Q: 安装chromedriver报错!!姿势没错啊npm i -D chromedriver</h3><p>恩,伟大的 GFW,,解决方案:指定国内的源安装就可以了</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="params">--save-dev</span> chromedriver <span class="params">--chromedriver_cdnurl=http</span>:<span class="string">//cdn.npm.taobao.org/dist/chromedriver</span></span><br></pre></td></tr></table></figure><h3 id="Q-Vue-React-Angular学习哪个好-哪个工作比较好找"><a href="#Q-Vue-React-Angular学习哪个好-哪个工作比较好找" class="headerlink" title="Q:Vue ,React, Angular学习哪个好?哪个工作比较好找!"></a>Q:Vue ,React, Angular学习哪个好?哪个工作比较好找!</h3><p>Vue属于渐进式开发,传统开发过渡 MVVM 模式的小伙伴,Vue 比较好上手,学习成本比较低<br>基础比较好的,有折腾精神的,可以选择NG5或者React 16;</p><p>NG5需要学习typescript和rxjs,还用到比较多的新东西,比如装饰器,后端的注入概念.ng有自己的一整套 MVVM 流程;</p><p>而Vue和React核心只是view,可以搭配自己喜欢的</p><p>React的写法偏向函数式写法,还有 jsx,官方自己有 flow,当然也能搭配ts,我也没怎么接触,所以也有一定的学习成本;</p><p>至于哪个比较好找工作!告诉你,若是只会一个框架,那不是一个合格的前端;</p><p>人家要的是动手能力,解决能力!!技术和待遇是成正比的!!</p><p>颜值和背景,学历,口才可以加分,但是这些条件你必须要有的基础下才能考虑这些!</p><h3 id="Q-我有个复杂组件需要有新增和编辑的功能同时存在-但是字段要保持不变性怎么破"><a href="#Q-我有个复杂组件需要有新增和编辑的功能同时存在-但是字段要保持不变性怎么破" class="headerlink" title="Q: 我有个复杂组件需要有新增和编辑的功能同时存在,但是字段要保持不变性怎么破"></a>Q: 我有个复杂组件需要有新增和编辑的功能同时存在,但是字段要保持不变性怎么破</h3><p>字段保持不变性怎么理解呢? 就是说比如新增和编辑同时共享一份 data;</p><p>有一种就是路由变了,组件渲染同一个(不引起组件的重新渲染和销毁!),但是功能却不同(新增和编译),</p><p>比如从编辑切到新增,data必须为空白没有赋值的,等待我们去赋值;</p><p>这时候有个东西就特别适合了,那就是<a href="https://immutable-js.github.io/immutable-js/" target="_blank" rel="noopener">immutable-js</a>;</p><p>这个东西可以模拟数据的唯一性!或者叫做不变性!</p><h3 id="Q-”首屏加载比较慢-怎么破-打包文件文件比较大”"><a href="#Q-”首屏加载比较慢-怎么破-打包文件文件比较大”" class="headerlink" title="Q:”首屏加载比较慢!!怎么破!打包文件文件比较大”"></a>Q:”首屏加载比较慢!!怎么破!打包文件文件比较大”</h3><p>依次排除和确认:</p><ul><li>减少第三方库的使用,比如jquey这些都可以不要了,很少操作 dom,而且原生基本满足开发</li><li>若是引入moment这些,webpack 排除国际化语言包</li><li>webpack 常规压缩js,css, 愿意折腾的还可以引入 dll 这些</li><li>路由组件采用懒加载</li><li>加入路由过渡和加载等待效果,虽然不能解决根本,但起码让人等的舒心一点不是么!</li></ul><p>整体下来,打包之后一般不会太大;</p><p>但是倘若想要更快?那就只能采用服务端渲染(SSR)了,可以避免浏览器去解析模板和指令这些; 直接返回一个 html ,.还能 SEO,</p><p><strong>Vue你们如何做spa的模块懒加载呢</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐这种写法</span></span><br><span class="line"><span class="comment">// 一来可以聚合webpackChunkName名字一样的为一个模块，也是当前版本推荐的加载姿势</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span><span class="keyword">import</span>(<span class="string">"HomePage"</span>);</span><br></pre></td></tr></table></figure><h3 id="Q-Vue-SPA-没法做优化-SEO-有解决方案么"><a href="#Q-Vue-SPA-没法做优化-SEO-有解决方案么" class="headerlink" title="Q: Vue SPA 没法做优化(SEO)!有解决方案么"></a>Q: Vue SPA 没法做优化(SEO)!有解决方案么</h3><p>可以的,ssr(服务端渲染就能满足你的需求),因为请求回来就是一个处理完毕的 html</p><p>现在 vue 的服务端开发框架有这么个比较流行,如下</p><p>传送门:<a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">Nuxt.js</a></p><p>也有官方的方案,<a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">ssr 完全指南</a></p><h3 id="Q-Vue可以写-hybird-App-么"><a href="#Q-Vue可以写-hybird-App-么" class="headerlink" title="Q: Vue可以写 hybird App 么!"></a>Q: Vue可以写 hybird App 么!</h3><p>当然可以,两个方向.</p><ul><li><a href="https://github.com/nativescript-vue/nativescript-vue" target="_blank" rel="noopener">codorva + nativescript</a></li><li><a href="https://weex.apache.org/" target="_blank" rel="noopener">Weex</a></li></ul><h3 id="Q-Vue-可以写桌面端么"><a href="#Q-Vue-可以写桌面端么" class="headerlink" title="Q: Vue 可以写桌面端么?"></a>Q: Vue 可以写桌面端么?</h3><p>当然可以,有electron和node-webkit(nw);</p><p>我只了解过electron;</p><ul><li><a href="https://www.electronjs.org/" target="_blank" rel="noopener">electron</a></li><li><a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>: Vue-cli 针对 electron 的脚手架模板</li></ul><h3 id="Q-Vue开发-项目中还需要-jQuery么"><a href="#Q-Vue开发-项目中还需要-jQuery么" class="headerlink" title="Q: Vue开发,项目中还需要 jQuery么"></a>Q: Vue开发,项目中还需要 jQuery么</h3><p>分情况探讨:</p><ol><li>若是老项目,只是单纯引入 Vue 简化开发的,依旧用吧,</li><li>重构项目?或者发起新项目的,真心没必要了.开发思路不一样,很多以前用 DOM 操作的现在基本可以数据驱动实现,而少量迫不得已的DOM 操作原生就能搞定,而且能减小打包体积,速度又快,何乐而不为!</li></ol><h3 id="Q-Vue-PC-桌面-端-M-mobile-移动-端-用什么-UI-框架好啊"><a href="#Q-Vue-PC-桌面-端-M-mobile-移动-端-用什么-UI-框架好啊" class="headerlink" title="Q:Vue PC(桌面)端,M(mobile:移动)端,用什么 UI 框架好啊!"></a>Q:Vue PC(桌面)端,M(mobile:移动)端,用什么 UI 框架好啊!</h3><p>PC: 推荐的只有两个 element UI和iview</p><p>mobile : Vux、Vant</p><h3 id="Q-Vue可以写微信小程序么-怎么搞起"><a href="#Q-Vue可以写微信小程序么-怎么搞起" class="headerlink" title="Q: Vue可以写微信小程序么,怎么搞起"></a>Q: Vue可以写微信小程序么,怎么搞起</h3><p>可以的,社区也有人出了对应的解决方案,uniapp;</p><ul><li><a href="https://uniapp.dcloud.io/" target="_blank" rel="noopener">uniapp</a></li></ul><h3 id="Q-the-“scope”-attribute-for-scoped-slots-replaced-by-“slot-scope”-since-2-5"><a href="#Q-the-“scope”-attribute-for-scoped-slots-replaced-by-“slot-scope”-since-2-5" class="headerlink" title="Q:the “scope” attribute for scoped slots replaced by “slot-scope” since 2.5"></a>Q:the “scope” attribute for scoped slots replaced by “slot-scope” since 2.5</h3><p>这个问题只出现老项目升级到 vue2.5+的时候, 提示就是 scope 现在要用 slot-scope 来代替,<br>但是 scope 暂时可以用,以后会移除</p><h3 id="Q-Vue-2-6废除的特性清单"><a href="#Q-Vue-2-6废除的特性清单" class="headerlink" title="Q:Vue 2.6废除的特性清单"></a>Q:Vue 2.6废除的特性清单</h3><p>自 2.6.0 起有所更新。已废弃的使用 slot 特性的语法在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener">这里</a><br>官方推荐用v-slot来调用插槽</p><h3 id="Q-想要-mock-数据-直接请求-json文件-为什么不行"><a href="#Q-想要-mock-数据-直接请求-json文件-为什么不行" class="headerlink" title="Q:想要 mock 数据,直接请求 json文件 为什么不行!"></a>Q:想要 mock 数据,直接请求 json文件 为什么不行!</h3><p>当然不行,浏览器安全机制不允许,JS天生不能越权(NodeJS不能单纯说是JS)</p><p>你要 mock 数据,一般都有比较成熟的方案传送门:</p><ul><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">Mock</a></li><li><a href="https://github.com/easy-mock/easy-mock" target="_blank" rel="noopener">Easy Mock</a></li></ul><h2 id="Vue-周边库汇总"><a href="#Vue-周边库汇总" class="headerlink" title="Vue 周边库汇总"></a>Vue 周边库汇总</h2><p><a href="https://github.com/vuejs/awesome-vue" target="_blank" rel="noopener">Awesome Vue </a>: 里面收集了 Vue 方方面面的热门库!!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;文章内容覆盖范围,芝麻绿豆的破问题都有,不止于vue;&lt;br&gt;给出的是方案,而非手把手一字一句的给你说十万个为什么!&lt;/p&gt;
&lt;h2 id=&quot;问题汇总&quot;&gt;&lt;a href=&quot;#问题汇总&quot; class=&quot;headerlink&quot; title=&quot;问题汇总&quot;&gt;&lt;/a&gt;问题汇总&lt;/h2&gt;&lt;h3 id=&quot;Q-安装超时-install-timeout&quot;&gt;&lt;a href=&quot;#Q-安装超时-install-timeout&quot; class=&quot;headerlink&quot; title=&quot;Q:安装超时(install timeout)&quot;&gt;&lt;/a&gt;Q:安装超时(install timeout)&lt;/h3&gt;&lt;p&gt;方案有这么些:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;cnpm : 国内对npm的镜像版本&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="https://chongdee.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://chongdee.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli4+webpack4移动端框架</title>
    <link href="https://chongdee.github.io/2021/05/09/Webpack/vue-cli4+webpack4%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>https://chongdee.github.io/2021/05/09/Webpack/vue-cli4+webpack4移动端框架/</id>
    <published>2021-05-08T17:16:10.291Z</published>
    <updated>2021-07-20T08:39:30.230Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是基于 vue-cli4 实现的移动端框架，其中包含项目常用的配置，组件封装及webpack优化方法，可供快速开发使用。</p><p>技术栈：vue-cli4 + webpack4 + vant + axios + less + postcss-px2rem</p><p>源码 <a href="https://github.com/Michael-lzg/vue-cli4-vant" target="_blank" rel="noopener">https://github.com/Michael-lzg/vue-cli4-vant</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地启动</span></span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产打包</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><a id="more"></a><p>在一两年前，vue-cli3已经声驾到3.0+版本，但是由于旧项目一致习惯于vue-cli2的脚手架的使用，之前也写过一篇 <a href="https://juejin.im/post/5db806b1f265da4d5133485a" target="_blank" rel="noopener">搭建一个vue-cli的移动端H5开发模板</a> 简单总结了一点移动端的开发技巧。  </p><p>近日升级vue-cli脚手架才发现，这已经升级到4.0+版本了，觉得很多必要在新的项目中使用vue-cli4进行开发，加上近来对webpack有了进一步理解，所以结合了vue-cli4和webpack搭建了一个移动端框架，以便开箱即用。 主要包括如下技术点：</p><ul><li>vue-cli4脚手架</li><li>vant按需引入</li><li>移动端rem适配</li><li>axios拦截封装</li><li>util工具类函数封装</li><li>vue-router配置</li><li>登录权限校验</li><li>多环境变量配置</li><li>vue.config.js配置</li><li>toast组件封装</li><li>dialog组件封装</li><li>跨域代理设置</li><li>webpack打包可视化分析</li><li>CDN资源优化</li><li>gzip打包优化</li><li>首页添加骨架屏</li></ul><p>关于更多的webpack优化方法，可参考 <a href="https://github.com/Michael-lzg/webpack-vue-cli" target="_blank" rel="noopener">https://github.com/Michael-lzg/webpack-vue-cli</a></p><h2 id="配置-vant"><a href="#配置-vant" class="headerlink" title="配置 vant"></a>配置 vant</h2><p>vant 是一套轻量、可靠的移动端 Vue 组件库，非常适合基于 vue 技术栈的移动端开发。在过去很长的一段时间内，本人用的移动端 UI 框架都是 vux。后来由于 vux 不支持 vue-cli3，就转用了 vant，不得不说，无论是在交互体验上，还是代码逻辑上，vant 都比 vux 好很多，而且 vant 的坑比较少。</p><p>对于第三方 UI 组件，如果是全部引入的话，比如会造成打包体积过大，加载首页白屏时间过长的问题，所以按需加载非常必要。vant 也提供了按需加载的方法。<code>babel-plugin-import</code> 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。</p><p>1、安装依赖</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> i babel-plugin-<span class="keyword">import</span> -D</span><br></pre></td></tr></table></figure><p>2、配置 .babelrc 或者 babel.config.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在.babelrc 中添加配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>, &#123;</span><br><span class="line">      <span class="string">"libraryName"</span>: <span class="string">"vant"</span>,</span><br><span class="line">      <span class="string">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">      <span class="string">"style"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于使用 babel7 的用户，可以在 babel.config.js 中配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [<span class="string">'import'</span>, &#123;</span><br><span class="line">      libraryName: <span class="string">'vant'</span>,</span><br><span class="line">      libraryDirectory: <span class="string">'es'</span>,</span><br><span class="line">      style: <span class="literal">true</span></span><br><span class="line">    &#125;, <span class="string">'vant'</span>]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、按需引入</p><p>你可以在代码中直接引入 Vant 组件，插件会自动将代码转化为方式二中的按需引入形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'vant'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br></pre></td></tr></table></figure><h2 id="rem-适配"><a href="#rem-适配" class="headerlink" title="rem 适配"></a>rem 适配</h2><p>移动端适配是开发过程中不得不面对的事情。在此，我们使用 postcss 中的 px2rem-loader，将我们项目中的 px 按一定比例转化 rem，这样我们就可以对着蓝湖上的标注写 px 了。</p><p>我们将 html 字跟字体设置为 100px，很多人选择设置为 375px，但是我觉得这样换算出来的 rem 不够精确，而且我们在控制台上调试代码的时候无法很快地口算得出它本来的 px 值。如果设置 1rem=100px，这样我们看到的 0.16rem，0.3rem 就很快得算出原来是 16px，30px 了。</p><p>具体步骤如下；</p><p>1、安装依赖</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install px2rem-loader --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>2、在 vue.config.js 进行如下配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">css: &#123;</span><br><span class="line">  <span class="comment">// css预设器配置项</span></span><br><span class="line">  loaderOptions: &#123;</span><br><span class="line">    postcss: &#123;</span><br><span class="line">      plugins: [</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'postcss-px2rem'</span>)(&#123;</span><br><span class="line">          remUnit: <span class="number">100</span></span><br><span class="line">        &#125;)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3、在 main.js 设置 html 跟字体大小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initRem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cale = <span class="built_in">window</span>.screen.availWidth &gt; <span class="number">750</span> ? <span class="number">2</span> : <span class="built_in">window</span>.screen.availWidth / <span class="number">375</span></span><br><span class="line">  <span class="built_in">window</span>.document.documentElement.style.fontSize = <span class="string">`<span class="subst">$&#123;<span class="number">100</span> * cale&#125;</span>px`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  initRem()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="axios-请求封装"><a href="#axios-请求封装" class="headerlink" title="axios 请求封装"></a>axios 请求封装</h2><p>1、设置请求拦截和响应拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PRODUCT_URL = <span class="string">'https://xxxx.com'</span></span><br><span class="line"><span class="keyword">const</span> MOCK_URL = <span class="string">'http://xxxx.com'</span></span><br><span class="line"><span class="keyword">let</span> http = axios.create(&#123;</span><br><span class="line">  baseURL: process.env.NODE_ENV === <span class="string">'production'</span> ? PRODUCT_URL : MOCK_URL,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">http.interceptors.request.use(</span><br><span class="line">  (config) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 设置token，Content-Type</span></span><br><span class="line">    <span class="keyword">var</span> token = sessionStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">    config.headers[<span class="string">'token'</span>] = token</span><br><span class="line">    config.headers[<span class="string">'Content-Type'</span>] = <span class="string">'application/json;charset=UTF-8'</span></span><br><span class="line">    <span class="comment">// 请求显示loading效果</span></span><br><span class="line">    <span class="keyword">if</span> (config.loading === <span class="literal">true</span>) &#123;</span><br><span class="line">      vm.$loading.show()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    vm.$loading.hide()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">http.interceptors.response.use(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    vm.$loading.hide()</span><br><span class="line">    <span class="comment">// token失效，重新登录</span></span><br><span class="line">    <span class="keyword">if</span> (res.data.code === <span class="number">401</span>) &#123;</span><br><span class="line">      <span class="comment">//  重新登录</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  (error) =&gt; &#123;</span><br><span class="line">    vm.$loading.hide()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2、封装 get 和 post 请求方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, data, lodaing</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    http</span><br><span class="line">      .get(url)</span><br><span class="line">      .then(</span><br><span class="line">        (response) =&gt; &#123;</span><br><span class="line">          resolve(response)</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">post</span>(<span class="params">url, data, loading</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    http</span><br><span class="line">      .post(url, data, &#123; <span class="attr">loading</span>: loading &#125;)</span><br><span class="line">      .then(</span><br><span class="line">        (response) =&gt; &#123;</span><br><span class="line">          resolve(response)</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; get, post &#125;</span><br></pre></td></tr></table></figure><p>3、把 get，post 方法挂载到 vue 实例上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; get, post &#125; <span class="keyword">from</span> <span class="string">'./js/ajax'</span></span><br><span class="line">Vue.prototype.$http = &#123; get, post &#125;</span><br></pre></td></tr></table></figure><h2 id="工具类函数封装"><a href="#工具类函数封装" class="headerlink" title="工具类函数封装"></a>工具类函数封装</h2><p>1、添加方法到 vue 实例的原型链上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install (Vue, options) &#123;</span><br><span class="line">    Vue.prototype.util = &#123;</span><br><span class="line">      method1(val) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">      method2 (val) &#123;</span><br><span class="line">       ...</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在 main.js 通过 vue.use()注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./js/utils'</span></span><br><span class="line">Vue.use(utils)</span><br></pre></td></tr></table></figure><h2 id="vue-router-配置"><a href="#vue-router-配置" class="headerlink" title="vue-router 配置"></a>vue-router 配置</h2><p>平时很多人对 vue-router 的配置可配置了 path 和 component，实现了路由跳转即可。其实 vue-router 可做的事情还有很多，比如</p><ul><li>路由懒加载配置</li><li>改变单页面应用的 title</li><li>登录权限校验</li><li>页面缓存配置</li></ul><h4 id="路由懒加载配置"><a href="#路由懒加载配置" class="headerlink" title="路由懒加载配置"></a>路由懒加载配置</h4><p>Vue 项目中实现路由按需加载（路由懒加载）的 3 种方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、Vue异步组件技术：</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="string">'Home'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> reqire([<span class="string">'../views/Home.vue'</span>], resolve)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、es6提案的import()</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  name: <span class="string">'home'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、webpack提供的require.ensure()</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="string">'Home'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],() =&gt;  r(<span class="built_in">require</span>(<span class="string">'../views/Home.vue'</span>)), <span class="string">'home'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本项目采用的是第二种方式，为了后续 webpack 打包优化。</p><h4 id="改变单页面应用的-title"><a href="#改变单页面应用的-title" class="headerlink" title="改变单页面应用的 title"></a>改变单页面应用的 title</h4><p>由于单页面应用只有一个 html，所有页面的 title 默认是不会改变的，但是我们可以才路由配置中加入相关属性，再在路由守卫中通过 js 改变页面的 title</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="登录权限校验"><a href="#登录权限校验" class="headerlink" title="登录权限校验"></a>登录权限校验</h4><p>在应用中，通常会有以下的场景，比如商城：有些页面是不需要登录即可访问的，如首页，商品详情页等，都是用户在任何情况都能看到的；但是也有是需要登录后才能访问的，如个人中心，购物车等。此时就需要对页面访问进行控制了。</p><p>此外，像一些需要记录用户信息和登录状态的项目，也是需要做登录权限校验的，以防别有用心的人通过直接访问页面的 url 打开页面。</p><p>此时。路由守卫可以帮助我们做登录校验。具体如下：</p><p>1、配置路由的 meta 对象的 auth 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>),</span><br><span class="line">    meta: &#123; <span class="attr">title</span>: <span class="string">'首页'</span>, <span class="attr">keepAlive</span>: <span class="literal">false</span>, <span class="attr">auth</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/mine'</span>,</span><br><span class="line">    name: <span class="string">'mine'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/mine.vue'</span>),</span><br><span class="line">    meta: &#123; <span class="attr">title</span>: <span class="string">'我的'</span>, <span class="attr">keepAlive</span>: <span class="literal">false</span>, <span class="attr">auth</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>2、在路由首页进行判断。当<code>to.meta.auth</code>为<code>true</code>(需要登录)，且不存在登录信息缓存时，需要重定向去登录页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">  <span class="keyword">const</span> userInfo = sessionStorage.getItem(<span class="string">'userInfo'</span>) || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (!userInfo &amp;&amp; to.meta.auth) &#123;</span><br><span class="line">    next(<span class="string">'/login'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="页面缓存配置"><a href="#页面缓存配置" class="headerlink" title="页面缓存配置"></a>页面缓存配置</h4><p>项目中，总有一些页面我们是希望加载一次就缓存下来的，此时就用到 keep-alive 了。keep-alive 是 Vue 提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在 v 页面渲染完毕后不会被渲染成一个 DOM 元素。</p><p>1、通过配置路由的 meta 对象的 keepAlive 属性值来区分页面是否需要缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/Home.vue'</span>),</span><br><span class="line">    meta: &#123; <span class="attr">title</span>: <span class="string">'首页'</span>, <span class="attr">keepAlive</span>: <span class="literal">false</span>, <span class="attr">auth</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/list'</span>,</span><br><span class="line">    name: <span class="string">'list'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../views/list.vue'</span>),</span><br><span class="line">    meta: &#123; <span class="attr">title</span>: <span class="string">'列表页'</span>, <span class="attr">keepAlive</span>: <span class="literal">true</span>, <span class="attr">auth</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>2、在 app.vue 做缓存判断</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"!$route.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"$route.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="多环境变量配置"><a href="#多环境变量配置" class="headerlink" title="多环境变量配置"></a>多环境变量配置</h2><p>首先我们先来了解一下环境变量，一般情况下我们的项目会有三个环境，本地环境(development)，测试环境(test)，生产环境(production)，我们可以在项目根目录下建三个配置环境变量的文件<code>.env.development</code>，<code>.env.test</code>，<code>.env.production</code></p><p>环境变量文件中只包含环境变量的“键=值”对：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = <span class="string">'production'</span></span><br><span class="line">VUE_APP_ENV = <span class="string">'production'</span> <span class="comment">// 只有VUE_APP开头的环境变量可以在项目代码中直接使用</span></span><br></pre></td></tr></table></figure><p>除了自定义的 VUE<em>APP</em>*变量之外，还有两个可用的变量：</p><ul><li>NODE_ENV : “development”、”production” 或 “test”中的一个。具体的值取决于应用运行的模式。</li><li>BASE_URL : 和 vue.config.js 中的 publicPath 选项相符，即你的应用会部署到的基础路径。</li></ul><p>下面开始配置我们的环境变量</p><p>1、在项目根目录中新建.env.*</p><ul><li>.env.development 本地开发环境配置</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NODE_ENV</span>=<span class="string">'development'</span></span><br><span class="line"><span class="attr">VUE_APP_ENV</span> = <span class="string">'development'</span></span><br></pre></td></tr></table></figure><ul><li>env.staging 测试环境配置</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NODE_ENV</span>=<span class="string">'production'</span></span><br><span class="line"><span class="attr">VUE_APP_ENV</span> = <span class="string">'staging'</span></span><br></pre></td></tr></table></figure><ul><li>env.production 正式环境配置</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NODE_ENV</span>=<span class="string">'production'</span></span><br><span class="line"><span class="attr">VUE_APP_ENV</span> = <span class="string">'production'</span></span><br></pre></td></tr></table></figure><p>为了在不同环境配置更多的变量，我们在 src 文件下新建一个 config/index</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据环境引入不同配置 process.env.NODE_ENV</span></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./env.'</span> + process.env.VUE_APP_ENV)</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><p>在同级目录下新建 <code>env.development.js</code>，<code>env.test.js</code>，<code>env.production.js</code>，在里面配置需要的变量。<br>以 env.development.js 为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  baseUrl: <span class="string">'http://localhost:8089'</span>, <span class="comment">// 项目地址</span></span><br><span class="line">  baseApi: <span class="string">'https://www.mock.com/api'</span>, <span class="comment">// 本地api请求地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、配置打包命令</p><p>package.json 里的 scripts 不同环境的打包命令</p><ul><li>通过 npm run serve 启动本地</li><li>通过 npm run test 打包测试</li><li>通过 npm run build 打包正式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"vue-cli-service serve"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"vue-cli-service build"</span>,</span><br><span class="line">  <span class="string">"test"</span>: <span class="string">"vue-cli-service build --mode test"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue-config-js-配置"><a href="#vue-config-js-配置" class="headerlink" title="vue.config.js 配置"></a>vue.config.js 配置</h2><p>vue-cli3 开始，新建的脚手架都需要我们在 vue.config.js 配置我们项目的东西。主要包括</p><ul><li>打包后文件输出位置</li><li>关闭生产环境 sourcemap</li><li>配置 rem 转化 px</li><li>配置 alias 别名</li><li>去除生产环境 console</li><li>跨域代理设置</li></ul><p>此外，还有很多属于优化打包的配置，后面会一一道来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">'./'</span>, <span class="comment">// 默认为'/'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将构建好的文件输出到哪里，本司要求</span></span><br><span class="line">  outputDir: <span class="string">'dist/static'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 放置生成的静态资源(js、css、img、fonts)的目录。</span></span><br><span class="line">  assetsDir: <span class="string">'static'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定生成的 index.html 的输出路径</span></span><br><span class="line">  indexPath: <span class="string">'index.html'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否使用包含运行时编译器的 Vue 构建版本。</span></span><br><span class="line">  runtimeCompiler: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  transpileDependencies: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果你不需要生产环境的 source map</span></span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置css</span></span><br><span class="line">  css: &#123;</span><br><span class="line">    <span class="comment">// 是否使用css分离插件 ExtractTextPlugin</span></span><br><span class="line">    extract: <span class="literal">true</span>,</span><br><span class="line">    sourceMap: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// css预设器配置项</span></span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">          <span class="built_in">require</span>(<span class="string">'postcss-px2rem'</span>)(&#123;</span><br><span class="line">            remUnit: <span class="number">100</span>,</span><br><span class="line">          &#125;),</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 启用 CSS modules for all css / pre-processor files.</span></span><br><span class="line">    modules: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是一个函数，允许对内部的 webpack 配置进行更细粒度的修改。</span></span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 配置别名</span></span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(<span class="string">'@'</span>, resolve(<span class="string">'src'</span>))</span><br><span class="line">      .set(<span class="string">'assets'</span>, resolve(<span class="string">'src/assets'</span>))</span><br><span class="line">      .set(<span class="string">'components'</span>, resolve(<span class="string">'src/components'</span>))</span><br><span class="line">      .set(<span class="string">'views'</span>, resolve(<span class="string">'src/views'</span>))</span><br><span class="line"></span><br><span class="line">    config.optimization.minimizer(<span class="string">'terser'</span>).tap(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 去除生产环境console</span></span><br><span class="line">      args[<span class="number">0</span>].terserOptions.compress.drop_console = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> args</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。</span></span><br><span class="line">  parallel: <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length &gt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    port: <span class="number">8088</span>, <span class="comment">// 端口号</span></span><br><span class="line">    https: <span class="literal">false</span>, <span class="comment">// https:&#123;type:Boolean&#125;</span></span><br><span class="line">    open: <span class="literal">false</span>, <span class="comment">// 配置自动启动浏览器  open: 'Google Chrome'-默认启动谷歌</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置多个代理</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'https://www.mock.com'</span>,</span><br><span class="line">        ws: <span class="literal">true</span>, <span class="comment">// 代理的WebSockets</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>, <span class="comment">// 允许websockets跨域</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础组件封装"><a href="#基础组件封装" class="headerlink" title="基础组件封装"></a>基础组件封装</h2><p>在开发项目过程中，通常会用到很多功能和设计相类似的组件，toast 和 dialog 组件基本是每一个移动端项目都会用到的。为了更好匹配自己公司的 UI 设计风格，我们没有直接用 vant 的 toast 和 dialog 组件，而是自己封装了类似的组件，可供直接调用，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$toast(&#123; <span class="attr">msg</span>: <span class="string">'手机号码不能为空'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$toast(&#123;</span><br><span class="line">  msg: <span class="string">'成功提示'</span>,</span><br><span class="line">  type: <span class="string">'success'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$dialog(&#123;</span><br><span class="line">  title: <span class="string">'删除提示'</span>,</span><br><span class="line">  text: <span class="string">'是否确定删除此标签？'</span>,</span><br><span class="line">  showCancelBtn: <span class="literal">true</span>,</span><br><span class="line">  confirmText: <span class="string">'确认'</span>,</span><br><span class="line">  confirm(content) &#123;</span><br><span class="line">    alert(<span class="string">'删除成功'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果图如下</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/10/171fc7862c4a065f?w=1032&amp;h=523&amp;f=png&amp;s=70452" alt=""></p><h4 id="toast-传入参数"><a href="#toast-传入参数" class="headerlink" title="toast 传入参数"></a>toast 传入参数</h4><p><strong>Props</strong></p><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody><tr><td>msg</td><td>String</td><td>‘’</td><td>弹窗提示语</td></tr><tr><td>type</td><td>String</td><td>‘’</td><td>弹窗类型：success(成功提示),fail(失败提示),warning(警告),loading(加载)</td></tr></tbody></table><h4 id="dialog-传入参数"><a href="#dialog-传入参数" class="headerlink" title="dialog 传入参数"></a>dialog 传入参数</h4><p><strong>Props</strong></p><table><thead><tr><th>name</th><th>type</th><th>default</th><th>description</th></tr></thead><tbody><tr><td>title</td><td>String</td><td>‘’</td><td>标题</td></tr><tr><td>text</td><td>String</td><td>‘’</td><td>文本内容</td></tr><tr><td>type</td><td>String</td><td>‘’</td><td>默认纯文本，input(输入框)</td></tr><tr><td>maxlength</td><td>Number</td><td>20</td><td>输入的最多字数</td></tr><tr><td>confirmText</td><td>String</td><td>确定</td><td>右边按钮</td></tr><tr><td>cancelText</td><td>String</td><td>取消</td><td>左边按钮</td></tr></tbody></table><p><strong>Events</strong></p><table><thead><tr><th>name</th><th>params</th><th>description</th></tr></thead><tbody><tr><td>confirm</td><td>null</td><td>选择后的回调</td></tr><tr><td>cancel</td><td>ull</td><td>取消后的回调</td></tr></tbody></table><h2 id="webpack-可视化分析"><a href="#webpack-可视化分析" class="headerlink" title="webpack 可视化分析"></a>webpack 可视化分析</h2><p>从这里开始，我们开始进行 webpack 优化打包。首先我们来分析一下 webpack 打包性能瓶颈，找出问题所在，然后才能对症下药。此时就用到 webpack-bundle-analyzer 了。<br>1、安装依赖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure><p>2、在 vue.config.js 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    config.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后，我们可以看到这样一份依赖图</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/10/171fc78ad5a37759?w=1909&amp;h=931&amp;f=png&amp;s=235323" alt=""></p><p>从以上的界面中，我们可以得到以下信息：</p><ul><li>打包出的文件中都包含了什么，以及模块之间的依赖关系</li><li>每个文件的大小在总体中的占比，找出较大的文件，思考是否有替换方案，是否使用了它包含了不必要的依赖？</li><li>是否有重复的依赖项，对此可以如何优化？</li><li>每个文件的压缩后的大小。</li></ul><h2 id="CDN-资源优化"><a href="#CDN-资源优化" class="headerlink" title="CDN 资源优化"></a>CDN 资源优化</h2><p>CDN 的全称是 <code>Content Delivery Network</code>，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。</p><p>随着项目越做越大，依赖的第三方 npm 包越来越多，构建之后的文件也会越来越大。再加上又是单页应用，这就会导致在网速较慢或者服务器带宽有限的情况出现长时间的白屏。此时我们可以使用 CDN 的方法，优化网络加载速度。</p><p>1、将 <code>vue、vue-router、vuex、axios</code> 这些 vue 全家桶的资源，全部改为通过 CDN 链接获取，在 <code>index.html</code> 里插入 相应链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/axios/0.19.0-beta.1/axios.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue-router/3.0.2/vue-router.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/element-ui/2.6.1/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、在 <code>vue.config.js</code> 配置 externals 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> ···</span><br><span class="line">    externals: &#123;</span><br><span class="line">      <span class="string">'vue'</span>: <span class="string">'Vue'</span>,</span><br><span class="line">      <span class="string">'vuex'</span>: <span class="string">'Vuex'</span>,</span><br><span class="line">      <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">      <span class="string">'axios'</span>:<span class="string">'axios'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>3、卸载相关依赖的 npm 包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> uninstall  vue vue-router vuex axios</span><br></pre></td></tr></table></figure><p>此时启动项目运行就可以了。我们在控制台就能发现项目加载了以上四个 CDN 资源。</p><p>不过现在有不少声音说，vue 全家桶加载 CDN 资源其实作用并不大，而且公共的 CDN 资源也没有 npm 包那么稳定，这个就见仁见智了。所以我在源码时新建的分支做这个优化。当项目较小的就不考虑 CDN 优化了。</p><p>当然，当引入其他较大第三方资源，比如 echarts，AMAP(高德地图)，采用 CDN 资源还是很有必要的。</p><h2 id="gZip-加速优化"><a href="#gZip-加速优化" class="headerlink" title="gZip 加速优化"></a>gZip 加速优化</h2><p>所有现代浏览器都支持 gzip 压缩，启用 gzip 压缩可大幅缩减传输资源大小，从而缩短资源下载时间，减少首次白屏时间，提升用户体验。</p><p>gzip 对基于文本格式文件的压缩效果最好（如：CSS、JavaScript 和 HTML），在压缩较大文件时往往可实现高达 70-90% 的压缩率，对已经压缩过的资源（如：图片）进行 gzip 压缩处理，效果很不好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    config.plugins.push(</span><br><span class="line">      <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">        <span class="comment">// gzip压缩配置</span></span><br><span class="line">        test: <span class="regexp">/\.js$|\.html$|\.css/</span>, <span class="comment">// 匹配文件名</span></span><br><span class="line">        threshold: <span class="number">10240</span>, <span class="comment">// 对超过10kb的数据进行压缩</span></span><br><span class="line">        deleteOriginalAssets: <span class="literal">false</span>, <span class="comment">// 是否删除原文件</span></span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="首页添加骨架屏"><a href="#首页添加骨架屏" class="headerlink" title="首页添加骨架屏"></a>首页添加骨架屏</h2><p>随着 SPA 在前端界的逐渐流行，单页面应用不可避免地给首页加载带来压力，此时良好的首页用户体验至关重要。很多 APP 采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。</p><p>所谓的骨架屏，就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。在这个过程中用户会感知到内容正在逐渐加载并即将呈现，降低了“白屏”的不良体验。</p><p>本文采用vue-skeleton-webpack-plugin插件为单页面应用注入骨架屏。  </p><p>1、在src的common文件夹下面创建了Skeleton1.vue，Skeleton2.vue，具体的结构和样式自行设计，此处省略一万字。。。。</p><p>2、在同级目录下新建entry-skeleton.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Skeleton1 <span class="keyword">from</span> <span class="string">'./Skeleton1'</span></span><br><span class="line"><span class="keyword">import</span> Skeleton2 <span class="keyword">from</span> <span class="string">'./Skeleton2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Skeleton1,</span><br><span class="line">    Skeleton2</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;skeleton1 id="skeleton1" style="display:none"/&gt;</span></span><br><span class="line"><span class="string">      &lt;skeleton2 id="skeleton2" style="display:none"/&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在vue.config.js下配置插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SkeletonWebpackPlugin = <span class="built_in">require</span>(<span class="string">'vue-skeleton-webpack-plugin'</span>)</span><br><span class="line">configureWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  config.plugins.push(</span><br><span class="line">    <span class="keyword">new</span> SkeletonWebpackPlugin(&#123;</span><br><span class="line">      webpackConfig: &#123;</span><br><span class="line">        entry: &#123;</span><br><span class="line">          app: path.join(__dirname, <span class="string">'./src/common/entry-skeleton.js'</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      minimize: <span class="literal">true</span>,</span><br><span class="line">      quiet: <span class="literal">true</span>,</span><br><span class="line">      router: &#123;</span><br><span class="line">        mode: <span class="string">'hash'</span>,</span><br><span class="line">        routes: [</span><br><span class="line">          &#123; <span class="attr">path</span>: <span class="string">'/'</span>, <span class="attr">skeletonId</span>: <span class="string">'skeleton1'</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">path</span>: <span class="string">'/about'</span>, <span class="attr">skeletonId</span>: <span class="string">'skeleton2'</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时重新加载页面就可以看到我们的骨架屏了。<strong>注意：一定要配置样式分离extract: true</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这是基于 vue-cli4 实现的移动端框架，其中包含项目常用的配置，组件封装及webpack优化方法，可供快速开发使用。&lt;/p&gt;
&lt;p&gt;技术栈：vue-cli4 + webpack4 + vant + axios + less + postcss-px2rem&lt;/p&gt;
&lt;p&gt;源码 &lt;a href=&quot;https://github.com/Michael-lzg/vue-cli4-vant&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Michael-lzg/vue-cli4-vant&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 安装依赖&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 本地启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm run dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 生产打包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm run build&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
      <category term="vue" scheme="https://chongdee.github.io/categories/webpack/vue/"/>
    
    
      <category term="vue" scheme="https://chongdee.github.io/tags/vue/"/>
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>react-webpack4配置与优化</title>
    <link href="https://chongdee.github.io/2021/05/09/Webpack/react-webpack4%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://chongdee.github.io/2021/05/09/Webpack/react-webpack4配置与优化/</id>
    <published>2021-05-08T17:08:22.403Z</published>
    <updated>2021-05-08T17:14:54.323Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一篇文章不写前言总感觉不太正式，大概介绍下我是怎么完成一个总的知识点的概括的把。其实很多人都有一看就会,一做就废的特点(当然也包括我在内),这个时候，你需要制定一个略微详细的计划，就比如我这篇会首先列出知识点，列出大的方向，制定思维导图，然后根据思维导图编写代码，计划明确，就会事半功倍，因此，希望你可以跟着本篇循序渐进的跟着代码走一遍，不管是真实开发，还是面试，都有的扯。好了，不扯了，可以先看下目录。现在开始</p><h2 id="一、基础配置"><a href="#一、基础配置" class="headerlink" title="一、基础配置"></a>一、基础配置</h2><h3 id="1、init项目"><a href="#1、init项目" class="headerlink" title="1、init项目"></a>1、init项目</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mkdir</span> react-webpack4-cook</span><br><span class="line"><span class="keyword">cd</span> react-webpack4-cook</span><br><span class="line"><span class="keyword">mkdir</span> src</span><br><span class="line"><span class="keyword">mkdir</span> dist</span><br><span class="line">npm init -<span class="built_in">y</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2、安装webpack"><a href="#2、安装webpack" class="headerlink" title="2、安装webpack"></a>2、安装webpack</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack webpack-cli webpack-dev-server -D <span class="comment">//webpack4把webpack拆分了</span></span><br><span class="line">touch webpack.config.js</span><br><span class="line"><span class="comment">// webpack.config.js初始化内容</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line"><span class="symbol">    mode:</span> <span class="string">"development"</span>,</span><br><span class="line"><span class="symbol">    entry:</span> [<span class="string">"./src/index.js"</span>],</span><br><span class="line"><span class="symbol">    output:</span> &#123;</span><br><span class="line">        <span class="comment">// 输出目录</span></span><br><span class="line"><span class="symbol">        path:</span> path.join(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">        <span class="comment">// 文件名称</span></span><br><span class="line"><span class="symbol">        filename:</span> <span class="string">"bundle.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="symbol">    module:</span>&#123;&#125;,</span><br><span class="line"><span class="symbol">    plugins:</span>[],</span><br><span class="line"><span class="symbol">    devServer:</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、安装react并编写代码"><a href="#3、安装react并编写代码" class="headerlink" title="3、安装react并编写代码"></a>3、安装react并编写代码</h3><p>这部分代码篇幅过多，就是一些简单的react和react-router的一些代码编写，可以去github上查看，这里只阐述基本功能</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> src </span><br><span class="line">cnpm i react react-router-dom -<span class="built_in">S</span></span><br><span class="line"><span class="comment">// 建立如下的文件目录，并编写安装react和react-router并编写react代码如下</span></span><br><span class="line">|-src</span><br><span class="line">│      index.js 主文件</span><br><span class="line">├───pages</span><br><span class="line">│      <span class="keyword">Count</span>.jsx -- 实现了一个计数器的功能，点击按钮，会让数字增加，按钮会实时显示在页面上</span><br><span class="line">│      Home.jsx -- 一个简单的文字展示</span><br><span class="line">└───router</span><br><span class="line">       index.js -- 路由配置文件，两个页面分别对应两个路由 <span class="keyword">count</span>和 home</span><br></pre></td></tr></table></figure><h3 id="4、babel编译ES6-JSX等"><a href="#4、babel编译ES6-JSX等" class="headerlink" title="4、babel编译ES6,JSX等"></a>4、babel编译ES6,JSX等</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> @babel/core-babel核心模块    @babel/preset-env-编译ES6等 @babel/preset-react-转换JSX</span><br><span class="line">cnpm i babel-loader @babel/core @babel/preset-env  @babel/plugin-transform-runtime   @babel/preset-react -D</span><br><span class="line"><span class="regexp">//</span> @babel/plugin-transform-runtime: 避免 polyfill 污染全局变量，减小打包体积</span><br><span class="line"><span class="regexp">//</span> @babel/polyfill: ES6 内置方法和函数转化垫片</span><br><span class="line">cnpm i @babel/polyfill @babel/runtime</span><br><span class="line"> &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">"babel-loader"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>新建.babelrc文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>,<span class="string">"@babel/preset-react"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、按需引入polyfill"><a href="#5、按需引入polyfill" class="headerlink" title="5、按需引入polyfill"></a>5、按需引入polyfill</h3><p>在src下的index.js中全局引入 @babel/polyfill 并写入 ES6 语法 ，但是这样有一个缺点：</p><p>全局引入 @babel/polyfill 的这种方式可能会导入代码中不需要的 polyfill，从而使打包体积更大<br>更改 .babelrc，只转译我们使用到的</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install core-js@2 @babel/runtime-corejs2 -S</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>,</span><br><span class="line">              &#123; <span class="string">"useBuiltIns"</span>: <span class="string">"usage"</span> &#125;,</span><br><span class="line">              <span class="string">"@babel/preset-react"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">将将全局引入这段代码注释掉</span><br><span class="line">// import <span class="string">'@babel/polyfill'</span></span><br></pre></td></tr></table></figure><p>这就配置好了按需引入。配置了按需引入 polyfill 后，用到es6以上的函数，babel会自动导入相关的polyfill，这样能大大减少 打包编译后的体积</p><h3 id="5、插件-CleanWebpackPlugin"><a href="#5、插件-CleanWebpackPlugin" class="headerlink" title="5、插件 CleanWebpackPlugin"></a>5、插件 CleanWebpackPlugin</h3><p>你经过多次打包后会发现，每次打包都会在dist目录下边生成一堆文件，但是上一次的打包的文件还在，我们需要每次打包时清除 dist 目录下旧版本文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cnpm install  clean-webpack-plugin -D</span><br><span class="line"><span class="comment">// 注意这个引入的坑，最新版的需要这样引入，而不是直接const CleanWebpackPlugin</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"> </span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin() </span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="6、使用插件-HtmlWebpackPlugin"><a href="#6、使用插件-HtmlWebpackPlugin" class="headerlink" title="6、使用插件 HtmlWebpackPlugin"></a>6、使用插件 HtmlWebpackPlugin</h3><p>经过上一步的操作，index.html 也被清除了。因此我们将使用 HtmlWebpackPlugin插件，来生成 html， 并将每次打包的js自动插入到你的 index.html 里面去，而且它还可以基于你的某个 html 模板来创建最终的 index.html，也就是说可以指定模板哦</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">cnpm install html-webpack-plugin -D</span></span><br><span class="line"><span class="xml">// 创建template.html</span></span><br><span class="line"><span class="xml">cd src</span></span><br><span class="line"><span class="xml">touch template.html</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">// 内容如下</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>react-webpack4-cook<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">// webpack.config.js做出更改</span></span><br><span class="line"><span class="xml">const HtmlWebpackPlugin = require('html-webpack-plugin');</span></span><br><span class="line"><span class="xml">plugins: [</span></span><br><span class="line"><span class="xml">    new CleanWebpackPlugin(),</span></span><br><span class="line"><span class="xml">    new HtmlWebpackPlugin(</span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">      filename: 'index.html', // 最终创建的文件名</span></span><br><span class="line"><span class="template-variable">      template: path.join(__dirname, 'src/template.html') // 指定模板路径</span></span><br><span class="line"><span class="template-variable">    &#125;</span><span class="xml">)</span></span><br><span class="line"><span class="xml">  ]</span></span><br></pre></td></tr></table></figure><h3 id="7、使用-source-map-对devtool进行优化"><a href="#7、使用-source-map-对devtool进行优化" class="headerlink" title="7、使用 source-map,对devtool进行优化"></a>7、使用 source-map,对devtool进行优化</h3><p>webpack中devtool选项用来控制是否生成，以及如何生成 source map。简言之，source map就是帮助我们定位到错误信息位置的文件。正确的配置source map，能够提高开发效率，更快的定位到错误位置。</p><p>在webpack.config.js中选项mode下加上如下这句话：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">devtool:</span><span class="string">"cheap-module-eval-source-map"</span>,<span class="comment">// 开发环境配置</span></span><br><span class="line"><span class="symbol">devtool:</span><span class="string">"cheap-module-source-map"</span>,   <span class="comment">// 线上生成配置</span></span><br></pre></td></tr></table></figure><h3 id="8、使用-WebpackDevServer"><a href="#8、使用-WebpackDevServer" class="headerlink" title="8、使用 WebpackDevServer"></a>8、使用 WebpackDevServer</h3><p>webpack-dev-server就是在本地为搭建了一个小型的静态文件服务器，有实时重加载的功能，为将打包生成的资源提供了web服务</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">devServer:</span> &#123;</span><br><span class="line"><span class="symbol">    hot:</span> true,</span><br><span class="line"><span class="symbol">    contentBase:</span> path.join(__dirname, <span class="string">"./dist"</span>),</span><br><span class="line"><span class="symbol">    host:</span> <span class="string">"0.0.0.0"</span>, <span class="comment">// 可以使用手机访问</span></span><br><span class="line"><span class="symbol">    port:</span> <span class="number">8080</span>,</span><br><span class="line"><span class="symbol">    historyApiFallback:</span> true, <span class="comment">// 该选项的作用所有的404都连接到index.html</span></span><br><span class="line"><span class="symbol">    proxy:</span> &#123;</span><br><span class="line">      <span class="comment">// 代理到后端的服务地址，会拦截所有以api开头的请求地址</span></span><br><span class="line">      <span class="string">"/api"</span>: <span class="string">"http://localhost:3000"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="9、使用-HotModuleReplacement-热模块替换HMR"><a href="#9、使用-HotModuleReplacement-热模块替换HMR" class="headerlink" title="9、使用 HotModuleReplacement (热模块替换HMR)"></a>9、使用 HotModuleReplacement (热模块替换HMR)</h3><p>建立了开发环境本地服务器 后，当修改内容后，网页会同步刷新，我们现在进入toCOunt页面</p><ol><li><p>点击按钮，将数字加到一个不为0的数，比如加到6</p></li><li><p>然后你可以在代码中改变按钮的文字，随便改点东西，会发现，页面刷新后，数字重新变为0</p></li></ol><p>这显然不是我们想要的，想要的是，能不能把页面的状态保存了，也就是更改了代码后，页面还是保存了数字为6的状态，也就是实现局部更改，首先需要用到：HotModuleReplacementPlugin插件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    hot:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">plugins:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">new</span> <span class="string">webpack.HotModuleReplacementPlugin()</span></span><br><span class="line"><span class="string">],</span></span><br></pre></td></tr></table></figure><p>完事之后，继续更上边的操作，点击按钮，数字增加，然后更改内容，发现还是没有保存状态。。。what？怎么办</p><p>对@！这还没完呢，接着往下看，我们还需要react-hot-loader这个插件</p><h3 id="10、react-hot-loader记录react页面留存状态state"><a href="#10、react-hot-loader记录react页面留存状态state" class="headerlink" title="10、react-hot-loader记录react页面留存状态state"></a>10、react-hot-loader记录react页面留存状态state</h3><p>我们继续接着上边的进行操作，分一下四步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cnpm i react-hot-loader -D</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在主文件里这样写</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">"react-hot-loader"</span>;------------------<span class="number">-1</span>、首先引入AppContainre</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"./router"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*初始化*/</span></span><br><span class="line">renderWithHotReload(Router);------------------<span class="number">-2</span>、初始化</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*热更新*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;------------------<span class="number">-3</span>、热更新操作</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">"./router/index.js"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">"./router/index.js"</span>).default;</span><br><span class="line">    renderWithHotReload(Router);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderWithHotReload</span>(<span class="params">Router</span>) </span>&#123;------------------<span class="number">-4</span>、定义渲染函数</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;AppContainer&gt;</span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Router /&gt;</span><br><span class="line">      &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>AppContainer&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在你再试试</p><h3 id="11、编译css和scss"><a href="#11、编译css和scss" class="headerlink" title="11、编译css和scss"></a>11、编译css和scss</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cnpm install css-loader style-loader sass-loader node-sass -<span class="built_in">D</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">test</span>: /\.scss$/,</span><br><span class="line">    <span class="keyword">use</span>: [</span><br><span class="line">      <span class="string">"style-loader"</span>, <span class="comment">// 创建style标签，并将css添加进去</span></span><br><span class="line">      <span class="string">"css-loader"</span>, <span class="comment">// 编译css</span></span><br><span class="line">      <span class="string">"sass-loader"</span> <span class="comment">// 编译scss</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、集成postcss"><a href="#12、集成postcss" class="headerlink" title="12、集成postcss"></a>12、集成postcss</h3><p>最关心的还是这有啥用啊？自动增加前缀， postcss-cssnext允许你使用未来的css特性，并做一些兼容处理</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cnpm install  postcss-loader postcss-cssnext -<span class="built_in">D</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">test</span>: /\.scss$/,</span><br><span class="line">        <span class="keyword">use</span>: [</span><br><span class="line">            <span class="string">"style-loader"</span>, <span class="comment">// 创建style标签，并将css添加进去</span></span><br><span class="line">            <span class="string">"css-loader"</span>, <span class="comment">// 编译css</span></span><br><span class="line">            <span class="string">"postcss-loader"</span>,</span><br><span class="line">            <span class="string">"sass-loader"</span> <span class="comment">// 编译scss</span></span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在刚才的home.scss 加上 transform: scale(2);</span></span><br><span class="line">通过控制台查看，已经自动加上了前缀</span><br></pre></td></tr></table></figure><h3 id="13、处理图片"><a href="#13、处理图片" class="headerlink" title="13、处理图片"></a>13、处理图片</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cnpm</span> <span class="selector-tag">i</span> <span class="selector-tag">file-loader</span> <span class="selector-tag">url-loader</span> <span class="selector-tag">-D</span></span><br><span class="line"> </span><br><span class="line"><span class="selector-tag">file-loader</span> 解决<span class="selector-tag">css</span>等文件中引入图片路径的问题</span><br><span class="line"><span class="selector-tag">url-loader</span> 当图片较小的时候会把图片<span class="selector-tag">BASE64</span>编码，大于<span class="selector-tag">limit</span>参数的时候还是使用<span class="selector-tag">file-loader</span> 进行拷贝</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">test</span>: /\.(png|jpg|jpeg|gif|svg)/,</span><br><span class="line">    <span class="attribute">use</span>: &#123;</span><br><span class="line">      <span class="attribute">loader</span>: <span class="string">'url-loader'</span>,</span><br><span class="line">      <span class="attribute">options</span>: &#123;</span><br><span class="line">        <span class="attribute">outputPath</span>: <span class="string">'images/'</span>, <span class="comment">// 图片输出的路径</span></span><br><span class="line">        <span class="attribute">limit</span>: <span class="number">10</span> * <span class="number">1024</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14、处理字体"><a href="#14、处理字体" class="headerlink" title="14、处理字体"></a>14、处理字体</h3><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test: /\.(<span class="name">eot</span>|woff2?|ttf|svg)$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: 'url-loader',</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: '[name]-[hash:5].min.[ext]',</span><br><span class="line">              limit: <span class="number">5000</span>, // fonts file size &lt;= <span class="number">5</span>KB, use 'base64'; else, output svg file</span><br><span class="line">              publicPath: 'fonts/',</span><br><span class="line">              outputPath: 'fonts/'</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="二、webpack优化"><a href="#二、webpack优化" class="headerlink" title="二、webpack优化"></a>二、webpack优化</h2><h3 id="1、alias对文件路径优化"><a href="#1、alias对文件路径优化" class="headerlink" title="1、alias对文件路径优化"></a>1、alias对文件路径优化</h3><ol><li>extension: 指定extension之后可以不用在require或是import的时候加文件扩展名,会依次尝试添加扩展名进行匹配</li><li>alias: 配置别名可以加快webpack查找模块的速度</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">resolve</span>: &#123;</span><br><span class="line">    <span class="attribute">extension</span>: [<span class="string">""</span>, <span class="string">".js"</span>, <span class="string">".jsx"</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">"@"</span>: path.<span class="built_in">join</span>(__dirname, <span class="string">"src"</span>),</span><br><span class="line">      pages: path.<span class="built_in">join</span>(__dirname, <span class="string">"src/pages"</span>),</span><br><span class="line">      router: path.<span class="built_in">join</span>(__dirname, <span class="string">"src/router"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="14、使用静态资源路径publicPath-CDN"><a href="#14、使用静态资源路径publicPath-CDN" class="headerlink" title="14、使用静态资源路径publicPath(CDN)"></a>14、使用静态资源路径publicPath(CDN)</h3><p>CDN通过将资源部署到世界各地，使得用户可以就近访问资源，加快访问速度。要接入CDN，需要把网页的静态资源上传到CDN服务上，在访问这些资源时，使用CDN服务提供的URL。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">output</span>:&#123;</span><br><span class="line"> <span class="attribute">publicPatch</span>: <span class="string">'//【cdn】.com'</span>, //指定存放JS文件的CDN地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、MiniCssExtractPlugin-，抽取-css-文件"><a href="#2、MiniCssExtractPlugin-，抽取-css-文件" class="headerlink" title="2、MiniCssExtractPlugin ，抽取 css 文件"></a>2、MiniCssExtractPlugin ，抽取 css 文件</h3><p>如果不做配置，我们的css是直接打包进js里面的，我们希望能单独生成css文件。 因为单独生成css,css可以和js并行下载，提高页面加载效率</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cnpm install mini-css-extract-plugin -D</span><br><span class="line"> </span><br><span class="line">const MiniCssExtractPlugin = require(<span class="string">"mini-css-extract-plugin"</span>);</span><br><span class="line"> </span><br><span class="line"> &#123;</span><br><span class="line"><span class="symbol">        test:</span> /\.scss$/,</span><br><span class="line"><span class="symbol">        use:</span> [</span><br><span class="line">          <span class="comment">// "style-loader", // b不再需要style-loader要已经分离处理</span></span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          <span class="string">"css-loader"</span>, <span class="comment">// 编译css</span></span><br><span class="line">          <span class="string">"postcss-loader"</span>,</span><br><span class="line">          <span class="string">"sass-loader"</span> <span class="comment">// 编译scss</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"> </span><br><span class="line"><span class="symbol"> plugins:</span> [</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line"><span class="symbol">      filename:</span> <span class="string">"[name].css"</span>,</span><br><span class="line"><span class="symbol">      chunkFilename:</span> <span class="string">"[id].css"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h3 id="3、代码分割按需加载、提取公共代码"><a href="#3、代码分割按需加载、提取公共代码" class="headerlink" title="3、代码分割按需加载、提取公共代码"></a>3、代码分割按需加载、提取公共代码</h3><p>为什么要实现按需加载？</p><p>我们现在看到，打包完后，所有页面只生成了一个bundle.js,当我们首屏加载的时候，就会很慢。因为他也下载了别的页面的js了,也就是说，执行完毕之前，页面是 完！全！空！白！的！。 如果每个页面单独打包自己的js，就可以在进入页面时候再加载自己 的js，首屏加载就可以快很多</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">optimization</span>: &#123;</span><br><span class="line">    <span class="attribute">splitChunks</span>: &#123;</span><br><span class="line">      chunks: <span class="string">"all"</span>, // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="5、文件压缩"><a href="#5、文件压缩" class="headerlink" title="5、文件压缩"></a>5、文件压缩</h3><p>webpack4只要在生产模式下， 代码就会自动压缩</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">mode:</span>productioin</span><br></pre></td></tr></table></figure><h3 id="6、暴露全局变量"><a href="#6、暴露全局变量" class="headerlink" title="6、暴露全局变量"></a>6、暴露全局变量</h3><p>可以直接在全局使用$变量</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      $: <span class="string">'jquery'</span>, <span class="comment">// npm</span></span><br><span class="line">      jQuery: <span class="string">'jQuery'</span> <span class="comment">// 本地Js文件</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="8、指定环境-定义环境变量"><a href="#8、指定环境-定义环境变量" class="headerlink" title="8、指定环境,定义环境变量"></a>8、指定环境,定义环境变量</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">plugins:</span> [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: &#123;</span><br><span class="line"><span class="symbol">        VUEP_BASE_URL:</span> JSON.stringify(<span class="string">'http://localhost:9000'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="9、css-Tree-Shaking"><a href="#9、css-Tree-Shaking" class="headerlink" title="9、css Tree Shaking"></a>9、css Tree Shaking</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">npm i <span class="built_in">glob</span>-<span class="keyword">all</span> purify-css purifycss-webpack --save-dev</span><br><span class="line"> </span><br><span class="line">const PurifyCSS = require(<span class="string">'purifycss-webpack'</span>)</span><br><span class="line">const <span class="built_in">glob</span> = require(<span class="string">'glob-all'</span>)</span><br><span class="line">plugin<span class="variable">s:</span>[</span><br><span class="line">    // 清除无用 css</span><br><span class="line">    <span class="keyword">new</span> PurifyCSS(&#123;</span><br><span class="line">      path<span class="variable">s:</span> <span class="built_in">glob</span>.<span class="keyword">sync</span>([</span><br><span class="line">        // 要做 CSS Tree Shaking 的路径文件</span><br><span class="line">        path.<span class="built_in">resolve</span>(__dirname, <span class="string">'./src/*.html'</span>), // 请注意，我们同样需要对 html 文件进行 tree shaking</span><br><span class="line">        path.<span class="built_in">resolve</span>(__dirname, <span class="string">'./src/*.js'</span>)</span><br><span class="line">      ])</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="10、js-Tree-Shaking"><a href="#10、js-Tree-Shaking" class="headerlink" title="10、js Tree Shaking"></a>10、js Tree Shaking</h3><p>清除到代码中无用的js代码，只支持import方式引入，不支持commonjs的方式引入</p><p><strong>只要mode是production就会生效，develpoment的tree shaking是不生效的，因为webpack为了方便你的调试</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">optimization</span>: &#123;</span><br><span class="line">    <span class="attribute">usedExports</span>:true,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="11、DllPlugin插件打包第三方类库"><a href="#11、DllPlugin插件打包第三方类库" class="headerlink" title="11、DllPlugin插件打包第三方类库"></a>11、DllPlugin插件打包第三方类库</h3><p>项目中引入了很多第三方库，这些库在很长的一段时间内，基本不会更新，打包的时候分开打包来提升打包速度，而DllPlugin动态链接库插件，其原理就是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取。</p><p>安装jquery，并在入口文件引入。新建webpack.dll.config.js文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @desc 静态公共资源打包配置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = require(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = require(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> src = path.resolve(<span class="built_in">process</span>.cwd(), <span class="string">'src'</span>); <span class="comment">// 源码目录</span></span><br><span class="line"><span class="keyword">const</span> evn = <span class="built_in">process</span>.env.NODE_ENV == <span class="string">"production"</span> ? <span class="string">"production"</span> : <span class="string">"development"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">'production'</span>,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        <span class="comment">// 定义程序中打包公共文件的入口文件vendor.js</span></span><br><span class="line">        jquery: [<span class="string">'jquery'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'dll'</span>),</span><br><span class="line">        filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">        library: <span class="string">'[name]_[hash]'</span>,</span><br><span class="line">        libraryTarget: <span class="string">'this'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            <span class="comment">// 定义程序中打包公共文件的入口文件vendor.js</span></span><br><span class="line">            context: <span class="built_in">process</span>.cwd(),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// manifest.json文件的输出位置</span></span><br><span class="line">            path: path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'dll/[name]-manifest.json'</span>),</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义打包的公共vendor文件对外暴露的函数名</span></span><br><span class="line">            name: <span class="string">'[name]_[hash]'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在package.json中添加</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"build:dll"</span>: <span class="string">"webpack --config ./build/webpack.dll.config.js"</span>,</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">run</span><span class="bash"> build:dll</span></span><br></pre></td></tr></table></figure><p>你会发现多了一个dll文件夹，里边有dll.js文件，这样我们就把我们的jquery这些已经单独打包了，接下来怎么使用呢？</p><p>需要再安装一个依赖 npm i add-asset-html-webpack-plugin，它会将我们打包后的 dll.js 文件注入到我们生成的 index.html 中.在 webpack.base.config.js 文件中进行更改。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">AddAssetHtmlWebpackPlugin</span>(&#123;</span><br><span class="line"> <span class="attribute">filepath</span>: path.<span class="built_in">resolve</span>(__dirname, <span class="string">'../dll/jquery.dll.js'</span>) // 对应的 dll 文件路径</span><br><span class="line"> &#125;),</span><br><span class="line"> <span class="selector-tag">new</span> <span class="selector-tag">webpack</span><span class="selector-class">.DllReferencePlugin</span>(&#123;</span><br><span class="line"> <span class="attribute">manifest</span>: path.<span class="built_in">resolve</span>(__dirname, <span class="string">'..'</span>, <span class="string">'dll/jquery-manifest.json'</span>)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>好了，你可有吧new webpack.DllReferencePlugin这个插件注释掉，打包试下，在放开打包试一下，我测试结果，注释钱5689，注释后，5302ms，才差了300ms?注意，我这里只有一个jquery包作为演示，要是你把很多个都抽离了出来呢？？？那岂不是很恐怖了。如果你看的有点迷迷糊糊，那推荐去线上看一下我的代码吧，一看便知</p><h3 id="12、使用happypack并发执行任务"><a href="#12、使用happypack并发执行任务" class="headerlink" title="12、使用happypack并发执行任务"></a>12、使用happypack并发执行任务</h3><p>运行在 Node.之上的Webpack是单线程模型的，也就是说Webpack需要一个一个地处理任务，不能同时处理多个任务。 Happy Pack 就能让Webpack做到这一点，它将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cnpm i -D happypack</span><br><span class="line"> </span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"> rules: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="comment">// cnpm i babel-loader @babel/core @babel/preset-env -D</span></span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">        <span class="keyword">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 一个loader对应一个id</span></span><br><span class="line">            loader: <span class="string">"happypack/loader?id=busongBabel"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      ]</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在plugins中增加</span></span><br><span class="line">plugins:[</span><br><span class="line">      <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      <span class="comment">// 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件</span></span><br><span class="line">      id:<span class="string">'busongBabel'</span>,</span><br><span class="line">      <span class="comment">// 如何处理.js文件，用法和Loader配置中一样</span></span><br><span class="line">      loaders:[<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">      threadPool: HappyPackThreadPool,</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="13、PWA优化策略"><a href="#13、PWA优化策略" class="headerlink" title="13、PWA优化策略"></a>13、PWA优化策略</h3><p>简言之：在你第一次访问一个网站的时候，如果成功，做一个缓存，当服务器挂了之后，你依然能够访问这个网页 ，这就是PWA。那相信你也已经知道了，这个只需要在生产环境，才需要做PWA的处理，以防不测。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cnpm i workbox-webpack-plugin -D</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WorkboxPlugin = <span class="built_in">require</span>(<span class="string">'workbox-webpack-plugin'</span>) <span class="comment">// 引入 PWA 插件</span></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 配置 PWA</span></span><br><span class="line">    <span class="keyword">new</span> WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">      clientsClaim: <span class="literal">true</span>,</span><br><span class="line">      skipWaiting: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在入口文件加上</span><br><span class="line"><span class="comment">// 判断该浏览器支不支持 serviceWorker</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    navigator.serviceWorker</span><br><span class="line">      .register(<span class="string">'/service-worker.js'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">registration</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service-worker registed'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service-worker registed error'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完后，你可以打包到dist目录下，在dist目录下启动一个静态服务器，访问首页，然后关闭这个服务器，你会惊讶的发现：网站竟然还能够访问，哈哈，是不是很神奇？</p><h3 id="15、合并提取webpack公共配置"><a href="#15、合并提取webpack公共配置" class="headerlink" title="15、合并提取webpack公共配置"></a>15、合并提取webpack公共配置</h3><p> 开发环境与生产环境以及webpack配置文件的分离，具体需要用到webpack-merge，用来 合并 webpack配置</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一篇文章不写前言总感觉不太正式，大概介绍下我是怎么完成一个总的知识点的概括的把。其实很多人都有一看就会,一做就废的特点(当然也包括我在内),这个时候，你需要制定一个略微详细的计划，就比如我这篇会首先列出知识点，列出大的方向，制定思维导图，然后根据思维导图编写代码，计划明确，就会事半功倍，因此，希望你可以跟着本篇循序渐进的跟着代码走一遍，不管是真实开发，还是面试，都有的扯。好了，不扯了，可以先看下目录。现在开始&lt;/p&gt;
&lt;h2 id=&quot;一、基础配置&quot;&gt;&lt;a href=&quot;#一、基础配置&quot; class=&quot;headerlink&quot; title=&quot;一、基础配置&quot;&gt;&lt;/a&gt;一、基础配置&lt;/h2&gt;&lt;h3 id=&quot;1、init项目&quot;&gt;&lt;a href=&quot;#1、init项目&quot; class=&quot;headerlink&quot; title=&quot;1、init项目&quot;&gt;&lt;/a&gt;1、init项目&lt;/h3&gt;&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mkdir&lt;/span&gt; react-webpack4-cook&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;cd&lt;/span&gt; react-webpack4-cook&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mkdir&lt;/span&gt; src&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;mkdir&lt;/span&gt; dist&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm init -&lt;span class=&quot;built_in&quot;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="webpack" scheme="https://chongdee.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://chongdee.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
